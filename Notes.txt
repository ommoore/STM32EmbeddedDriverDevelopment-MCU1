/****************************************************************************************/
								Section05_HelloWorld
/****************************************************************************************/
main.c
extern void initialise_monitor_handles(void);

syscalls.c
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//					Implementation of printf like feature using ARM Cortex M3/M4/ ITM functionality
//					This function will not work for ARM Cortex M0/M0+
//					If you are using Cortex M0, then you can use semihosting feature of openOCD
/////////////////////////////////////////////////////////////////////////////////////////////////////////

//Debug Exception and Monitor Control Register base address
#define DEMCR        			*((volatile uint32_t*) 0xE000EDFCU )

/* ITM register addresses */
#define ITM_STIMULUS_PORT0   	*((volatile uint32_t*) 0xE0000000 )
#define ITM_TRACE_EN          	*((volatile uint32_t*) 0xE0000E00 )

void ITM_SendChar(uint8_t ch)
{

	//Enable TRCENA
	DEMCR |= ( 1 << 24);

	//enable stimulus port 0
	ITM_TRACE_EN |= ( 1 << 0);

	// read FIFO status in bit [0]:
	while(!(ITM_STIMULUS_PORT0 & 1));

	//Write to ITM stimulus port0
	ITM_STIMULUS_PORT0 = ch;
}

/* Functions */
void initialise_monitor_handles()
{
}

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
	{
		//__io_putchar(*ptr++);
		ITM_SendChar(*ptr++);
	}
	return len;
}

/****************************************************************************************/
								Section05_HelloWorldSemiHosting
/****************************************************************************************/
main.c
/*
 * OpenOCD Debugger and Semi-hosting
 *
 * Set the linker arguments:
 * 	. -specs=rdimon.specs -lc -lrdimon
 *
 * Add semi-hosting run command:
 * 	. monitor arm semihosting enable
 *
 * Add the below function call to main.c
 * 	. extern void initialise_monitor_handles(void);
 * 	. initialise_monitor_handles(void);
 */
 
extern void initialise_monitor_handles(void);
 
int main(void)
{
	initialise_monitor_handles();

	printf("Hello World\n");

	for(;;);
}
/****************************************************************************************/
								Section06_Debug_Tips_and_Tricks
/****************************************************************************************/

#include <stdio.h>
#include<stdlib.h>
#include<string.h>

int numbers[] = { 456,345,678,567,890,456,3456,123,765,456,896,456,678,987,000,145,90};

int someData = 90;

void array_fill_numbers(int pNumbers[], unsigned int len)
{

    for ( unsigned int i = 0 ; i < len ; i++)
    {
        pNumbers[i] = rand() % 1000;
    }

}

void display_numbers(int *pNumbers, unsigned int len, char *pMessage)
{
    printf("%s",pMessage);

    for (unsigned i = 0 ; i < len ; i++)
    {
        printf("%5d  ",pNumbers[i]);
    }

    printf("\n");
}


void swap_numbers(int *x,int *y)
{
     int temp=*x;
     *x=*y;
     *y=temp;

#if 0
     void (*jump_addr) (void);
     jump_addr = (void*)0x20000009;
     jump_addr();
#endif

     someData = 10;
}


void bubble_sort(int *pNumbers , unsigned int len)
{
    int i,j,flag=0;

    for(i=0;i<len-1;i++)
    {
        flag=0;

        for(j=0;j<len-1-i;j++)
        {
            if(pNumbers[j] > pNumbers[j+1])
            {
                swap_numbers(&pNumbers[j],&pNumbers[j+1]);
                flag=1;
            }
        }

        if(flag==0)
            break;
    }
}

void insertion_sort(int *pNumbers , unsigned int len)
{
     int i,j,num;

     for(i=1 ; i<len ; i++)
     {
         j=i-1;

         num = pNumbers[i];

         while( (j>-1) && (pNumbers[j] > num) )
         {
             pNumbers[j+1] = pNumbers[j];
             j--;
         }

         pNumbers[j+1]=num;
     }
}

int main()
{
    unsigned int len = sizeof(numbers)/sizeof(int);
    array_fill_numbers(numbers,len);
    display_numbers(numbers,len,"B-unsorted array :");
    bubble_sort(numbers,len);
    display_numbers(numbers,len,"B-sorted array   :");
    array_fill_numbers(numbers,len);
    display_numbers(numbers,len,"I-unsorted array :");
    insertion_sort(numbers,len);
    display_numbers(numbers,len,"I-sorted array   :");

    return 0;
}

/****************************************************************************************/
								Section07_MCU_Memory_Map
/****************************************************************************************/
/*
 *		Memory Map of the MCU (STM32F446RE)
 *	ARM Cortex M4
 *	Width of the system bus is 32 bits.
 *	The processor can produce 2^32 of different addresses (4,294,967,296 addresses)
 *
 *	0x0000_0000 to 0xFFFF_FFFF
 *
 *	MCU: STM32F447X
 *
 *	1. Whats the base address of AHB1 BUS peripheral registers?
 *	AHB1_PERI_START_ADDRESS = 0x40020000;
 *	AHB1_PERI_END_ADDRESS = 0x4007FFFF;
 *
 *	2. Whats the base address of GPIOA registers?
 *	GPIOA_PERI_START_ADDRESS = AHB1_PERI_START_ADDRESS;
 *	GPIOA_PERI_END_ADDRESS = 0x400203FF;
 *
 *	3. Whats the base address of RCC engine registers of the MCU?
 *	RCC_PERI_START_ADDRESS = 0x40023800;
 *	RCC_PERI_END_ADDRESS = 0x40023BFF;
 *
 *	4. Whats the base address of APB1 peripheral registers
 *	APB1_PERI_START_ADDRESS = 0x40000000;
 *	APB1_PERI_END_ADDRESS = 0x40007FFF;
 *
 *	5. Whats the base address of FLASH memory?
 *	FLASH_START_ADDRESS = 0x08000000;
 *	FLASH_END_ADDRESS = 0x081FFFFF;
 *
 *	6. Whats the base address of SRAM2?
 *	SRAM1 is 112kB, SRAM2 is 16kB
 *	SRAM1 starts at 0x20000000
 *	base address of SRAM2 = 0x2001C000
 *
 *	BASE_ADDRESS_OF_SRAM = 0x20000000;
 *	SIZE_OF_SRAM1 = 0x0001BFFF;
 *	BASE_ADDRESS_OF_SRAM2 = ((BASE_ADDRESS_OF_SRAM + SIZE_OF_SRAM1) + 1);
 *
 *	7. Whats the base address of ADC registers?
 *	ADC_START_ADDRESS = 0x40012000;
 *	ADC_END_ADDRESS = 0x400123FF;
 *
 */

/****************************************************************************************/
								Section08_MCU_Bus_Interfaces
/****************************************************************************************/

/*
 *  Notes about MCU Bus Interfaces
 *
 *  Bus interfaces from Processor to AHB-Lite Bus Matrix
 * 	I-BUS : Instruction Bus
 * 	D-BUS : Data Bus
 * 	S-BUS : System Bus
 *
 * 	example:
 *  //A string literal (constant data) is stored in ROM (Flash Memory)
 *  const char *pMessage = "Hello World!";
 *
 *  //This is constant data. This data will be stored in ROM (Flash Memory)
 *  const int value = 200;
 *
 *  //This is not constant data. This will be stored in SRAM.
 *  char myData[50];
 *
 *  int main(void)
 *  {
 *  	for(uint32_t i = 0; i < strlen(pMessage); i++)
 *  	{
 *  		//This is data copy from FLASH to SRAM
 *  		myData[i] = *(pMessage + i);
 *  	}
 *  	for(;;);
 *  }
 *
 *
 *  Flash memory (512kB) can be broken up into:
 *     Instructions              (fetched over I-Bus from ARM CM4 processor)
 *     Const Data (R_only)       (fetched over D-Bus from ARM CM4 processor)
 *     Vector tables             (fetched over S-Bus from ARM CM4 processor)
 *
 *	ICode Memory Interface:
 *	Instruction fetches from Code memory space, 0x00000000 to 0x1FFFFFFC, are performed over the 32-bit AHB-Lite bus.
 *	The debugger cannot access this interface. All fetches are word-wide. The number of instructions fetched per word depends
 *	on the code running and the alignment of the code in memory.
 *
 *	DCode Memory Interface:
 *	Data and debug accesses to Code memory space, 0x00000000 to 0x1FFFFFFF, are performed over the 32-bit AHB-Lite bus.
 *	The Code memory space avail is dependent on implementation. Core data accesses have a higher prio than debug accesses on this bus.
 *	This means that debug accesses are waited until core accesses have completed when there are simultaneous core and debug access to this bus.
 *
 *	System Interface
 *	Instruction fetches and data and debug accesses to address ranges 0x20000000 to 0xDFFFFFFF and 0xE0100000 to 0xFFFFFFFF are performed over the
 *	32-bit AHB-Lite bus.
 *	For simultaneous accesses to 32-bit AHB-Lite bus, the arbitration order in decreasing priority is:
 *		Data Accesses
 *		Instruction and vector fetches
 *		Debug
 *	The system bus interface contains control logic to handle unaligned accesses, FPB remapped accesses, bit-band accesses and pipelined instruction 
 *  fetches.
 *
 *	Summary:
 *	If the instructions are present in between the memory locations 0x00000000 to 0x1FFFFFFC then the Cortex Processor will fetch the instructions using
 *	I-CODE interface.
 *	If the instructions are present outside of 0x00000000 to 0x1FFFFFFC then processor fetches the instructions over the system bus.
 *
 *	If the data is present in between memory locations 0x00000000 to 0x1FFFFFFF then the processor fetches the data over D-CODE bus interface.
 *	If the data is present outside 0x00000000 to 0x1FFFFFFF then the data will be fetched over the system bus.
 *
 *	FLASH is connected to ICODE and DCODE only, not System Bus.
 *
 *  System Bus talks to peripherals.
 *
 *  System Bus can operate at 180MHz (Cortex M4)
 *
 *  AHB-Lite Bus Matrix interfaces with AHB1 (180MHz) and AHB2 (180MHz) system buses.
 *
 *  AHB1 Bus (180MHz) meets a bridge that selects/converts between APB1 (45MHz) and APB2 (90MHz) buses that interface with different peripherals.
 *
 *  Processor cannot fetch instructions and data simultaneously from SRAM because thats connected to the System Bus.
 *  Processor can however fetch instructions and data simultaneously from FLASH because it can utilize both ICODE and DCODE.
 *
 *	System bus can only communicate with one peripheral at a time, regardless if they are on separate AHB1/2 buses.
 *	Processor can talk to SRAM and FLASH simultaneously because I-BUS, D-BUS and S-BUS are all independent.
 *
 */
 
/****************************************************************************************/
							Section09_MCU_Clocks_and_Details
/****************************************************************************************/

/*
 * 		Clocks:
 * 	Three different clock sources can be used to drive the system clock (SYSCLK):
 * 	. HSI oscillator clock
 * 	. HSE oscillator clock
 * 	. Main PLL (PLL) clock
 *
 * 	The devices have the two following secondary clock sources:
 * 	. 32kHz low-speed internal RC (LSI RC) which drives the independent watchdog and, optionally, the RTC used for Auto-wakeup from the stop/standby mode.
 * 	. 32.768 kHz low-speed external crystal (LSE crystal) which optionally drives the RTC clock (RTCCLK)
 *
 *	Sources:
 *	. Crystal Oscillator (external)
 *	. RC Oscillator (internal)
 *	. The PLL (Phase Locked Loop) (internal)
 *
 *	HSI is assumed to be default on reset.
 *
 */

/****************************************************************************************/
						Section10_MCU_Clock_Exercise_HSE_measurement
/****************************************************************************************/
/*
 *  Exercise HSE Measurement (Nucleo):
 *
 *	1. Enable the HSEBYP bit (RCC_CR)
 *	(bypass the oscillator with an external clock)
 *	2. Enable the HSE clock using the HSEON bit (RCC_CR)
 *	3. Switch the systemclock to HSE
 *	4. Do MCO1 settings to measure it
 */


#include <stdint.h>

#define RCC_BASE_ADDR		0x40023800UL
#define RCC_CFGR_REG_OFFSET	0x08UL
#define RCC_CR_REG_OFFSET	0x00UL
#define RCC_CFGR_REG_ADDR	(RCC_BASE_ADDR + RCC_CFGR_REG_OFFSET)
#define RCC_CR_REG_ADDR		(RCC_BASE_ADDR + RCC_CR_REG_OFFSET)

#define GPIOA_BASE_ADDR		0x40020000UL

int main(void)
{
	 uint32_t *pRccCrReg = (uint32_t*) RCC_CR_REG_ADDR;
	 uint32_t *pRccCfgrReg = (uint32_t*) RCC_CFGR_REG_ADDR;

	 //1. Enable the HSEBYP bit (RCC_CR) (bypass the oscillator with an external clock)
	 *pRccCrReg |= (0x1 << 18);

	 //2. Enable the HSE clock using the HSEON bit (RCC_CR)
	 *pRccCrReg |= (0x1 << 16);

	 //3. Switch the systemclock to HSE
	 *pRccCfgrReg |= (0x1 << 0);

	 /************** Do MCO1 settings to measure it ****************/

	//1. Configure the RCC_CFGR MCO1 bit fields to select HSE as clock source
	*pRccCfgrReg |= (0x1 << 22);

	//Configure MCO1 prescaler to divide by 4. Bits 26:24 we want to write 110.
	*pRccCfgrReg |= (0x1 << 26);
	*pRccCfgrReg |= (0x1 << 25);


	//2. Configure PA8 to AF0 mode to behave as MCO1 signal
	//a. Enable the peripheral clock for GPIOA peripheral
	uint32_t *pRccAhb1Enr = (uint32_t*)(RCC_BASE_ADDR + 0x30);
	*pRccAhb1Enr |= (0x1 << 0); //enable peripheral clock

	//b. Configure the mode of GPIOA pin 8 as alternate function mode
	uint32_t *pGPIOAModeReg = (uint32_t*)(GPIOA_BASE_ADDR + 0x00);
	*pGPIOAModeReg &= ~(0x3 << 16); //clear  0x3 = 0b11
	*pGPIOAModeReg |= (0x2 << 16); //set 0x2 = 0b10 -> 10 means alternate function. bits 16:17 is for pin8

	//c. Configure the alternate function register to set PA8 to mode 0
	uint32_t *pGPIOAAltFunHighReg = (uint32_t*)(GPIOA_BASE_ADDR + 0x24); //AFRH is for pins 8-15, AFRL is for pins 0-7
	*pGPIOAAltFunHighReg &= ~(0xF << 0); //clear 0xF = 0b1111  -> 0000: AF0

	for(;;);
}

/****************************************************************************************/
						Section10_MCU_Clock_Exercise_HSI_measurement
/****************************************************************************************/
/*
 *  Exercise: HSI Measurement
 *
 *  Write a program to output HSI clock on microcontroller pin and measure it using oscilloscope or logic analyzer.
 *
 *	Steps:
 *	1. Select the desired clock for the MCOx signal (Microcontroller Clock Output)
 *	2. Output the MCOx signal on the MCU pin
 *
 *	6.3.3 RCC clock configuration register (RCC_CFGR)
 *	Select HSI Clock for MCO1 (microcontroller clock output 1)
 *		> Bits 22:21 -> 00 (HSI clock selected)
 *
 *  PA8 alternate functionality:  MCO1 (AF0)
 *  PA8 is Pin 41 on the MCU (LQFP64 Package)
 *
 *
 *
 */

#include <stdint.h>

#define RCC_BASE_ADDR		0x40023800UL
#define RCC_CFGR_REG_OFFSET	0x08UL
#define RCC_CFGR_REG_ADDR	(RCC_BASE_ADDR + RCC_CFGR_REG_OFFSET)

#define GPIOA_BASE_ADDR		0x40020000UL

int main(void)
{
	uint32_t *pRccCfgrReg = (uint32_t*) RCC_CFGR_REG_ADDR;

    //1. Configure the RCC_CFGR MCO1 bit fields to select HSI as clock source
	*pRccCfgrReg &= ~(0x3 << 21);  // 0x3 = 0b11. Clearing bits 21 and 22

	//Configure MCO1 prescaler to divide by 4. Bits 26:24 we want to write 110.
	*pRccCfgrReg |= (1 << 26);
	*pRccCfgrReg |= (1 << 25);


	//2. Configure PA8 to AF0 mode to behave as MCO1 signal
	//a. Enable the peripheral clock for GPIOA peripheral
	uint32_t *pRccAhb1Enr = (uint32_t*)(RCC_BASE_ADDR + 0x30);
	*pRccAhb1Enr |= (1 << 0); //enable peripheral clock

	//b. Configure the mode of GPIOA pin 8 as alternate function mode
	uint32_t *pGPIOAModeReg = (uint32_t*)(GPIOA_BASE_ADDR + 0x00);
	*pGPIOAModeReg &= ~(0x3 << 16); //clear  0x3 = 0b11
	*pGPIOAModeReg |= (0x2 << 16); //set 0x2 = 0b10 -> 10 means alternate function. bits 16:17 is for pin8

	//c. Configure the alternate function register to set PA8 to mode 0
	uint32_t *pGPIOAAltFunHighReg = (uint32_t*)(GPIOA_BASE_ADDR + 0x24); //AFRH is for pins 8-15, AFRL is for pins 0-7
	*pGPIOAAltFunHighReg &= ~(0xF << 0); //clear 0xF = 0b1111  -> 0000: AF0

	for(;;);
}

/****************************************************************************************/
								Section10_MCU_Clock_Tree
/****************************************************************************************/
Check Image in folder.

/****************************************************************************************/
								Section10_MCU_Clock_Tree_Code
/****************************************************************************************/
/*
 * Peripheral Clock configuration
 * . In modern MCUs, before using any peripheral, you must enable its peripheral clock using peripheral clock registers.
 * . By default, peripheral clocks of most all peripherals will be disabled to save power.
 * . A peripheral wont take or respond to your configuration values until you enable its peripheral clock.
 * . In STM32 microcontrollers, peripheral clocks are managed through RCC registers.
 *
 *	Before you configure any peripheral register, you must enable its clock first **IMPORTANT**
 *
 *
 */


#include <stdint.h>

#define ADC_BASE_ADDR 		0x40012000UL
#define ADC_CR1_REG_OFFSET 	0x04UL
#define ADC_CR1_REG_ADDR 	(ADC_BASE_ADDR + ADC_CR1_REG_OFFSET)

#define RCC_BASE_ADDR		0x40023800UL
#define RCC_APB2_ENR_OFFSET	0x44UL
#define RCC_APB2_ENR_ADDR	(RCC_BASE_ADDR + RCC_APB2_ENR_OFFSET)

int main(void)
{
    uint32_t *pAdcCr1Reg =  (uint32_t*) ADC_CR1_REG_ADDR;
	uint32_t *pRccApb2Enr = (uint32_t*) RCC_APB2_ENR_ADDR;

    //1. Enable the peripheral clock for ADC1
	*pRccApb2Enr |= (1 << 8);

	//2. Modify the ADC CR1 register
    *pAdcCr1Reg |= (1 << 8);

	for(;;);
}

/****************************************************************************************/
					Section11_12_13_Interrupt_NVIC_GPIO_Volatile_Notes
/****************************************************************************************/

/*
 *  How do GPIO pins interrupt the processor?
 *  Some peripherals deliver their interrupt to the NVIC over the EXTI[0:4] line (EXTernal Interrupt/event controller). Others deliver 
 *  it directly to NVIC.
 *
 *
 *  PinGroup  SYSCFG_EXTICRx	Line
 *  P[A:I]0   	--MUX0->		EXTI0
 *  P[A:I]1   	--MUX1-> 		EXTI1
 *  P[A:I]2   	--MUX2->		EXTI2
 *  P[A:I]3   	--MUX3->		EXTI3
 *  P[A:I]4   	--MUX4->		EXTI4
 *
 *	Notable Registers to configure EXTI lines:
 *	. Pending Request Register (EXTI_PR)
 *	. Interrupt Mask Register (EXTI_IMR)
 *	. Software Interrupt Event Register (EXTI_SWIER)
 *	. Rising Trigger Selection Register (EXTI_RTSR)
 *	. Falling Trigger Selection Register (EXTI_FTSR)
 *
 *
 *
 *
 *
 */

#include <stdint.h>

#define SRAM_ADDRESS1			0x20000004U

int main(void)
{
    uint32_t value = 0;
    uint32_t volatile *p = (uint32_t*) SRAM_ADDRESS1;

    while(1) {
    	value = *p;
    	if(value) break;
    }

    while(1);

	return 0;
}

/****************************************************************************************/
				Section14_15_16_17_18_19_GPIO_Programming_Struct_and_Regs
/****************************************************************************************/

/*
 *    GPIO Functional Summary:
 *
 *  . Input Floating
 *  . Input Pull-up
 *  . Input Pull-down
 *  . Analog
 *  . Output open-drain with pull-up or pull-down
 *  . Output push-pull with pull-up or pull-down
 *  . Alternate function push-pull with pull-up or pull-down
 *  . Alternate function open-drain with pull-up or pull-down
 *
 *	A GPIO Pin's 16 possible alternate functionalities:
 *	AF0 (system)
 *	AF1 (TIM1/TIM2)
 *	AF2 (TIM3..5)
 *	AF3 (TIM8..11, CEC)
 *	AF4 (I2C1..4, CEC)
 *	AF5 (SPI1/2/3/4)
 *	AF6 (SPI2/3/4, SAI1)
 *	AF7 (SPI2/3, USART1..3, UART5, SPDIF-IN)
 *	AF8 (SPI2/3, USART1..3, UART5, SPDIF-IN)
 *	AF9 (CAN1/2, TIM12..14, QUADSPI)
 *	AF10 (SAI2, QUADSPI, OTG_HS, OTG_FS)
 *	AF11
 *	AF12 (FMC, SDIO, OTG_HS)
 *	AF13 (DCMI)
 *	AF14
 *	AF15 (EVENTOUT)
 *
 *	Exercise: List out all the 16 possible alternate functionalities supported byb GPIO port 'A' pin 8 (GPIOA.8)
 *
 *	PA8:   (From Datasheet: Alternate Function Mapping)
 *	AF0		MCO1
 *	AF1		TIM1_CH1
 *	AF2		-
 *	AF3		-
 *	AF4		I2C3_SCL
 *	AF5		-
 *	AF6		-
 *	AF7		USART1_CK
 *	AF8		-
 *	AF9		-
 *	AF10	OTG_FS_SOF
 *	AF11	-
 *	AF12	-
 *	AF13	-
 *	AF14	-
 *	AF15	EVENTOUT
 *
 * 	MCU Specific Device Header File:
 * 	. Base Addresses of various memories present in the MCU such as Flash, SRAM1, SRAM2, ROM, etc
 * 	. The base addresses of various bus domains such as AHBx domain, APBx domain
 * 	. Base addresses of various peripherals present in different bus domains of the MCU
 * 	. Clock management macros (ie. cloak enable and disable macros)
 * 	. IRQ definitions
 * 	. Peripheral Register definition structures
 * 	. Peripheral register bit definitions
 * 	. Other useful microcontroller configuration macros
 *
 *
 *			 --- (Device Header) ---
 *	   		v						v
 *	   (Application)		   (Driver Files)
 *
 *
 *
 *	Different bus domains of the stm32f4x MCU:
 *
 *								   PERIPH_BASE
 *								        v
 *		   -------------------------------------------------------------
 *	       v                 v                     v                   v
 *	APB1PERIPH_BASE   APRB2PERIPH_BASE 		AHB1PERIPH_BASE 	AHB2PERIPH_BASE
 *
 *	. Different peripherals are hanging on different busses.
 *	. AHB bus is used for those peripherals which need high speed data communication (ex. Camera interfaces, GPIOs)
 *  . APB bus is used for those peripherals for which low speed communication would suffice.
 *
 *
 *	AHB1 Peripherals:
 *	GPIOA GPIOB GPIOC GPIOD GPIOE GPIOF GPIOG GPIOH
 *
 *	APB1 Peripherals:
 *	I2C1 I2C2 I2C3 SPI2 SPI3 USART2 USART3 UART4 UART5
 *
 *	APB2 Peripherals:
 *	SPI1 USART1 USART6 EXTI SYSCFG
 *
 *
 *

 */

#include <stdint.h>

int main(void)
{

	for(;;);
}

/****************************************************************************************/
									stm32f446RE_drivers
/****************************************************************************************/

Contents:

Src:
	- 001LedToggle.c
	- 002LedButton.c
	- 003LedBtnInterrupt.c
	- 004spi_tx_testing.c
	- 005spi_txonly_arduino.c
	- 006spi_cmd_handling.c
	- 007spi_message_rcv_it.c
	- 008i2c_master_tx_testing.c
	- 009i2c_master_rx_testing.c
	- 010i2c_master_rx_testingIT.c
	- 011i2c_slave_tx_string.c
	- 012i2c_slave_tx_string2.c
	- 013uart_tx.c
	- 014uart_case.c
	- 015rtc_lcd.c

bsp:
	- ds1307.c
	- ds1307.h
	- lcd.c
	- lcd.h

drivers:
	- inc
		. stm32f446xx_gpio_driver.h
		. stm32f446xx_i2c_driver.h
		. stm32f446xx_rcc_driver.h
		. stm32f446xx_spi_driver.h
		. stm32f446xx_usart_driver.h
		. stm32f446xx.h
	- src
		. stm32f446xx_gpio_driver.c
		. stm32f446xx_i2c_driver.c
		. stm32f446xx_rcc_driver.c
		. stm32f446xx_spi_driver.c
		. stm32f446xx_usart_driver.c


////////////////////////////// SRC ////////////////////////

/****************************************************************************************/
									001LedToggle.c
/****************************************************************************************/
 *	Write a program to toggle the on board LED with some delay.
 *	Case 1: Use push pull configuration for the output pin
 *	Case 2: Use open drain configuration for the output pin
 */

#include "stm32f446xx.h"


void delay(void) {
	for(uint32_t i = 0; i < 500000; i++);

}


int main(void) {
	GPIO_Handle_t GPIOLed;

	// RED1 = PB5
	GPIOLed.pGPIOx = GPIOB;
	GPIOLed.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_5;
	GPIOLed.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	GPIOLed.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOLed.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GPIOLed.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_PClockControl(GPIOB, ENABLE);

	GPIO_Init(&GPIOLed);

	while(1) {
		GPIO_ToggleOutputPin(GPIOB, GPIO_PIN_NO_5);
		delay();

	}
	return 0;
}

/****************************************************************************************/
								002LedButton.c
/****************************************************************************************/
#include "stm32f446xx.h"

#define BTN_PRESSED 0

void delay(void) {

	for(uint32_t i = 0; i < 300000; i++);
}


int main(void) {

	GPIO_Handle_t GPIOLed;
	GPIO_Handle_t GPIOBtn;

	// RED1 = PB5
	GPIOLed.pGPIOx = GPIOB;
	GPIOLed.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_5;
	GPIOLed.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	GPIOLed.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOLed.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GPIOLed.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_PClockControl(GPIOB, ENABLE);

	GPIO_Init(&GPIOLed);

	// User Push Button = PC13
	GPIOBtn.pGPIOx = GPIOC;
	GPIOBtn.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIOBtn.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	GPIOBtn.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOBtn.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_PClockControl(GPIOC, ENABLE);

	GPIO_Init(&GPIOBtn);


	while(1) {

		if((GPIO_ReadFromInputPin(GPIOC, GPIO_PIN_NO_13)) == BTN_PRESSED) {
			delay();
			GPIO_ToggleOutputPin(GPIOB, GPIO_PIN_NO_5);
		}
	}

	return 0;
}

/****************************************************************************************/
								003LedBtnInterrupt.c
/****************************************************************************************/
/*
 * GPIO Pin Interrupt Configuration
 *
 * 1. Pin must be in input configuration
 * 2. Configure the edge trigger (RT,FT,RFT)
 * 3. Enable interrupt delivery from peripheral to the processor (on peripheral side)
 * 4. Identify the IRQ number on which the processor accepts the interrupt from that pin
 * 5. Configure the IRQ priority for the identified IRQ number (processor side)
 * 6. Enable interrupt reception on that IRQ number (processor side)
 * 7. Implement IRQ handler
 *
 *
 * 			STM32F4x GPIO Pins interrupt delivery to the Processor
 * 			MCU Peripheral Side							Processor Side
 * GPIO port is decided by
 * SYSCFG_EXTICR register config
 *
 *	  (GPIO)				    (EXTI)		          (NVIC)
 * 	GPIOx_PIN0		-->			EXTI0		-->			6
 * 	GPIOx_PIN1		-->			EXTI1		-->			7
 * 	GPIOx_PIN2		-->			EXTI2		-->			8
 * 	GPIOx_PIN3		-->			EXTI3		-->			9			<-->  Processor Core
 * 	GPIOx_PIN4		-->			EXTI4		-->			10
 * 	GPIOx_PIN5_9	-->			EXTI5_9		-->			23
 * 	GPIOx_PIN10_15	-->			EXTI10_15	-->			40
 * 					EXTI block does Edge Detection		Enable/Disable of IRQ's are
 * 					(FT,RT), Enable/Disable of			configured in NVIC registers
 * 					interrupt delivery to the
 * 					processor.
 *
 *	1. Implement the ISR function
 *	2. Store the addr. of your ISR at the vector addr. location corresponding to the IRQ number for which you have written the ISR`
 *
 *	Exercise:
 *	Configure user push button (PC13) and toggle the LED (PB5) whenever interrupt is triggered by the button press.
 *	Interrupt should be triggered during the falling edge of the button press.
 *
 *
 */

#include <string.h>
#include "stm32f446xx.h"

#define BTN_PRESSED 0

void delay(void) {

	//this will introduce ~200ms delay when the system clock is 16MHz
	for(uint32_t i = 0; i < 250000; i++);
}


int main(void) {

	GPIO_Handle_t GPIOLed, GPIOBtn;

	memset(&GPIOLed, 0, sizeof(GPIOLed));
	memset(&GPIOBtn, 0, sizeof(GPIOBtn));

	// RED_LED_1 = PB5
	GPIOLed.pGPIOx = GPIOB;
	GPIOLed.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_5;
	GPIOLed.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	GPIOLed.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_LOW;
	GPIOLed.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GPIOLed.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_PClockControl(GPIOB, ENABLE);

	GPIO_Init(&GPIOLed);

	// User Push Button = PC13
	GPIOBtn.pGPIOx = GPIOC;
	GPIOBtn.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIOBtn.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN_FT;
	GPIOBtn.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOBtn.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;

	GPIO_PClockControl(GPIOC, ENABLE);

	GPIO_Init(&GPIOBtn);

	GPIO_WriteToOutputPin(GPIOC, GPIO_PIN_NO_13, GPIO_PIN_RESET);

	//IRQ Configurations
	GPIO_IRQPriorityConfig(IRQ_NO_EXTI15_10, NVIC_IRQ_PRI15);
	GPIO_IRQInterruptConfig(IRQ_NO_EXTI15_10, ENABLE);


	while(1);

	return 0;
}

void EXTI15_10_IRQHandler(void) {

	delay(); //200ms wait until button de-bouncing  is over
	GPIO_IRQHandling(GPIO_PIN_NO_13);	//clear the pending event from EXTI line
	GPIO_ToggleOutputPin(GPIOB, GPIO_PIN_NO_5);
}

/****************************************************************************************/
								004spi_tx_testing.c
/****************************************************************************************/
/*
 * Exercise:
 * Test the SPI_SendData API to send the string "Hello world" and use the below configurations:
 * SPI-2 Master Mode
 * SCLK = max possible
 * DFF = 0 and DFF = 1
 *
 *	Options (some not all):
 *	SPI2_SCK - PA9 AF5, PB13 AF5
 *	SPI2_NSS - PB4 AF7, PB9 AF5, PB12 AF5
 *	SPI2_MISO - PB14 AF5
 *	SPI2_MOSI - PB15 AF5
 *
 *	Chosen:
 *	PB12 AF5 - SPI2_NSS
 *	PB13 AF5 - SPI2_SCK
 *	PB14 AF5 - SPI2_MISO
 *	PB15 AF5 - SPI2_MOSI
 */

#include "stm32f446xx.h"
#include <string.h>

void SPI2_GPIOInits(void) {

	GPIO_Handle_t SPIPins;

	SPIPins.pGPIOx = GPIOB;
	SPIPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	SPIPins.GPIO_PinConfig.GPIO_PinAltFunMode = 5;
	SPIPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	SPIPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	SPIPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

	//NSS
	//SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_12;
	//GPIO_Init(&SPIPins);

	//SCK
	SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIO_Init(&SPIPins);

	//MISO
	//SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_14;
	//GPIO_Init(&SPIPins);

	//MOSI
	SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_15;
	GPIO_Init(&SPIPins);
}

void SPI2_Inits(void) {

	SPI_Handle_t SPI2Handle;

	SPI2Handle.pSPIx = SPI2;
	SPI2Handle.SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_FD;
	SPI2Handle.SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;
	SPI2Handle.SPIConfig.SPI_SclkSpeed = SPI_SCLK_SPEED_DIV2; 			//generates sclk of 8MHz
	SPI2Handle.SPIConfig.SPI_DFF = SPI_DFF_8BITS;
	SPI2Handle.SPIConfig.SPI_CPOL = SPI_CPOL_LOW;
	SPI2Handle.SPIConfig.SPI_CPHA = SPI_CPHA_LOW;
	SPI2Handle.SPIConfig.SPI_SSM = SPI_SSM_EN;							//software slave management enabled for NSS pin

	SPI_Init(&SPI2Handle);
}

int main(void) {

	char user_data[] = "Hello world";

	//Initialize the GPIO pins to behave as SPI2 pins
	SPI2_GPIOInits();

	//Initialize the SPI2 peripheral parameters
	SPI2_Inits();

	//Force NSS signal high (internally) to avoid MODF error
	SPI_SSIConfig(SPI2, ENABLE);

	//enable the SPI2 peripheral
	SPI_PeripheralControl(SPI2, ENABLE);

	//send data
	SPI_SendData(SPI2, (uint8_t*)user_data, strlen(user_data));

	//confirm SPI is not busy
	while(SPI_GetFlagStatus(SPI2, SPI_FLAG_BUSY));

	//disable the SPI2 peripheral
	SPI_PeripheralControl(SPI2, DISABLE);

	while(1);

	return 0;
}

/****************************************************************************************/
							005spi_txonly_arduino.c
/****************************************************************************************/
/*
 * Exercise:
 * SPI Master(STM) and SPI Slave(Arduino) communication
 * When the button on the master is pressed, master should send string of data to the Arduino slave connected. The data received by
 * the Arduino will be displayed on the Arduino serial port.
 *
 * 1. Use SPI Full duplex mode
 * 2. ST board will be in SPI master mode and Arduino will be configured for SPI slave mode
 * 3. Use DFF = 0
 * 4. Use Hardware slave management (SSM = 0)
 * 5. SCLK speed = 2MHz, fclk = 16MHz
 *
 * In this exercise, master is not going to receive anything for the slave. So you may not configure the MISO pin.
 *
 * Note: slave does not know how many bytes of data master is going to send. So master first sends the number of bytes info which slave
 * is going to receive next.
 *
 *
 *	Things you need:
 *	Arduino Board
 *	STM32 Board
 *	Logic Level converter
 *	Breadboard and jumper wires
 *
 *	STM32 Vdd = 3V 		Arduino Vcc = 5V
 *
 *	Power Arduino board and download SPI Slave Sketch to Arduino
 *	Sketch name: 001SPISlaveRxString.ino
 *
 *
 *	STM MCU feature:
 *	with SSM = 0, and SPE = 1, NSS output will be forced to 0 (provided SSOE bit = 1 as well)
 *	with SSM = 0, and SPE = 0, NSS output will be forced to 1 (provided SSOE bit = 1 as well)
 */

#include "stm32f446xx.h"
#include <string.h>

void delay(void) {

	//this will introduce ~200ms delay when the system clock is 16MHz
	for(uint32_t i = 0; i < 250000; i++);
}

void SPI2_GPIOInits(void) {

	GPIO_Handle_t SPIPins;

	SPIPins.pGPIOx = GPIOB;
	SPIPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	SPIPins.GPIO_PinConfig.GPIO_PinAltFunMode = 5;
	SPIPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	SPIPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	SPIPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

	//NSS
	SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_12;
	GPIO_Init(&SPIPins);

	//SCK
	SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIO_Init(&SPIPins);

	//MISO
	//SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_14;
	//GPIO_Init(&SPIPins);

	//MOSI
	SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_15;
	GPIO_Init(&SPIPins);
}

void SPI2_Inits(void) {

	SPI_Handle_t SPI2Handle;

	SPI2Handle.pSPIx = SPI2;
	SPI2Handle.SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_FD;
	SPI2Handle.SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;
	SPI2Handle.SPIConfig.SPI_SclkSpeed = SPI_SCLK_SPEED_DIV32; 			//generates sclk of 2MHz
	SPI2Handle.SPIConfig.SPI_DFF = SPI_DFF_8BITS;
	SPI2Handle.SPIConfig.SPI_CPOL = SPI_CPOL_LOW;
	SPI2Handle.SPIConfig.SPI_CPHA = SPI_CPHA_LOW;
	SPI2Handle.SPIConfig.SPI_SSM = SPI_SSM_DI;							//hardware slave management enabled for NSS pin

	SPI_Init(&SPI2Handle);
}

void GPIO_ButtonInit() {

	// User Push Button = PC13
	GPIO_Handle_t GPIOBtn;

	GPIOBtn.pGPIOx = GPIOC;
	GPIOBtn.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIOBtn.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	GPIOBtn.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOBtn.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_Init(&GPIOBtn);
}

int main(void) {

	char user_data[] = "Hello world";

	GPIO_ButtonInit();

	//Initialize the GPIO pins to behave as SPI2 pins
	SPI2_GPIOInits();

	//Initialize the SPI2 peripheral parameters
	SPI2_Inits();

	//Enabling SSOE will enable NSS Output. The NSS pin is automatically managed by hardware.
	//When SPE=1, NSS will be pulled to low. When SPE=0, NSS will be pulled to high.
	SPI_SSOEConfig(SPI2, ENABLE);

	while(1) {

		//wait until button is pressed
		while(GPIO_ReadFromInputPin(GPIOC, GPIO_PIN_NO_13));

		//to avoid button debouncing related issues
		delay();

		//enable the SPI2 peripheral
		SPI_PeripheralControl(SPI2, ENABLE);

		//first send length information
		uint8_t dataLen = strlen(user_data);
		SPI_SendData(SPI2, &dataLen, 1);

		//send data
		SPI_SendData(SPI2, (uint8_t*)user_data, strlen(user_data));

		//confirm SPI is not busy
		while(SPI_GetFlagStatus(SPI2, SPI_FLAG_BUSY));

		//disable the SPI2 peripheral
		SPI_PeripheralControl(SPI2, DISABLE);
	}

	return 0;
}

/****************************************************************************************/
							006spi_cmd_handling.c
/****************************************************************************************/
/*
 * Exercise:
 * SPI Master(STM) and SPI Slave(Arduino) command & response based communication.
 *
 * When the button on the master is pressed, master sends a command to the slave and slave responds
 * as per the command implementation.
 *
 * 1. Use SPI Full Duplex Mode
 * 2. ST Board will be in SPI Master Mode and Arduino will be configured for SPI slave mode
 * 3. Use DFF = 0
 * 4. Use Hardware Slave Management (SSM = 0)
 * 5. SCLK speed = 2MHz, fclk = 16MHz
 *
 *	Slave ACK (0xF5)
 *	Slave NACK (0xA5)
 *
 *	Command Formats:
 *
 *	1) CMD_LED_CTRL   	<pin no(1)>  <value(1)>
 *	2) CMD_SENSOR_READ 	<analog pin number(1)>
 *	3) CMD_LED_READ		<pin no(1)>
 *	4) CMD_PRINT		<len(2)> <message(len)>
 *	5) CMD_ID_READ
 *
 *	connect 1 LED with 470ohm resistor to pin 9 of arduino
 *
 *	Using Semihosting:
 *	1. Linker argument settings
 *	-specs=rdimon.specs -lc -lrdimon
 *
 *	2. Debug configuration of your application
 *	monitor arm semihosting enable
 *
 *	3. in main.c use below codes
 *	extern void initialise_monitor_handles();
 *	initialise_monitor_handles();
 *
 */

#include "stm32f446xx.h"
#include <string.h>
#include <stdio.h>

//semihosting
extern void initialise_monitor_handles();

//Command Codes
#define COMMAND_LED_CTRL		0x50
#define COMMAND_SENSOR_READ		0x51
#define COMMAND_LED_READ		0x52
#define COMMAND_PRINT			0x53
#define COMMAND_ID_READ			0x54

#define LED_OFF					0
#define LED_ON					1

#define ANALOG_PIN0				0
#define ANALOG_PIN1				1
#define ANALOG_PIN2				2
#define ANALOG_PIN3				3
#define ANALOG_PIN4				4

//Arduino LED
#define LED_PIN					9



void delay(void) {

	//this will introduce ~200ms delay when the system clock is 16MHz
	for(uint32_t i = 0; i < 250000; i++);
}

void SPI2_GPIOInits(void) {

	GPIO_Handle_t SPIPins;

	SPIPins.pGPIOx = GPIOB;
	SPIPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	SPIPins.GPIO_PinConfig.GPIO_PinAltFunMode = 5;
	SPIPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	SPIPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	SPIPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

	//NSS
	SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_12;
	GPIO_Init(&SPIPins);

	//SCK
	SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIO_Init(&SPIPins);

	//MISO
	SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_14;
	GPIO_Init(&SPIPins);

	//MOSI
	SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_15;
	GPIO_Init(&SPIPins);
}

void SPI2_Inits(void) {

	SPI_Handle_t SPI2Handle;

	SPI2Handle.pSPIx = SPI2;
	SPI2Handle.SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_FD;
	SPI2Handle.SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;
	SPI2Handle.SPIConfig.SPI_SclkSpeed = SPI_SCLK_SPEED_DIV32; 			//generates sclk of 2MHz
	SPI2Handle.SPIConfig.SPI_DFF = SPI_DFF_8BITS;
	SPI2Handle.SPIConfig.SPI_CPOL = SPI_CPOL_LOW;
	SPI2Handle.SPIConfig.SPI_CPHA = SPI_CPHA_LOW;
	SPI2Handle.SPIConfig.SPI_SSM = SPI_SSM_DI;							//hardware slave management enabled for NSS pin

	SPI_Init(&SPI2Handle);
}

void GPIO_ButtonInit() {

	// User Push Button = PC13
	GPIO_Handle_t GPIOBtn;

	GPIOBtn.pGPIOx = GPIOC;
	GPIOBtn.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIOBtn.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	GPIOBtn.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOBtn.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_Init(&GPIOBtn);
}

uint8_t SPI_VerifyResponse(uint8_t ackbyte) {

	if(ackbyte == (uint8_t)0xF5) {

		//ack
		return 1;
	}

	//nack
	return 0;
}


int main(void) {

	uint8_t dummy_write = 0xFF;
	uint8_t dummy_read;

	//semihosting
	initialise_monitor_handles();

	printf("Application is running\n");

	GPIO_ButtonInit();

	//Initialize the GPIO pins to behave as SPI2 pins
	SPI2_GPIOInits();

	//Initialize the SPI2 peripheral parameters
	SPI2_Inits();

	printf("SPI Init done.\n");

	//Enabling SSOE will enable NSS Output. The NSS pin is automatically managed by hardware.
	//When SPE=1, NSS will be pulled to low. When SPE=0, NSS will be pulled to high.
	SPI_SSOEConfig(SPI2, ENABLE);

	while(1) {

		//wait until button is pressed
		while(GPIO_ReadFromInputPin(GPIOC, GPIO_PIN_NO_13));

		//to avoid button debouncing related issues
		delay();

		//enable the SPI2 peripheral
		SPI_PeripheralControl(SPI2, ENABLE);
		printf("SPI Communication Opened\n");

	//1. CMD_LED_CTRL   	<pin no(1)>  <value(1)>
		uint8_t command_code = COMMAND_LED_CTRL;
		uint8_t ack_byte;
		uint8_t args[2];

		//send command
		SPI_SendData(SPI2, &command_code, 1);

		//do dummy read to clear RXNE
		SPI_ReceiveData(SPI2, &dummy_read, 1);

		//send some dummy bits (1 byte or 2 bytes depending on 8 or 16 bit comms) to fetch the response from the slave.
		SPI_SendData(SPI2, &dummy_write, 1);

		//read the ack byte received
		SPI_ReceiveData(SPI2, &ack_byte, 1);

		if(SPI_VerifyResponse(ack_byte)) {

			args[0] = LED_PIN;
			args[1] = LED_ON;

			//send arguments
			SPI_SendData(SPI2, args, 2);
			//dummy read
			SPI_ReceiveData(SPI2, args, 2);

			printf("COMMAND_LED_CTRL executed\n");
		}

	//2. CMD_SENSOR_READ 	<analog pin number(1)>
		//wait until button is pressed
		while(GPIO_ReadFromInputPin(GPIOC, GPIO_PIN_NO_13));

		//to avoid button debouncing related issues
		delay();

		//send command
		command_code = COMMAND_SENSOR_READ;
		SPI_SendData(SPI2, &command_code, 1);

		//do dummy read to clear RXNE
		SPI_ReceiveData(SPI2, &dummy_read, 1);

		//send some dummy bits (1 byte or 2 bytes depending on 8 or 16 bit comms) to fetch the response from the slave.
		SPI_SendData(SPI2, &dummy_write, 1);

		//read the ack byte received
		SPI_ReceiveData(SPI2, &ack_byte, 1);

		if(SPI_VerifyResponse(ack_byte)) {

			args[0] = ANALOG_PIN0;

			//send arguments
			SPI_SendData(SPI2, args, 1);

			//do dummy read to clear RXNE
			SPI_ReceiveData(SPI2, &dummy_read, 1);

			//insert some delay so that slave can ready with the data
			delay();

			//send some dummy bits (1 byte or 2 bytes depending on 8 or 16 bit comms) to fetch the response from the slave.
			SPI_SendData(SPI2, &dummy_write, 1);

			uint8_t analog_read;
			SPI_ReceiveData(SPI2, &analog_read, 1);

			printf("COMMAND_SENSOR_READ executed %d\n", analog_read);
		}

	//3. CMD_LED_READ		<pin no(1)>
		//wait until button is pressed
		while(GPIO_ReadFromInputPin(GPIOC, GPIO_PIN_NO_13));

		//to avoid button debouncing related issues
		delay();

		//send command
		command_code = COMMAND_LED_READ;
		SPI_SendData(SPI2, &command_code, 1);

		//
		//do dummy read to clear off the RXNE
		SPI_ReceiveData(SPI2,&dummy_read,1);

		//Send some dummy byte to fetch the response from the slave
		SPI_SendData(SPI2,&dummy_write,1);

		//read the ack byte received
		SPI_ReceiveData(SPI2,&ack_byte,1);

		if(SPI_VerifyResponse(ack_byte)) {

			args[0] = ANALOG_PIN0;

			//send arguments
			SPI_SendData(SPI2, args, 1);

			//do dummy read to clear RXNE
			SPI_ReceiveData(SPI2, &dummy_read, 1);

			//insert some delay so that slave can ready with the data
			delay();

			//send some dummy bits (1 byte or 2 bytes depending on 8 or 16 bit comms) to fetch the response from the slave.
			SPI_SendData(SPI2, &dummy_write, 1);

			uint8_t led_status;
			SPI_ReceiveData(SPI2, &led_status, 1);

			printf("COMMAND_READ_LED %d\n", led_status);
		}

	//4. CMD_PRINT			<len(2)> <message(len)>
		//wait until button is pressed
		while(GPIO_ReadFromInputPin(GPIOC, GPIO_PIN_NO_13));

		//to avoid button debouncing related issues
		delay();

		//send command
		command_code = COMMAND_PRINT;
		SPI_SendData(SPI2, &command_code, 1);

		//do dummy read to clear RXNE
		SPI_ReceiveData(SPI2, &dummy_read, 1);

		//send some dummy bits (1 byte or 2 bytes depending on 8 or 16 bit comms) to fetch the response from the slave.
		SPI_SendData(SPI2, &dummy_write, 1);

		//read the ack byte received
		SPI_ReceiveData(SPI2, &ack_byte, 1);

		uint8_t message[] = "Hello ! How are you ??";

		if(SPI_VerifyResponse(ack_byte)) {

			args[0] = strlen((char*)message);

			//send arguments
			SPI_SendData(SPI2, args, 1); //sending length

			//do dummy read to clear off the RXNE
			SPI_ReceiveData(SPI2,&dummy_read,1);

			delay();

			//send message
			for(int i = 0 ; i < args[0] ; i++){
				SPI_SendData(SPI2,&message[i],1);
				SPI_ReceiveData(SPI2,&dummy_read,1);
			}

			printf("COMMAND_PRINT Executed\n");
		}

	//5. CMD_ID_READ
		//wait until button is pressed
		while(GPIO_ReadFromInputPin(GPIOC, GPIO_PIN_NO_13));

		//to avoid button debouncing related issues
		delay();

		//send command
		command_code = COMMAND_ID_READ;
		SPI_SendData(SPI2, &command_code, 1);

		//do dummy read to clear RXNE
		SPI_ReceiveData(SPI2, &dummy_read, 1);

		//send some dummy bits (1 byte or 2 bytes depending on 8 or 16 bit comms) to fetch the response from the slave.
		SPI_SendData(SPI2, &dummy_write, 1);

		//read the ack byte received
		SPI_ReceiveData(SPI2, &ack_byte, 1);

		uint8_t id[11];
		uint32_t i = 0;

		if(SPI_VerifyResponse(ack_byte)) {

			//read 10 bytes id from the slave
			for(i = 0; i < 10; i++) {

				//send dummy byte to fetch data from slave
				SPI_SendData(SPI2, &dummy_write, 1);
				SPI_ReceiveData(SPI2, &id[i], 1);
			}

			id[10] = '\0';

			printf("COMMAND_ID : %s\n", id);
		}

		//confirm SPI is not busy
		while(SPI_GetFlagStatus(SPI2, SPI_FLAG_BUSY));

		//disable the SPI2 peripheral
		SPI_PeripheralControl(SPI2, DISABLE);

		printf("SPI Communication Closed\n");
	}

	return 0;
}

/****************************************************************************************/
							007spi_message_rcv_it.c
/****************************************************************************************/
/*
 * This application receives and prints the user message received from the Arduino peripheral in SPI interrupt mode
 * User sends the message through Arduino IDE's serial monitor tool
 * Monitor the message received in the SWV itm data console
 */
/*
 * Note : Follow the instructions to test this code
 * 1. Download this code on to STM32 board , acts as Master
 * 2. Download Slave code (003SPISlaveUartReadOverSPI.ino) on to Arduino board (Slave)
 * 3. Reset both the boards
 * 4. Enable SWV ITM data console to see the message
 * 5. Open Arduino IDE serial monitor tool
 * 6. Type anything and send the message (Make sure that in the serial monitor tool line ending set to carriage return)
 */
#include <stdio.h>
#include <string.h>
#include "stm32f446xx.h"


SPI_Handle_t SPI2handle;

#define MAX_LEN 500

char RcvBuff[MAX_LEN];

volatile char ReadByte;


volatile uint8_t rcvStop = 0;

/*This flag will be set in the interrupt handler of the Arduino interrupt GPIO */
volatile uint8_t dataAvailable = 0;

void delay(void) {

	//this will introduce ~200ms delay when the system clock is 16MHz
	for(uint32_t i = 0; i < 250000; i++);
}

/*
 * PB14 --> SPI2_MISO
 * PB15 --> SPI2_MOSI
 * PB13 -> SPI2_SCLK
 * PB12 --> SPI2_NSS
 * ALT function mode : 5
 */

void SPI2_GPIOInits(void) {

	GPIO_Handle_t SPIPins;

	SPIPins.pGPIOx = GPIOB;
	SPIPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	SPIPins.GPIO_PinConfig.GPIO_PinAltFunMode = 5;
	SPIPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	SPIPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	SPIPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

	//NSS
	SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_12;
	GPIO_Init(&SPIPins);

	//SCK
	SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIO_Init(&SPIPins);

	//MISO
	SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_14;
	GPIO_Init(&SPIPins);

	//MOSI
	SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_15;
	GPIO_Init(&SPIPins);
}

void SPI2_Inits(void) {

	SPI2handle.pSPIx = SPI2;
	SPI2handle.SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_FD;
	SPI2handle.SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;
	SPI2handle.SPIConfig.SPI_SclkSpeed = SPI_SCLK_SPEED_DIV32;
	SPI2handle.SPIConfig.SPI_DFF = SPI_DFF_8BITS;
	SPI2handle.SPIConfig.SPI_CPOL = SPI_CPOL_LOW;
	SPI2handle.SPIConfig.SPI_CPHA = SPI_CPHA_LOW;
	SPI2handle.SPIConfig.SPI_SSM = SPI_SSM_DI; //Hardware slave management enabled for NSS pin

	SPI_Init(&SPI2handle);
}


/*This function configures the gpio pin (PC4) over which SPI peripheral issues data available interrupt */
void Slave_GPIO_InterruptPinInit(void) {

	GPIO_Handle_t spiIntPin;

	memset(&spiIntPin, 0, sizeof(spiIntPin));

	//LED GPIO configuration
	spiIntPin.pGPIOx = GPIOC;
	spiIntPin.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_4;
	spiIntPin.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN_FT;
	spiIntPin.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_LOW;
	spiIntPin.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;

	GPIO_Init(&spiIntPin);

	GPIO_IRQPriorityConfig(IRQ_NO_EXTI4, NVIC_IRQ_PRI15);
	GPIO_IRQInterruptConfig(IRQ_NO_EXTI4, ENABLE);
}

/* This function configures the gpio pin (PB3) which acts as SWO to facilitate SWV Trace Output for printf() 
   statement of RcvBuff contents */
//void SWO_GPIO_SWVTraceInit(void) {
//
//	GPIO_Handle_t tracePin;
//
//	memset(&tracePin, 0, sizeof(tracePin));
//
//	//LED GPIO configuration
//	tracePin.pGPIOx = GPIOB;
//	tracePin.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_3;
//	tracePin.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
//	tracePin.GPIO_PinConfig.GPIO_PinAltFunMode = 0;
//	//tracePin.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
//	tracePin.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;
//	tracePin.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
//	tracePin.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
//
//	GPIO_Init(&tracePin);
//
//
//}


int main(void) {

	uint8_t dummy = 0xFF;

	Slave_GPIO_InterruptPinInit();

	//this function is used to initialize the GPIO pins to behave as SPI2 pins
	SPI2_GPIOInits();

	//This function is used to initialize the SPI2 peripheral parameters
	SPI2_Inits();

	/*
	* making SSOE 1 does NSS output enable.
	* The NSS pin is automatically managed by the hardware.
	* i.e when SPE=1 , NSS will be pulled to low
	* and NSS pin will be high when SPE=0
	*/
	SPI_SSOEConfig(SPI2, ENABLE);

	SPI_IRQInterruptConfig(IRQ_NO_SPI2, ENABLE);

	while(1){

		rcvStop = 0;

		while(!dataAvailable); //wait till data available interrupt from transmitter device(slave)

		GPIO_IRQInterruptConfig(IRQ_NO_EXTI4, DISABLE);

		//enable the SPI2 peripheral
		SPI_PeripheralControl(SPI2, ENABLE);

		while(!rcvStop) {
			/* fetch the data from the SPI peripheral byte by byte in interrupt mode */
			while(SPI_SendDataIT(&SPI2handle, &dummy, 1) == SPI_BUSY_IN_TX);
			while(SPI_ReceiveDataIT(&SPI2handle, (uint8_t*)&ReadByte, 1) == SPI_BUSY_IN_RX);
		}

		// confirm SPI is not busy
		while(SPI_GetFlagStatus(SPI2, SPI_FLAG_BUSY));

		//Disable the SPI2 peripheral
		SPI_PeripheralControl(SPI2, DISABLE);

		printf("Rcvd data = %s\n", RcvBuff);

		dataAvailable = 0;

		GPIO_IRQInterruptConfig(IRQ_NO_EXTI4, ENABLE);
	}

	return 0;
}


/* Runs when a data byte is received from the peripheral over SPI*/
void SPI2_IRQHandler(void) {

	SPI_IRQHandling(&SPI2handle);
}

void SPI_ApplicationEventCallback(SPI_Handle_t *pSPIHandle, uint8_t AppEv) {

	static uint32_t i = 0;

	/* In the RX complete event , copy data in to rcv buffer . '\0' indicates end of message(rcvStop = 1) */
	if(AppEv == SPI_EVENT_RX_CMPLT) {

		RcvBuff[i++] = ReadByte;

		if(ReadByte == '\0' || (i == MAX_LEN)) {

			rcvStop = 1;
			RcvBuff[i-1] = '\0';
			i = 0;
		}
	}
}

/* Slave data available interrupt handler */
void EXTI4_IRQHandler(void) {

	GPIO_IRQHandling(GPIO_PIN_NO_4);
	dataAvailable = 1;
}

/****************************************************************************************/
							008i2c_master_tx_testing.c
/****************************************************************************************/
#include <stdio.h>
#include <string.h>
#include "stm32f446xx.h"

I2C_Handle_t I2C1Handle;

#define MY_ADDR 	0x61
#define SLAVE_ADDR 	0x68

//some data
uint8_t some_data[] = "We are testing I2C master Tx\n";

void delay(void) {

	//this will introduce ~200ms delay when the system clock is 16MHz
	for(uint32_t i = 0; i < 250000; i++);
}

/*
 * PB6 -> I2C1_SCL
 * PB7 -> I2C1_SDA
 *
 * ALT function mode : 4
 */

void I2C1_GPIOInits(void) {

	GPIO_Handle_t I2CPins;

	/*Note : Internal pull-up resistors are used */

	I2CPins.pGPIOx = GPIOB;
	I2CPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	I2CPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD;
	/*
	 * Note : In the below line use GPIO_NO_PUPD option if you want to use external pullup resistors, then you have to use 
	 * 3.3K pull up resistors for both SDA and SCL lines
	 */
	I2CPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
	I2CPins.GPIO_PinConfig.GPIO_PinAltFunMode = 4;
	I2CPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

	//SCL
	I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_6;
	GPIO_Init(&I2CPins);

	//SDA
	I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_7;
	GPIO_Init(&I2CPins);
}

void I2C1_Inits(void) {

	I2C1Handle.pI2Cx = I2C1;
	I2C1Handle.I2C_Config.I2C_AckControl = I2C_ACK_ENABLE;
	I2C1Handle.I2C_Config.I2C_DeviceAddress = MY_ADDR;
	I2C1Handle.I2C_Config.I2C_FMDutyCycle = I2C_FM_DUTY_2;
	I2C1Handle.I2C_Config.I2C_SCLSpeed = I2C_SCL_Speed_SM;

	I2C_Init(&I2C1Handle);
}

void GPIO_ButtonInit() {

	// User Push Button = PC13
	GPIO_Handle_t GPIOBtn;

	GPIOBtn.pGPIOx = GPIOC;
	GPIOBtn.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIOBtn.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	GPIOBtn.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOBtn.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_Init(&GPIOBtn);
}

int main(void) {

	//Push Button Init
	GPIO_ButtonInit();

	//I2C pin inits
	I2C1_GPIOInits();

	//I2C peripheral configuration
	I2C1_Inits();

	//Enable the I2C peripheral
	I2C_PeripheralControl(I2C1, ENABLE);

	while(1) {
		//wait for button press
		while(GPIO_ReadFromInputPin(GPIOC, GPIO_PIN_NO_13));

		//to avoid button de-bouncing related issues 200ms of delay
		delay();

		//Send some data to the slave
		I2C_MasterSendData(&I2C1Handle, some_data, strlen((char*)some_data), SLAVE_ADDR);
	}

	return 0;
}

/****************************************************************************************/
							009i2c_master_rx_testing.c
/****************************************************************************************/
#include <stdio.h>
#include <string.h>
#include "stm32f446xx.h"

extern void initialise_monitor_handles();

I2C_Handle_t I2C1Handle;

#define MY_ADDR 	0x61
#define SLAVE_ADDR 	0x68

//Rcv buffer
uint8_t rcv_buf[32];

void delay(void) {

	//this will introduce ~200ms delay when the system clock is 16MHz
	for(uint32_t i = 0; i < 250000; i++);
}

/*
 * PB6 -> I2C1_SCL
 * PB7 -> I2C1_SDA
 *
 * ALT function mode : 4
 */

void I2C1_GPIOInits(void) {

	GPIO_Handle_t I2CPins;

	/*Note : Internal pull-up resistors are used */

	I2CPins.pGPIOx = GPIOB;
	I2CPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	I2CPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD;
	/*
	 * Note : In the below line use GPIO_NO_PUPD option if you want to use external pullup resistors, then you have to use 
	 * 3.3K pull up resistors for both SDA and SCL lines
	 */
	I2CPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
	I2CPins.GPIO_PinConfig.GPIO_PinAltFunMode = 4;
	I2CPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

	//SCL
	I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_6;
	GPIO_Init(&I2CPins);

	//SDA
	I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_7;
	GPIO_Init(&I2CPins);
}

void I2C1_Inits(void) {

	I2C1Handle.pI2Cx = I2C1;
	I2C1Handle.I2C_Config.I2C_AckControl = I2C_ACK_ENABLE;
	I2C1Handle.I2C_Config.I2C_DeviceAddress = MY_ADDR;
	I2C1Handle.I2C_Config.I2C_FMDutyCycle = I2C_FM_DUTY_2;
	I2C1Handle.I2C_Config.I2C_SCLSpeed = I2C_SCL_Speed_SM;

	I2C_Init(&I2C1Handle);
}

void GPIO_ButtonInit() {

	// User Push Button = PC13
	GPIO_Handle_t GPIOBtn;

	GPIOBtn.pGPIOx = GPIOC;
	GPIOBtn.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIOBtn.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	GPIOBtn.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOBtn.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_Init(&GPIOBtn);
}

int main(void) {

	uint8_t commandcode, len;

	initialise_monitor_handles();
	printf("Application is running\n");

	//Push Button Init
	GPIO_ButtonInit();

	//I2C pin inits
	I2C1_GPIOInits();

	//I2C peripheral configuration
	I2C1_Inits();

	//Enable the I2C peripheral
	I2C_PeripheralControl(I2C1, ENABLE);

	//ACK bit is set to 1 after PE=1
	I2C_ManageAcking(I2C1, I2C_ACK_ENABLE);

	while(1) {
		//wait for button press
		while(GPIO_ReadFromInputPin(GPIOC, GPIO_PIN_NO_13));

		//to avoid button de-bouncing related issues 200ms of delay
		delay();

		commandcode = 0x51;
		I2C_MasterSendData(&I2C1Handle, &commandcode, 1, SLAVE_ADDR, I2C_ENABLE_SR);
		I2C_MasterReceiveData(&I2C1Handle, &len, 1, SLAVE_ADDR, I2C_ENABLE_SR);

		commandcode = 0x52;
		I2C_MasterSendData(&I2C1Handle, &commandcode, 1, SLAVE_ADDR, I2C_ENABLE_SR);
		I2C_MasterReceiveData(&I2C1Handle, rcv_buf, len, SLAVE_ADDR, I2C_DISABLE_SR);

		rcv_buf[len + 1] = '\0';
		printf("Data : %s", rcv_buf);
	}

	return 0;
}

/****************************************************************************************/
							010i2c_master_rx_testingIT.c
/****************************************************************************************/
#include <stdio.h>
#include <string.h>
#include "stm32f446xx.h"

extern void initialise_monitor_handles();

I2C_Handle_t I2C1Handle;

//Flag variable
uint8_t rxComplete = RESET;

#define MY_ADDR 	0x61
#define SLAVE_ADDR 	0x68 //changing this will trigger ACK failure (AF) error

//Rcv buffer
uint8_t rcv_buf[32];

void delay(void) {

	//this will introduce ~200ms delay when the system clock is 16MHz
	for(uint32_t i = 0; i < 250000; i++);
}

/*
 * PB6 -> I2C1_SCL
 * PB7 -> I2C1_SDA
 *
 * ALT function mode : 4
 */

void I2C1_GPIOInits(void) {

	GPIO_Handle_t I2CPins;

	/* Note : Internal pull-up resistors are used */

	I2CPins.pGPIOx = GPIOB;
	I2CPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	I2CPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD;
	/*
	 * Note : In the below line use GPIO_NO_PUPD option if you want to use external pullup resistors, then you have to use 
	 * 3.3K pull up resistors for both SDA and SCL lines
	 */
	I2CPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
	I2CPins.GPIO_PinConfig.GPIO_PinAltFunMode = 4;
	I2CPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

	//SCL
	I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_6;
	GPIO_Init(&I2CPins);

	//SDA
	I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_7;
	GPIO_Init(&I2CPins);
}

void I2C1_Inits(void) {

	I2C1Handle.pI2Cx = I2C1;
	I2C1Handle.I2C_Config.I2C_AckControl = I2C_ACK_ENABLE;
	I2C1Handle.I2C_Config.I2C_DeviceAddress = MY_ADDR;
	I2C1Handle.I2C_Config.I2C_FMDutyCycle = I2C_FM_DUTY_2;
	I2C1Handle.I2C_Config.I2C_SCLSpeed = I2C_SCL_Speed_SM;

	I2C_Init(&I2C1Handle);
}

void GPIO_ButtonInit() {

	// User Push Button = PC13
	GPIO_Handle_t GPIOBtn;

	GPIOBtn.pGPIOx = GPIOC;
	GPIOBtn.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIOBtn.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	GPIOBtn.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOBtn.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_Init(&GPIOBtn);
}

int main(void) {

	uint8_t commandcode, len;

	initialise_monitor_handles();
	printf("Application is running\n");

	//Push Button Init
	GPIO_ButtonInit();

	//I2C pin inits
	I2C1_GPIOInits();

	//I2C peripheral configuration
	I2C1_Inits();

	//I2C IRQ configurations
	I2C_IRQInterruptConfig(IRQ_NO_I2C1_EV, ENABLE);
	I2C_IRQInterruptConfig(IRQ_NO_I2C1_ER, ENABLE);
	//no need to implement priority function

	//Enable the I2C peripheral
	I2C_PeripheralControl(I2C1, ENABLE);

	//ACK bit is set to 1 after PE=1
	I2C_ManageAcking(I2C1, I2C_ACK_ENABLE);

	while(1) {
		//wait for button press
		while(GPIO_ReadFromInputPin(GPIOC, GPIO_PIN_NO_13));

		//to avoid button de-bouncing related issues 200ms of delay
		delay();

		commandcode = 0x51;
		while(I2C_MasterSendDataIT(&I2C1Handle, &commandcode, 1, SLAVE_ADDR, I2C_ENABLE_SR) != I2C_READY);
		while(I2C_MasterReceiveDataIT(&I2C1Handle, &len, 1, SLAVE_ADDR, I2C_ENABLE_SR) != I2C_READY);

		commandcode = 0x52;
		while(I2C_MasterSendDataIT(&I2C1Handle, &commandcode, 1, SLAVE_ADDR, I2C_ENABLE_SR) != I2C_READY);
		while(I2C_MasterReceiveDataIT(&I2C1Handle, rcv_buf, len, SLAVE_ADDR, I2C_DISABLE_SR) != I2C_READY);

		rxComplete = RESET;

		//wait until RX completes
		while(rxComplete != SET);

		rcv_buf[len + 1] = '\0';
		printf("Data : %s", rcv_buf);

		rxComplete = RESET;
	}

	return 0;
}

void I2C1_EV_IRQHandler(void) {

	I2C_EV_IRQHandling(&I2C1Handle);
}

void I2C1_ER_IRQHandler(void) {

	I2C_ER_IRQHandling(&I2C1Handle);
}

void I2C_ApplicationEventCallback(I2C_Handle_t *pI2CHandle, uint8_t AppEv) {

	if(AppEv == I2C_EV_TX_CMPLT) {
		printf("Tx is completed\n");

	} else if(AppEv == I2C_EV_RX_CMPLT) {
		printf("Rx is completed\n");
		rxComplete = SET;

	} else if(AppEv == I2C_EV_STOP) {
		printf("STOP condition initiated\n");

	} else if(AppEv == I2C_ERROR_BERR) {
		printf("Error : Bus Error\n");

	} else if(AppEv == I2C_ERROR_ARLO) {
		printf("Error : Bus Arbitration Lost\n");

	} else if(AppEv == I2C_ERROR_AF) {
		printf("Error : ACK failure\n");

		//in master, ACK failure happens when slave fails to send ACK for the byte sent by master.
		I2C_CloseTransmission(pI2CHandle);

		//generate the STOP condition to release the bus
		I2C_GenerateStopCondition(I2C1);

		//hang in infinite loop
		while(1);

	} else if(AppEv == I2C_ERROR_OVR) {
		printf("Error : Overrun/Underrun\n");

	} else if(AppEv == I2C_ERROR_TIMEOUT) {
		printf("Error : TIMEOUT\n");

	} else if(AppEv == I2C_EV_DATA_REQ) {
		printf("Data Requested\n");

	} else if(AppEv == I2C_EV_DATA_RCV) {
		printf("Data Received\n");

	}
}

/****************************************************************************************/
							011i2c_slave_tx_string.c
/****************************************************************************************/
#include <stdio.h>
#include <string.h>
#include "stm32f446xx.h"

I2C_Handle_t I2C1Handle;

#define SLAVE_ADDR 		0x68 //changing this will trigger ACK failure (AF) error
#define MY_ADDR			SLAVE_ADDR

//tx buffer
uint8_t tx_buf[32] = "STM32 Slave mode testing..";

void delay(void) {

	//this will introduce ~200ms delay when the system clock is 16MHz
	for(uint32_t i = 0; i < 250000; i++);
}

/*
 * PB6 -> I2C1_SCL
 * PB7 -> I2C1_SDA
 *
 * ALT function mode : 4
 */

void I2C1_GPIOInits(void) {

	GPIO_Handle_t I2CPins;

	/* Note : Internal pull-up resistors are used */

	I2CPins.pGPIOx = GPIOB;
	I2CPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	I2CPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD;
	/*
	 * Note : In the below line use GPIO_NO_PUPD option if you want to use external pullup resistors, then you have to use 
	 * 3.3K pull up resistors for both SDA and SCL lines
	 */
	I2CPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
	I2CPins.GPIO_PinConfig.GPIO_PinAltFunMode = 4;
	I2CPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

	//SCL
	I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_6;
	GPIO_Init(&I2CPins);

	//SDA
	I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_7;
	GPIO_Init(&I2CPins);
}

void I2C1_Inits(void) {

	I2C1Handle.pI2Cx = I2C1;
	I2C1Handle.I2C_Config.I2C_AckControl = I2C_ACK_ENABLE;
	I2C1Handle.I2C_Config.I2C_DeviceAddress = MY_ADDR;
	I2C1Handle.I2C_Config.I2C_FMDutyCycle = I2C_FM_DUTY_2;
	I2C1Handle.I2C_Config.I2C_SCLSpeed = I2C_SCL_Speed_SM;

	I2C_Init(&I2C1Handle);
}

void GPIO_ButtonInit() {

	// User Push Button = PC13
	GPIO_Handle_t GPIOBtn;

	GPIOBtn.pGPIOx = GPIOC;
	GPIOBtn.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIOBtn.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	GPIOBtn.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOBtn.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_Init(&GPIOBtn);
}

int main(void) {

	//printf("Application is running\n");

	//Push Button Init
	GPIO_ButtonInit();

	//I2C pin inits
	I2C1_GPIOInits();

	//I2C peripheral configuration
	I2C1_Inits();

	//I2C IRQ configurations
	I2C_IRQInterruptConfig(IRQ_NO_I2C1_EV, ENABLE);
	I2C_IRQInterruptConfig(IRQ_NO_I2C1_ER, ENABLE);
	//no need to implement priority function

	I2C_SlaveEnableDisableCallbackEvents(I2C1,ENABLE);

	//Enable the I2C peripheral
	I2C_PeripheralControl(I2C1, ENABLE);

	//ACK bit is set to 1 after PE=1
	I2C_ManageAcking(I2C1, I2C_ACK_ENABLE);

	while(1);
	return 0;
}

void I2C1_EV_IRQHandler(void) {

	I2C_EV_IRQHandling(&I2C1Handle);
}

void I2C1_ER_IRQHandler(void) {

	I2C_ER_IRQHandling(&I2C1Handle);
}

void I2C_ApplicationEventCallback(I2C_Handle_t *pI2CHandle, uint8_t AppEv) {

	static uint8_t commandCode = 0;
	static uint8_t cnt = 0;
	if(AppEv == I2C_EV_TX_CMPLT) {

	} else if(AppEv == I2C_EV_RX_CMPLT) {

	} else if(AppEv == I2C_EV_STOP) {
		//This happens only during slave reception.
		//Master has ended the I2C communication with the slave.

	} else if(AppEv == I2C_ERROR_BERR) {

	} else if(AppEv == I2C_ERROR_ARLO) {

	} else if(AppEv == I2C_ERROR_AF) {
		//This happens only during slave transmission
		//Master has sent the NACK so slave should understand that master doesn't need more data
		commandCode = 0xFF;
		cnt = 0;

	} else if(AppEv == I2C_ERROR_OVR) {

	} else if(AppEv == I2C_ERROR_TIMEOUT) {

	} else if(AppEv == I2C_EV_DATA_REQ) {
		//Master wants some data. Slave has to send it.
		if(commandCode == 0x51) {
			//send the length information to the master.
			I2C_SlaveSendData(pI2CHandle->pI2Cx, strlen((char*)tx_buf));
		} else if(commandCode == 0x52) {
			//send the contents of tx_buf
			I2C_SlaveSendData(pI2CHandle->pI2Cx, tx_buf[cnt++]);
		}

	} else if(AppEv == I2C_EV_DATA_RCV) {
		//Data is waiting for the slave to read. Slave has to read it.
		commandCode = I2C_SlaveReceiveData(pI2CHandle->pI2Cx);
	}
}

/****************************************************************************************/
							012i2c_slave_tx_string2.c
/****************************************************************************************/
#include <stdio.h>
#include <string.h>
#include "stm32f446xx.h"

I2C_Handle_t I2C1Handle;

#define SLAVE_ADDR 		0x68 //changing this will trigger ACK failure (AF) error
#define MY_ADDR			SLAVE_ADDR

uint32_t data_len = 0;

//tx buffer
uint8_t tx_buf[] = "HiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHi \
				HiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHi \
				HiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHi \
				HiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHi \
				HiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHiHi...123";
//rcv buffer
uint8_t rcv_buf[32];

uint8_t commandCode;

void delay(void) {

	//this will introduce ~200ms delay when the system clock is 16MHz
	for(uint32_t i = 0; i < 250000; i++);
}


/*
 * PB6 -> I2C1_SCL
 * PB7 -> I2C1_SDA
 *
 * ALT function mode : 4
 */

void I2C1_GPIOInits(void) {

	GPIO_Handle_t I2CPins;

	/* Note : Internal pull-up resistors are used */

	I2CPins.pGPIOx = GPIOB;
	I2CPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	I2CPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD;
	/*
	 * Note : In the below line use GPIO_NO_PUPD option if you want to use external pullup resistors, 
	 * then you have to use 3.3K pull up resistors for both SDA and SCL lines
	 */
	I2CPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
	I2CPins.GPIO_PinConfig.GPIO_PinAltFunMode = 4;
	I2CPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

	//SCL
	I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_6;
	GPIO_Init(&I2CPins);

	//SDA
	I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_7;
	GPIO_Init(&I2CPins);
}

void I2C1_Inits(void) {

	I2C1Handle.pI2Cx = I2C1;
	I2C1Handle.I2C_Config.I2C_AckControl = I2C_ACK_ENABLE;
	I2C1Handle.I2C_Config.I2C_DeviceAddress = MY_ADDR;
	I2C1Handle.I2C_Config.I2C_FMDutyCycle = I2C_FM_DUTY_2;
	I2C1Handle.I2C_Config.I2C_SCLSpeed = I2C_SCL_Speed_SM;

	I2C_Init(&I2C1Handle);
}

void GPIO_ButtonInit() {

	// User Push Button = PC13
	GPIO_Handle_t GPIOBtn;

	GPIOBtn.pGPIOx = GPIOC;
	GPIOBtn.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIOBtn.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	GPIOBtn.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOBtn.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_Init(&GPIOBtn);
}

int main(void) {

	//printf("Application is running\n");
	data_len = strlen((char*)tx_buf);

	//Push Button Init
	GPIO_ButtonInit();

	//I2C pin inits
	I2C1_GPIOInits();

	//I2C peripheral configuration
	I2C1_Inits();

	//Enable the I2C peripheral
	I2C_PeripheralControl(I2C1, ENABLE);

	//ACK bit is set to 1 after PE=1
	I2C_ManageAcking(I2C1, I2C_ACK_ENABLE);

	//I2C IRQ configurations
	I2C_IRQInterruptConfig(IRQ_NO_I2C1_EV, ENABLE);
	I2C_IRQInterruptConfig(IRQ_NO_I2C1_ER, ENABLE);
	//no need to implement priority function

	I2C_SlaveEnableDisableCallbackEvents(I2C1,ENABLE);

	while(1);
	return 0;
}

void I2C1_EV_IRQHandler(void) {

	I2C_EV_IRQHandling(&I2C1Handle);
}

void I2C1_ER_IRQHandler(void) {

	I2C_ER_IRQHandling(&I2C1Handle);
}

void I2C_ApplicationEventCallback(I2C_Handle_t *pI2CHandle, uint8_t AppEv) {

	static uint8_t cnt = 0;
	static uint8_t w_ptr = 0;

	if(AppEv == I2C_EV_TX_CMPLT) {

	} else if(AppEv == I2C_EV_RX_CMPLT) {

	} else if(AppEv == I2C_EV_STOP) {
		//This will happen during end slave reception
		//slave concludes end of Rx
		cnt = 0;

	} else if(AppEv == I2C_ERROR_BERR) {

	} else if(AppEv == I2C_ERROR_ARLO) {

	} else if(AppEv == I2C_ERROR_AF) {
		//This will occur during slave transmission to master .
		//slave should understand master needs no more data
		//slave concludes end of Tx


		//if the current active code is 0x52 then don't invalidate
		if(!(commandCode == 0x52)) {
			commandCode = 0xFF;
		}

		//reset the cnt variable because transmission is completed
		cnt = 0;

		//Slave concludes it sent all the bytes when w_ptr reaches data_len
		if(w_ptr >= (data_len))
		{
			w_ptr = 0;
			commandCode = 0xFF;
		}

	} else if(AppEv == I2C_ERROR_OVR) {

	} else if(AppEv == I2C_ERROR_TIMEOUT) {

	} else if(AppEv == I2C_EV_DATA_REQ) {
		//Master is requesting data. Send data.
		if(commandCode == 0x51) {
			//sending 4 bytes of length information
			I2C_SlaveSendData(I2C1, ((data_len >> ((cnt % 4) * 8)) & 0xFF));
			cnt++;
		} else if (commandCode == 0x52) {
			//sending tx_buf contents indexed by w_ptr variable
			I2C_SlaveSendData(I2C1, tx_buf[w_ptr++]);
		}

	} else if(AppEv == I2C_EV_DATA_RCV) {
		//Master has sent command code, read it
		commandCode = I2C_SlaveReceiveData(I2C1);

	}
}


/****************************************************************************************/
								013uart_tx.c
/****************************************************************************************/
#include <stdio.h>
#include <string.h>
#include "stm32f446xx.h"

char msg[1024] = "UART Tx testing...\n\r";

USART_Handle_t USART1Handle;

void delay(void) {

	//this will introduce ~200ms delay when the system clock is 16MHz
	for(uint32_t i = 0; i < 250000; i++);
}

void USART1_GPIOInit(void) {

	GPIO_Handle_t USARTPins;

	/* Note : Internal pull-up resistors are used */

	USARTPins.pGPIOx = GPIOA;
	USARTPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	USARTPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	USARTPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
	USARTPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	USARTPins.GPIO_PinConfig.GPIO_PinAltFunMode = 7;

	//Using USART2 peripheral requires solder bridge changes to Nucleo-F446RE board
	//to allow PA2 and PA3 to be used instead of Tx/Rx jumper (CN3) on the ST-link debug board

	//USART1 peripheral does not require any physical changes

	//USART1 TX (PA9)
	USARTPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_9;
	GPIO_Init(&USARTPins);

	//USART1 RX (PA10)
	USARTPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_10;
	GPIO_Init(&USARTPins);
}

void USART1_Init(void) {

	USART1Handle.pUSARTx = USART1;
	USART1Handle.USART_Config.USART_Baud = USART_STD_BAUD_115200;
	USART1Handle.USART_Config.USART_HWFlowControl = USART_HW_FLOW_CTRL_NONE;
	USART1Handle.USART_Config.USART_Mode = USART_MODE_ONLY_TX;
	USART1Handle.USART_Config.USART_NoOfStopBits = USART_STOPBITS_1;
	USART1Handle.USART_Config.USART_WordLength = USART_WORDLEN_8BITS;
	USART1Handle.USART_Config.USART_ParityControl = USART_PARITY_DISABLE;

	USART_Init(&USART1Handle);
}

void GPIO_ButtonInit() {

	// User Push Button = PC13
	GPIO_Handle_t GPIOBtn;

	GPIOBtn.pGPIOx = GPIOC;
	GPIOBtn.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIOBtn.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	GPIOBtn.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOBtn.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_Init(&GPIOBtn);
}

int main(void) {

	//Push Button Init
	GPIO_ButtonInit();

	//USART pin inits
	USART1_GPIOInit();

	//USART peripheral configuration
	USART1_Init();

	//Enable the I2C peripheral
	USART_PeripheralControl(USART1, ENABLE);


	while(1) {
		//wait for button press
		while(GPIO_ReadFromInputPin(GPIOC, GPIO_PIN_NO_13));

		//to avoid button de-bouncing related issues 200ms of delay
		delay();

		USART_SendData(&USART1Handle, (uint8_t*)msg, strlen(msg));
	}

	return 0;
}

/****************************************************************************************/
								014uart_case.c
/****************************************************************************************/	
#include <stdio.h>
#include <string.h>
#include "stm32f446xx.h"

char *msg[3] = {"hihihihihihi123", "Hello How are you ?" , "Today is Monday !"};

USART_Handle_t USART1Handle;

//reply from arduino will be stored here
char rx_buf[1024];

//This flag indicates reception completion
uint8_t rxCmplt = RESET;

uint8_t g_data = 0;

extern void initialise_monitor_handles();

void delay(void) {

	//this will introduce ~200ms delay when the system clock is 16MHz
	for(uint32_t i = 0; i < 250000; i++);
}

void USART1_GPIOInit(void) {

	GPIO_Handle_t USARTPins;

	/* Note : Internal pull-up resistors are used */

	USARTPins.pGPIOx = GPIOA;
	USARTPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	USARTPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	USARTPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
	USARTPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	USARTPins.GPIO_PinConfig.GPIO_PinAltFunMode = 7;

	//Using USART2 peripheral requires solder bridge changes to Nucleo-F446RE board
	//to allow PA2 and PA3 to be used instead of Tx/Rx jumper (CN3) on the ST-link debug board

	//USART1 peripheral does not require any physical changes

	//USART1 TX (PA9)
	USARTPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_9;
	GPIO_Init(&USARTPins);

	//USART1 RX (PA10)
	USARTPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_10;
	GPIO_Init(&USARTPins);
}

void USART1_Init(void) {

	USART1Handle.pUSARTx = USART1;
	USART1Handle.USART_Config.USART_Baud = USART_STD_BAUD_115200;
	USART1Handle.USART_Config.USART_HWFlowControl = USART_HW_FLOW_CTRL_NONE;
	USART1Handle.USART_Config.USART_Mode = USART_MODE_TXRX;
	USART1Handle.USART_Config.USART_NoOfStopBits = USART_STOPBITS_1;
	USART1Handle.USART_Config.USART_WordLength = USART_WORDLEN_8BITS;
	USART1Handle.USART_Config.USART_ParityControl = USART_PARITY_DISABLE;

	USART_Init(&USART1Handle);
}

void GPIO_ButtonInit() {

	// User Push Button = PC13
	GPIO_Handle_t GPIOBtn;

	GPIOBtn.pGPIOx = GPIOC;
	GPIOBtn.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIOBtn.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	GPIOBtn.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOBtn.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_Init(&GPIOBtn);
}

int main(void) {


	uint32_t cnt = 0;

	initialise_monitor_handles();

	//Push Button Init
	GPIO_ButtonInit();

	//USART pin inits
	USART1_GPIOInit();

	//USART peripheral configuration
	USART1_Init();

	//Enable USART Interrupts
	USART_IRQInterruptConfig(IRQ_NO_USART1, ENABLE);

	//Enable the I2C peripheral
	USART_PeripheralControl(USART1, ENABLE);

    printf("Application is running\n");

	while(1) {
		//wait for button press
		while(GPIO_ReadFromInputPin(GPIOC, GPIO_PIN_NO_13));

		//to avoid button de-bouncing related issues 200ms of delay
		delay();

		//Next message index -- make sure that cnt value doesn't cross 2
		cnt = cnt % 3;

		//First enable the reception in interrupt mode
		while(USART_ReceiveDataIT(&USART1Handle, rx_buf, strlen(msg[cnt])) != USART_READY);

		//Send the message indexed by cnt in blocking (polling) mode
		USART_SendData(&USART1Handle, (uint8_t*)msg[cnt], strlen(msg[cnt]));

		printf("Transmitted : %s\n", msg[cnt]);

		//Wait until all bytes are received from the Arduino
		//When all bytes are received, rxCmplt will be SET in application callback
		while(rxCmplt != SET);

		//Ensure that last byte should be null otherwise %s fails while printing
		rx_buf[strlen(msg[cnt]) + 1] = '\0';

    	//Print received message from Arduino
    	printf("Received    : %s\n", rx_buf);

    	//Clear the flag
    	rxCmplt = RESET;

    	//move on to the next message indexed in msg[]
    	cnt++;
	}

	return 0;
}

void USART1_IRQHandler(void)
{
	USART_IRQHandling(&USART1Handle);
}

void USART_ApplicationEventCallback(USART_Handle_t *pUSARTHandle, uint8_t AppEv)
{
   if(AppEv == USART_EVENT_RX_CMPLT) {
	   rxCmplt = SET;

   } else if(AppEv == USART_EVENT_TX_CMPLT) {
	   ;
   }
}

/****************************************************************************************/
									015rtc_lcd
/****************************************************************************************/	
/*
 *		Application Layer				rtc_lcd.c					Application
 *
 *
 * 	This layer abstracts		lcd.c ds1307.c lcd.h ds1307.h			BSP
 * 	the usage of RTC and LCD
 *
 * 	This layer abstracts the		GPIO driver, I2C driver			  HAL, LL
 * 	usage of MCU peripherals
 */


/* LCD GPIOs */
//PA0 = RS, PA1 = R/W, PA2 = EN
//PA3 = D4, PA4 = D5, PA5 = D6, PA6 = D7

/* I2C1 GPIOs */
//PB6 = SCL, PB7 = SDA

//extern void initialise_monitor_handles(void);

#include<stdio.h>
#include "ds1307.h"

#include "lcd.h"

#define SYSTICK_TIM_CLK   16000000UL

/* Enable this macro if you want to test RTC on LCD */
#define PRINT_LCD


void init_systick_timer(uint32_t tick_hz) {

	uint32_t *pSRVR = (uint32_t*)0xE000E014;
	uint32_t *pSCSR = (uint32_t*)0xE000E010;

    /* calculation of reload value */
    uint32_t count_value = (SYSTICK_TIM_CLK / tick_hz) - 1;

    //Clear the value of SVR
    *pSRVR &= ~(0x00FFFFFFFF);

    //load the value in to SVR
    *pSRVR |= count_value;

    //do some settings
    *pSCSR |= (1 << 1);  //Enables SysTick exception request:
    *pSCSR |= (1 << 2);  //Indicates the clock source, processor clock source

    //enable the systick
    *pSCSR |= (1 << 0); //enables the counter

}

char* get_day_of_week(uint8_t i) {

	char* days[] = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };

	return days[i - 1];
}

void number_to_string(uint8_t num , char* buf) {

	if(num < 10){
		buf[0] = '0';
		buf[1] = num + 48;

	} else if(num >= 10 && num < 99) {
		buf[0] = (num / 10) + 48;
		buf[1]= (num % 10) + 48;
	}
}

//hh:mm:ss
char* time_to_string(RTC_time_t *rtc_time) {

	static char buf[9];

	buf[2]= ':';
	buf[5]= ':';

	number_to_string(rtc_time->hours, buf);
	number_to_string(rtc_time->minutes, &buf[3]);
	number_to_string(rtc_time->seconds, &buf[6]);

	buf[8] = '\0';

	return buf;
}

//dd/mm/yy
char* date_to_string(RTC_date_t *rtc_date) {

	static char buf[9];

	buf[2]= '/';
	buf[5]= '/';

	number_to_string(rtc_date->date, buf);
	number_to_string(rtc_date->month, &buf[3]);
	number_to_string(rtc_date->year, &buf[6]);

	buf[8]= '\0';

	return buf;

}

static void mdelay(uint32_t cnt) {

	for(uint32_t i = 0; i < (cnt * 1000); i++);
}

int main(void) {

	//initialise_monitor_handles();

	RTC_time_t current_time;
	RTC_date_t current_date;

#ifndef PRINT_LCD
	printf("RTC test\n");
#else
	lcd_init();

	lcd_print_string("RTC Test...");


	mdelay(2000);

	lcd_display_clear();
	lcd_display_return_home();
#endif

	if(ds1307_init()) {
		printf("RTC init has failed\n");
		while(1);
	}

	init_systick_timer(1);

	current_date.day = FRIDAY;
	current_date.date = 15;
	current_date.month = 1;
	current_date.year = 21;

	current_time.hours = 11;
	current_time.minutes = 59;
	current_time.seconds = 30;
	current_time.time_format = TIME_FORMAT_12HRS_PM;

	ds1307_set_current_date(&current_date);
	ds1307_set_current_time(&current_time);

	ds1307_get_current_date(&current_date);
	ds1307_get_current_time(&current_time);

	char *am_pm;

	if(current_time.time_format != TIME_FORMAT_24HRS) {
		am_pm = (current_time.time_format) ? "PM" : "AM";
#ifndef PRINT_LCD
		printf("Current time = %s %s\n", time_to_string(&current_time), am_pm); // 11:59:30 PM
#else
		lcd_print_string(time_to_string(&current_time));
		lcd_print_string(am_pm);
#endif
	} else {
#ifndef PRINT_LCD
		printf("Current time = %s\n", time_to_string(&current_time)); // 11:59:30
#else
		lcd_print_string(time_to_string(&current_time));
#endif
	}

#ifndef PRINT_LCD
	// 15/01/21 <Friday>
	printf("Current date = %s <%s>\n", date_to_string(&current_date), get_day_of_week(current_date.day));
#else
	lcd_set_cursor(2, 1);
	lcd_print_string(date_to_string(&current_date));
#endif

	while(1);

	return 0;
}


void SysTick_Handler(void) {

	RTC_time_t current_time;
	RTC_date_t current_date;

	ds1307_get_current_time(&current_time);

	char *am_pm;
	if(current_time.time_format != TIME_FORMAT_24HRS) {
		am_pm = (current_time.time_format) ? "PM" : "AM";
#ifndef PRINT_LCD
		printf("Current time = %s %s\n", time_to_string(&current_time), am_pm); // 11:59:30 PM
#else
		lcd_set_cursor(1, 1);
		lcd_print_string(time_to_string(&current_time));
		lcd_print_string(am_pm);
#endif

	} else {
#ifndef PRINT_LCD
		printf("Current time = %s\n", time_to_string(&current_time)); // 11:59:30
#else
		lcd_set_cursor(1, 1);
		lcd_print_string(time_to_string(&current_time));
#endif
	}

	ds1307_get_current_date(&current_date);

#ifndef PRINT_LCD
	printf("Current date = %s <%s>\n", date_to_string(&current_date), get_day_of_week(current_date.day));
#else
	lcd_set_cursor(2, 1);
	lcd_print_string(date_to_string(&current_date));
	lcd_print_char('<');
	lcd_print_string(get_day_of_week(current_date.day));
	lcd_print_char('>');
#endif
}

////////////////////////////// BSP ////////////////////////

/****************************************************************************************/
									ds1307.c
/****************************************************************************************/	
#include <stdint.h>
#include <string.h>

#include "ds1307.h"


static void ds1307_i2c_pin_config(void);
static void ds1307_i2c_config(void);
static uint8_t ds1307_read(uint8_t reg_addr);
static void ds1307_write(uint8_t value,uint8_t reg_addr);
static uint8_t bcd_to_binary(uint8_t value);
static uint8_t binary_to_bcd(uint8_t value);

I2C_Handle_t g_ds1307I2CHandle;

static void ds1307_i2c_pin_config(void) {

	GPIO_Handle_t i2c_sda, i2c_scl;

	memset(&i2c_sda, 0, sizeof(i2c_sda));
	memset(&i2c_scl, 0, sizeof(i2c_scl));

	/*
	 * I2C1_SCL ==> PB6
	 * I2C1_SDA ==> PB7
	 */

	i2c_sda.pGPIOx = DS1307_I2C_GPIO_PORT;
	i2c_sda.GPIO_PinConfig.GPIO_PinAltFunMode = 4;
	i2c_sda.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	i2c_sda.GPIO_PinConfig.GPIO_PinNumber = DS1307_I2C_SDA_PIN;
	i2c_sda.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD;
	i2c_sda.GPIO_PinConfig.GPIO_PinPuPdControl = DS1307_I2C_PUPD;
	i2c_sda.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

	GPIO_Init(&i2c_sda);

	i2c_scl.pGPIOx = DS1307_I2C_GPIO_PORT;
	i2c_scl.GPIO_PinConfig.GPIO_PinAltFunMode = 4;
	i2c_scl.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	i2c_scl.GPIO_PinConfig.GPIO_PinNumber = DS1307_I2C_SCL_PIN;
	i2c_scl.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD;
	i2c_scl.GPIO_PinConfig.GPIO_PinPuPdControl = DS1307_I2C_PUPD;
	i2c_scl.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

	GPIO_Init(&i2c_scl);
}

static void ds1307_i2c_config(void) {

	g_ds1307I2CHandle.pI2Cx = DS1307_I2C;
	g_ds1307I2CHandle.I2C_Config.I2C_AckControl = I2C_ACK_ENABLE;
	g_ds1307I2CHandle.I2C_Config.I2C_SCLSpeed = DS1307_I2C_SPEED;
	I2C_Init(&g_ds1307I2CHandle);
}


static void ds1307_write(uint8_t value, uint8_t reg_addr) {

	uint8_t tx[2];
	tx[0] = reg_addr;
	tx[1] = value;
	I2C_MasterSendData(&g_ds1307I2CHandle, tx, 2, DS1307_I2C_ADDRESS, 0);
}



static uint8_t ds1307_read(uint8_t reg_addr) {

	uint8_t data;
    I2C_MasterSendData(&g_ds1307I2CHandle, &reg_addr, 1, DS1307_I2C_ADDRESS, 0);
    I2C_MasterReceiveData(&g_ds1307I2CHandle, &data, 1, DS1307_I2C_ADDRESS, 0);

    return data;
}


static uint8_t binary_to_bcd(uint8_t value) {

	uint8_t m, n;
	uint8_t bcd;

	bcd = value;
	if(value >= 10) {
		m = (value / 10);
		n = (value % 10);
		bcd = ((m << 4) | n);
	}

	return bcd;
}

static uint8_t bcd_to_binary(uint8_t value) {

	uint8_t m, n;

	m = (uint8_t) ((value >> 4) * 10);
	n = (value & (uint8_t)0x0F);
	return (m + n);
}


//returns 1 : CH = 1 ; init failed
//returns 0 : CH = 0 ; init success
uint8_t ds1307_init(void) {

	//1. Initialize the I2C pins
	ds1307_i2c_pin_config();

	//2. Initialize the I2C peripheral
	ds1307_i2c_config();

	//3. Enable the I2C peripheral
	I2C_PeripheralControl(DS1307_I2C, ENABLE);

	//4. Make clock halt = 0
	ds1307_write(0x00, DS1307_ADDR_SEC);

	//5. Read clock halt bit
	uint8_t clock_state = ds1307_read(DS1307_ADDR_SEC);

	return ((clock_state >> 7) & 0x1);
}


void ds1307_set_current_time(RTC_time_t *rtc_time) {

	uint8_t seconds, hrs;

	seconds = binary_to_bcd(rtc_time->seconds);
	seconds &= ~( 1 << 7);
	ds1307_write(seconds, DS1307_ADDR_SEC);

	ds1307_write(binary_to_bcd(rtc_time->minutes), DS1307_ADDR_MIN);

	hrs = binary_to_bcd(rtc_time->hours);

	if(rtc_time->time_format == TIME_FORMAT_24HRS) {
		hrs &= ~(1 << 6);
	} else {
		hrs |= (1 << 6);
		hrs = (rtc_time->time_format == TIME_FORMAT_12HRS_PM) ? hrs | (1 << 5) : hrs & ~(1 << 5);
	}

	ds1307_write(hrs, DS1307_ADDR_HRS);
}

void ds1307_set_current_date(RTC_date_t *rtc_date) {

	ds1307_write(binary_to_bcd(rtc_date->date), DS1307_ADDR_DATE);
	ds1307_write(binary_to_bcd(rtc_date->month), DS1307_ADDR_MONTH);
	ds1307_write(binary_to_bcd(rtc_date->year), DS1307_ADDR_YEAR);
	ds1307_write(binary_to_bcd(rtc_date->day), DS1307_ADDR_DAY);
}

void ds1307_get_current_time(RTC_time_t *rtc_time) {

	uint8_t seconds, hrs;

	seconds = ds1307_read(DS1307_ADDR_SEC);
	seconds &= ~( 1 << 7);
	rtc_time->seconds = bcd_to_binary(seconds);

	rtc_time->minutes = bcd_to_binary(ds1307_read(DS1307_ADDR_MIN));

	hrs = ds1307_read(DS1307_ADDR_HRS);

	if(hrs & ( 1 << 6)) {
		//12 hr format
		rtc_time->time_format = !((hrs & (1 << 5)) == 0) ;
		hrs &= ~(0x3 << 5); //Clear 6 and 5
	} else {
		//24 hr format
		rtc_time->time_format = TIME_FORMAT_24HRS;
	}

	rtc_time->hours = bcd_to_binary(hrs);
}

void ds1307_get_current_date(RTC_date_t *rtc_date) {

	rtc_date->day = bcd_to_binary(ds1307_read(DS1307_ADDR_DAY));
	rtc_date->date = bcd_to_binary(ds1307_read(DS1307_ADDR_DATE));
	rtc_date->month = bcd_to_binary(ds1307_read(DS1307_ADDR_MONTH));
	rtc_date->year = bcd_to_binary(ds1307_read(DS1307_ADDR_YEAR));
}

/****************************************************************************************/
									ds1307.h
/****************************************************************************************/	
#ifndef DS1307_H_
#define DS1307_H_

#include "stm32f446xx.h"

/* Application configurable items */
#define DS1307_I2C  			I2C1
#define DS1307_I2C_GPIO_PORT    GPIOB
#define DS1307_I2C_SDA_PIN 		GPIO_PIN_NO_7
#define DS1307_I2C_SCL_PIN 		GPIO_PIN_NO_6
#define DS1307_I2C_SPEED 		I2C_SCL_Speed_SM
#define DS1307_I2C_PUPD			GPIO_PIN_PU

/* Register addresses */
#define DS1307_ADDR_SEC 		0x00
#define DS1307_ADDR_MIN 		0x01
#define DS1307_ADDR_HRS			0x02
#define DS1307_ADDR_DAY			0x03
#define DS1307_ADDR_DATE		0x04
#define DS1307_ADDR_MONTH		0x05
#define DS1307_ADDR_YEAR		0x06


#define TIME_FORMAT_12HRS_AM 	0
#define TIME_FORMAT_12HRS_PM 	1
#define TIME_FORMAT_24HRS 		2

#define DS1307_I2C_ADDRESS      0x68


#define SUNDAY  	1
#define MONDAY  	2
#define TUESDAY  	3
#define WEDNESDAY   4
#define THURSDAY  	5
#define FRIDAY  	6
#define SATURDAY  	7


typedef struct {
	uint8_t date;
	uint8_t month;
	uint8_t year;
	uint8_t day;
} RTC_date_t;


typedef struct {
	uint8_t seconds;
	uint8_t minutes;
	uint8_t hours;
	uint8_t time_format;
} RTC_time_t;



/* Function prototypes */

uint8_t ds1307_init(void);

void ds1307_set_current_time(RTC_time_t *);
void ds1307_get_current_time(RTC_time_t *);

void ds1307_set_current_date(RTC_date_t *);
void ds1307_get_current_date(RTC_date_t *);

#endif /* DS1307_H_ */

/****************************************************************************************/
									lcd.c
/****************************************************************************************/	
#include "lcd.h"

static void write_4_bits(uint8_t value);
static void lcd_enable(void);
static void mdelay(uint32_t cnt);
static void udelay(uint32_t cnt);

/* writes 4 bits of data/command on to D4,D5,D6,D7 lines */
static void write_4_bits(uint8_t value) {
	GPIO_WriteToOutputPin(LCD_GPIO_PORT,LCD_GPIO_D4, ((value >> 0) & 0x1) );
	GPIO_WriteToOutputPin(LCD_GPIO_PORT,LCD_GPIO_D5, ((value >> 1) & 0x1) );
	GPIO_WriteToOutputPin(LCD_GPIO_PORT,LCD_GPIO_D6, ((value >> 2) & 0x1) );
	GPIO_WriteToOutputPin(LCD_GPIO_PORT,LCD_GPIO_D7, ((value >> 3) & 0x1) );

	lcd_enable();
}

static void lcd_enable(void) {

	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_EN, GPIO_PIN_SET);
	udelay(10);
	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_EN, GPIO_PIN_RESET);
	udelay(100);/* execution time > 37 micro seconds */
}

static void mdelay(uint32_t cnt) {

	for(uint32_t i = 0 ; i < (cnt * 1000); i++);
}

static void udelay(uint32_t cnt) {

	for(uint32_t i = 0 ; i < (cnt * 1); i++);
}


void lcd_send_command(uint8_t cmd) {
	/* RS = 0 for LCD command */
	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_RS, GPIO_PIN_RESET);

	/*R/nW = 0, for write */
	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_RW, GPIO_PIN_RESET);

	write_4_bits(cmd >> 4);
	write_4_bits(cmd & 0x0F);
}

/*
 * This function sends a character to the LCD
 * Here we used 4 bit parallel data transmission.
 * First higher nibble of the data will be sent on to the data lines D4,D5,D6,D7
 * Then lower nibble of the data will be set on to the data lines D4,D5,D6,D7
 */
void lcd_print_char(uint8_t data) {
	/* RS = 1 for LCD user data */
	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_RS, GPIO_PIN_SET);

	/*R/nW = 0, for write */
	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_RW, GPIO_PIN_RESET);

	write_4_bits(data >> 4);   /* Higher nibble */
	write_4_bits(data & 0x0F); /* Lower nibble */
}


void lcd_print_string(char *message) {

	do {
	  lcd_print_char((uint8_t)*message++);
	} while (*message != '\0');
}


void lcd_init(void) {
	//Configure the gpio pins which are used for lcd connections

	GPIO_Handle_t lcd_signal;

	lcd_signal.pGPIOx = LCD_GPIO_PORT;
	lcd_signal.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	lcd_signal.GPIO_PinConfig.GPIO_PinNumber = LCD_GPIO_RS;
	lcd_signal.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	lcd_signal.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
	lcd_signal.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIO_Init(&lcd_signal);

	lcd_signal.GPIO_PinConfig.GPIO_PinNumber = LCD_GPIO_RW;
	GPIO_Init(&lcd_signal);

	lcd_signal.GPIO_PinConfig.GPIO_PinNumber = LCD_GPIO_EN;
	GPIO_Init(&lcd_signal);

	lcd_signal.GPIO_PinConfig.GPIO_PinNumber = LCD_GPIO_D4;
	GPIO_Init(&lcd_signal);

	lcd_signal.GPIO_PinConfig.GPIO_PinNumber = LCD_GPIO_D5;
	GPIO_Init(&lcd_signal);

	lcd_signal.GPIO_PinConfig.GPIO_PinNumber = LCD_GPIO_D6;
	GPIO_Init(&lcd_signal);

	lcd_signal.GPIO_PinConfig.GPIO_PinNumber = LCD_GPIO_D7;
	GPIO_Init(&lcd_signal);

	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_RS, GPIO_PIN_RESET);
	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_RW, GPIO_PIN_RESET);
	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_EN, GPIO_PIN_RESET);
	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_D4, GPIO_PIN_RESET);
	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_D5, GPIO_PIN_RESET);
	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_D6, GPIO_PIN_RESET);
	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_D7, GPIO_PIN_RESET);

	//2. Do the LCD initialization

	mdelay(40);

	/* RS = 0 , For LCD command */
	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_RS, GPIO_PIN_RESET);

	/* RnW = 0, Writing to LCD */
	GPIO_WriteToOutputPin(LCD_GPIO_PORT, LCD_GPIO_RW, GPIO_PIN_RESET);

	write_4_bits(0x3);

	mdelay(5);

	write_4_bits(0x3);

	udelay(150);

	write_4_bits(0x3);
	write_4_bits(0x2);

	//function set command
	lcd_send_command(LCD_CMD_4DL_2N_5X8F);

	//display ON and cursor ON
	lcd_send_command(LCD_CMD_DON_CURON);

	lcd_display_clear();

	//entry mode set
	lcd_send_command(LCD_CMD_INCADD);
}

void lcd_display_clear(void) {
	//Display clear
	lcd_send_command(LCD_CMD_DIS_CLEAR);

	/*
	 * check page number 24 of datasheet
	 * display clear command execution wait time is around 2ms
	 */

	mdelay(2);
}


/*Cursor returns to home position */
void lcd_display_return_home(void) {
	lcd_send_command(LCD_CMD_DIS_RETURN_HOME);
	/*
	 * check page number 24 of datasheet.
	 * return home command execution wait time is around 2ms
	 */
	mdelay(2);
}


/**
  *   Set Lcd to a specified location given by row and column information
  *   Row Number (1 to 2)
  *   Column Number (1 to 16) Assuming a 2 X 16 characters display
  */
void lcd_set_cursor(uint8_t row, uint8_t column) {

	column--;

	switch(row) {
		case 1:
		  /* Set cursor to 1st row address and add index*/
		  lcd_send_command((column |= 0x80));
		  break;

		case 2:
		  /* Set cursor to 2nd row address and add index*/
			lcd_send_command((column |= 0xC0));
		  break;

		default:
		  break;
	}
}

/****************************************************************************************/
									lcd.h
/****************************************************************************************/	
#ifndef LCD_H_
#define LCD_H_

#include "stm32f446xx.h"

/* bsp exposed apis */
void lcd_init(void);
void lcd_send_command(uint8_t cmd);
void lcd_print_char(uint8_t data);
void lcd_display_clear(void);
void lcd_display_return_home(void);
void lcd_print_string(char*);
void lcd_set_cursor(uint8_t row, uint8_t column);

/* Application configurable items */

#define LCD_GPIO_PORT  GPIOA
#define LCD_GPIO_RS	   GPIO_PIN_NO_0
#define LCD_GPIO_RW	   GPIO_PIN_NO_1
#define LCD_GPIO_EN	   GPIO_PIN_NO_2
#define LCD_GPIO_D4	   GPIO_PIN_NO_3
#define LCD_GPIO_D5	   GPIO_PIN_NO_4
#define LCD_GPIO_D6	   GPIO_PIN_NO_5
#define LCD_GPIO_D7	   GPIO_PIN_NO_6


/* LCD commands */
#define LCD_CMD_4DL_2N_5X8F  		0x28
#define LCD_CMD_DON_CURON    		0x0E
#define LCD_CMD_INCADD       		0x06
#define LCD_CMD_DIS_CLEAR    		0X01
#define LCD_CMD_DIS_RETURN_HOME  	0x02


#endif /* LCD_H_ */

////////////////////////////// DRIVERS ////////////////////////

/****************************************************************************************/
							stm32f446xx_gpio_driver.h
/****************************************************************************************/	
/*
 * stm32f446xx_gpio_driver.h
 *
 *  Created on: Jan 24, 2021
 *      Author: Oliver
 */

#ifndef INC_STM32F446XX_GPIO_DRIVER_H_
#define INC_STM32F446XX_GPIO_DRIVER_H_

#include "stm32f446xx.h"


/* Configuration Structure for a GPIO Pin */
typedef struct {
	uint8_t GPIO_PinNumber;				/* possible values from @GPIO_PIN_NUMBERS */
	uint8_t GPIO_PinMode;				/* possible values from @GPIO_PIN_MODES */
	uint8_t GPIO_PinSpeed;				/* possible values from @GPIO_PIN_SPEED */
	uint8_t GPIO_PinPuPdControl;		/* possible values from @GPIO_PIN_PUPD */
	uint8_t GPIO_PinOPType;				/* possible values from @GPIO_PIN_OPTYPE */
	uint8_t GPIO_PinAltFunMode;			/* possible values from @GPIO_PIN_AFM */
} GPIO_PinConfig_t;


/* Handle Structure for a GPIO Pin */
typedef struct {
	GPIO_RegDef_t *pGPIOx; 				/* Holds the base address of the GPIO port belonging to the pin */
	GPIO_PinConfig_t GPIO_PinConfig; 	/* Holds GPIO pin configuration settings */
} GPIO_Handle_t;


/* GPIO Pin Numbers: @GPIO_PIN_NUMBERS */
#define GPIO_PIN_NO_0		0
#define GPIO_PIN_NO_1		1
#define GPIO_PIN_NO_2		2
#define GPIO_PIN_NO_3		3
#define GPIO_PIN_NO_4		4
#define GPIO_PIN_NO_5		5
#define GPIO_PIN_NO_6		6
#define GPIO_PIN_NO_7		7
#define GPIO_PIN_NO_8		8
#define GPIO_PIN_NO_9		9
#define GPIO_PIN_NO_10		10
#define GPIO_PIN_NO_11		11
#define GPIO_PIN_NO_12		12
#define GPIO_PIN_NO_13		13
#define GPIO_PIN_NO_14		14
#define GPIO_PIN_NO_15		15


/* GPIO Pin Modes: @GPIO_PIN_MODES */
	//non-interrupt modes
#define GPIO_MODE_IN 		0			/* Input */
#define GPIO_MODE_OUT 		1			/* Output */
#define GPIO_MODE_ALTFN 	2			/* Alternate Function */
#define GPIO_MODE_ANALOG	3			/* Analog Input */
	//interrupt modes
#define GPIO_MODE_IN_FT		4			/* Input Falling Edge Trigger */
#define GPIO_MODE_IN_RT		5			/* Input Rising Edge Trigger */
#define GPIO_MODE_IN_RFT	6			/* Input Rising or Falling Edge Trigger */


/* GPIO Pin Output Speeds: @GPIO_PIN_SPEED */
#define GPIO_SPEED_LOW	 	0			/* Refer to the product datasheets for the values of OSPEEDRy bits versus VDD range and external load.*/
#define GPIO_SPEED_MEDIUM 	1			/* Refer to the product datasheets for the values of OSPEEDRy bits versus VDD range and external load.*/
#define GPIO_SPEED_FAST	 	2			/* Refer to the product datasheets for the values of OSPEEDRy bits versus VDD range and external load.*/
#define GPIO_SPEED_HIGH	 	3			/* Refer to the product datasheets for the values of OSPEEDRy bits versus VDD range and external load.*/


/* GPIO Pin Pull-up and Pull-down Config: @GPIO_PIN_PUPD */
#define GPIO_NO_PUPD		0			/* No Pull-up or Pull-down */
#define GPIO_PIN_PU			0			/* Pull-Up */
#define GPIO_PIN_PD			0			/* Pull-down */


/* GPIO Pin Output Types: @GPIO_PIN_OPTYPE */
#define GPIO_OP_TYPE_PP		0			/* Output Push-Pull (reset-state) */
#define GPIO_OP_TYPE_OD		1			/* Output Open-Drain */

/* GPIO Pin Alternate Function Modes: @GPIO_PIN_AFM */




/*
 * GPIO Driver API requirements should be:
 * . GPIO Initialization
 * . Enable/Disable GPIO port clock
 * . Read from a GPIO pin
 * . Write to a GPIO pin
 * . Configure alternate functionality
 * . Interrupt Handling
 */

/***********************************************************************************
 * 							APIs supported by this driver
 * 			For more info about the APIs, check the function definitions
 **********************************************************************************/

/* Peripheral Clock Setup */
void GPIO_PClockControl(GPIO_RegDef_t *pGPIOx, uint8_t State);

/* Initialize and Deinitialize */
void GPIO_Init(GPIO_Handle_t *pGPIOHandle);
void GPIO_DeInit(GPIO_RegDef_t *pGPIOx);

/* Data Read and Write */
uint8_t GPIO_ReadFromInputPin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber);
uint16_t GPIO_ReadFromInputPort(GPIO_RegDef_t *pGPIOx);
void GPIO_WriteToOutputPin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber, uint8_t Value);
void GPIO_WriteToOutputPort(GPIO_RegDef_t *pGPIOx, uint16_t Value);
void GPIO_ToggleOutputPin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber);

/* IRQ Configuration, Priority and ISR Handling */
void GPIO_IRQInterruptConfig(uint8_t IRQNumber, uint8_t State);
void GPIO_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority);
void GPIO_IRQHandling(uint8_t PinNumber);



#endif /* INC_STM32F446XX_GPIO_DRIVER_H_ */

/****************************************************************************************/
							stm32f446xx_i2c_driver.h
/****************************************************************************************/
/*
 * stm32f446xx_i2c_driver.h
 *
 *  Created on: Feb 19, 2021
 *      Author: Oliver
 */

#ifndef INC_STM32F446XX_I2C_DRIVER_H_
#define INC_STM32F446XX_I2C_DRIVER_H_

#include "stm32f446xx.h"

/* Configuration Structure for I2Cx Peripheral */
typedef struct {
	uint32_t I2C_SCLSpeed;				/* possible values from @I2C_SCLSpeed */
	uint8_t  I2C_DeviceAddress;			/* possible values from @I2C_DeviceAddress */
	uint8_t  I2C_AckControl;			/* possible values from @I2C_ACKControl */
	uint16_t I2C_FMDutyCycle;			/* possible values from @I2C_FMDutyCycle */
} I2C_Config_t;

/* Handle Structure for I2Cx Peripheral */
typedef struct {
	I2C_RegDef_t 	*pI2Cx; 				/* Holds the base address of the I2Cx peripheral */
	I2C_Config_t 	I2C_Config; 			/* Holds I2Cx peripheral configuration settings */
	uint8_t 		*pTxBuffer; 			/* To store the application Tx buffer address */
	uint8_t 		*pRxBuffer; 			/* To store the application Rx buffer address */
	uint32_t 		TxLen; 					/* Tx Length */
	uint32_t 		RxLen; 					/* Rx Length */
	uint8_t 		TxRxState; 				/* possible values from @I2C_ApplicationStates */
	uint8_t 		DevAddr; 				/* To store slave/device address */
	uint32_t 		RxSize; 				/* To store Rx size */
	uint8_t 		SR; 					/* To store Repeated Start state */
} I2C_Handle_t;

/* I2C Application States: @I2C_ApplicationStates */
#define I2C_READY					0
#define I2C_BUSY_IN_RX				1
#define I2C_BUSY_IN_TX				2

/* I2C Serial Clock Speeds: @I2C_SCLSpeed */
#define I2C_SCL_Speed_SM			100000
#define I2C_SCL_Speed_FM2K			200000
#define I2C_SCL_Speed_FM4K			400000

/* @I2C_DeviceAddress */

/* @I2C_ACKControl */
#define I2C_ACK_DISABLE       		0
#define I2C_ACK_ENABLE        		1

/* @I2C_FMDutyCycle */
#define I2C_FM_DUTY_2        		0
#define I2C_FM_DUTY_16_9     		1

/* I2C Related Status Flag Definitions */
#define I2C_FLAG_SB					(1 << I2C_SR1_SB)
#define I2C_FLAG_ADDR				(1 << I2C_SR1_ADDR)
#define I2C_FLAG_BTF				(1 << I2C_SR1_BTF)
#define I2C_FLAG_ADD10				(1 << I2C_SR1_ADD10)
#define I2C_FLAG_STOPF				(1 << I2C_SR1_STOPF)
#define I2C_FLAG_RXNE				(1 << I2C_SR1_RXNE)
#define I2C_FLAG_TXE				(1 << I2C_SR1_TXE)
#define I2C_FLAG_BERR				(1 << I2C_SR1_BERR)
#define I2C_FLAG_ARLO				(1 << I2C_SR1_ARLO)
#define I2C_FLAG_AF					(1 << I2C_SR1_AF)
#define I2C_FLAG_OVR				(1 << I2C_SR1_OVR)
#define I2C_FLAG_PECERR				(1 << I2C_SR1_PECERR)
#define I2C_FLAG_TIMEOUT			(1 << I2C_SR1_TIMEOUT)
#define I2C_FLAG_SMBALERT			(1 << I2C_SR1_SMBALERT)

#define I2C_FLAG_MSL				(1 << I2C_SR2_MSL)
#define I2C_FLAG_BUSY				(1 << I2C_SR2_BUSY)
#define I2C_FLAG_TRA				(1 << I2C_SR2_TRA)
#define I2C_FLAG_GENCALL			(1 << I2C_SR2_GENCALL)
#define I2C_FLAG_SMBDEFAULT			(1 << I2C_SR2_SMBDEFAULT)
#define I2C_FLAG_SMBHOST			(1 << I2C_SR2_SMBHOST)
#define I2C_FLAG_DUALF				(1 << I2C_SR2_DUALF)
#define I2C_FLAG_PEC				(1 << I2C_SR2_PEC70)

#define I2C_ENABLE_SR				SET
#define I2C_DISABLE_SR				RESET

/* I2C Application Events Macro */
#define I2C_EV_TX_CMPLT				0
#define I2C_EV_RX_CMPLT				1
#define I2C_EV_STOP					2
#define I2C_ERROR_BERR				3
#define I2C_ERROR_ARLO				4
#define I2C_ERROR_AF				5
#define I2C_ERROR_OVR				6
#define I2C_ERROR_TIMEOUT			7
#define I2C_EV_DATA_REQ				8
#define I2C_EV_DATA_RCV				9

/***********************************************************************************
 * 							APIs supported by this driver
 * 			For more info about the APIs, check the function definitions
 **********************************************************************************/

/* Peripheral Clock Setup */
void I2C_PClockControl(I2C_RegDef_t *pI2Cx, uint8_t State);

/* Initialization and Deinitialization */
void I2C_Init(I2C_Handle_t *pI2CHandle);
void I2C_DeInit(I2C_RegDef_t *pI2Cx);

/* Data Send and Receive */
void I2C_MasterSendData(I2C_Handle_t *pI2CHandle, uint8_t *pTxBuffer, uint32_t Len, uint8_t SlaveAddress, uint8_t SR);
void I2C_MasterReceiveData(I2C_Handle_t *pI2CHandle, uint8_t *pRxBuffer, uint8_t Len, uint8_t SlaveAddress, uint8_t SR);

uint8_t I2C_MasterSendDataIT(I2C_Handle_t *pI2CHandle, uint8_t *pTxBuffer, uint32_t Len, uint8_t SlaveAddress, uint8_t SR);
uint8_t I2C_MasterReceiveDataIT(I2C_Handle_t *pI2CHandle, uint8_t *pRxBuffer, uint8_t Len, uint8_t SlaveAddress, uint8_t SR);

void I2C_CloseTransmission(I2C_Handle_t *pI2CHandle);
void I2C_CloseReception(I2C_Handle_t *pI2CHandle);

void I2C_SlaveSendData(I2C_RegDef_t *pI2Cx, uint8_t data);
uint8_t I2C_SlaveReceiveData(I2C_RegDef_t *pI2Cx);

/* IRQ Configuration, Priority and ISR Handling */
void I2C_IRQInterruptConfig(uint8_t IRQNumber, uint8_t State);
void I2C_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority);
void I2C_EV_IRQHandling(I2C_Handle_t *pI2CHandle);
void I2C_ER_IRQHandling(I2C_Handle_t *pI2CHandle);

/* Other Peripheral Control APIs */
void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx, uint8_t State);
uint8_t I2C_GetFlagStatus(I2C_RegDef_t *pI2Cx, uint32_t FlagName);
void I2C_ManageAcking(I2C_RegDef_t *pI2Cx, uint8_t State);
void I2C_GenerateStopCondition(I2C_RegDef_t *pI2Cx);
void I2C_SlaveEnableDisableCallbackEvents(I2C_RegDef_t *pI2Cx, uint8_t State);

/* Application Callback */
void I2C_ApplicationEventCallback(I2C_Handle_t *pI2CHandle, uint8_t AppEv);

#endif /* INC_STM32F446XX_I2C_DRIVER_H_ */


/****************************************************************************************/
							stm32f446xx_rcc_driver.h
/****************************************************************************************/
/*
 * stm32f446xx_rcc_driver.c
 *
 *  Created on: Mar 10, 2021
 *      Author: Oliver
 */

#include "stm32f446xx_rcc_driver.h"

uint16_t AHB_PreScaler[8] = {2,4,8,16,64,128,256,512};
uint8_t APB1_PreScaler[4] = {2,4,8,16};



/*********************************************************************
 * @fn      		  - RCC_GetPCLK1Value
 *
 * @brief             - Returns the APB1 clock value
 *
 * @param[in]         - N/A
 *
 * @return            - APB1 clock value
 *
 * @Note              -
 */
uint32_t RCC_GetPCLK1Value(void) {

	uint32_t pclk1, SystemClk;
	uint8_t clksrc, temp, ahbp, apb1p;

	clksrc = ((RCC->CFGR >> 2) & 0x3);

	if(clksrc == 0) {
		SystemClk = 16000000;
	} else if(clksrc == 1) {
		SystemClk = 8000000;
	} else if(clksrc == 2) {
		SystemClk = RCC_GetPLLOutputClock();
	}

	//for AHB
	temp = ((RCC->CFGR >> 4) & 0xF);

	if(temp < 8) {
		ahbp = 1;
	} else {
		ahbp = AHB_PreScaler[temp - 8];
	}

	//for APB1
	temp = ((RCC->CFGR >> 10) & 0x7);

	if(temp < 4) {
		apb1p = 1;
	} else {
		apb1p = APB1_PreScaler[temp - 4];
	}

	pclk1 = ((SystemClk / ahbp) / apb1p);

	return pclk1;
}

/*********************************************************************
 * @fn      		  - RCC_GetPCLK2Value
 *
 * @brief             - Returns the APB2 clock value
 *
 * @param[in]         - N/A
 *
 * @return            - APB2 clock value
 *
 * @Note              -
 */
uint32_t RCC_GetPCLK2Value(void) {

	uint32_t SystemClock = 0, tmp, pclk2;
	uint8_t clk_src = (RCC->CFGR >> 2) & 0x3;

	uint8_t ahbp, apb2p;

	if(clk_src == 0) {
		SystemClock = 16000000;
	} else {
		SystemClock = 8000000;
	}

	tmp = (RCC->CFGR >> 4) & 0xF;
	if(tmp < 0x08) {
		ahbp = 1;
	} else {
		ahbp = AHB_PreScaler[tmp - 8];
	}

	tmp = (RCC->CFGR >> 13) & 0x7;
	if(tmp < 0x04) {
		apb2p = 1;
	} else {
		apb2p = APB1_PreScaler[tmp - 4];
	}
	pclk2 = ((SystemClock / ahbp) / apb2p);

	return pclk2;
}

/*********************************************************************
 * @fn      		  - RCC_GetPLLOutputClock
 *
 * @brief             - Returns the PLL Output clock value
 *
 * @param[in]         - N/A
 *
 * @return            - PLL Output clock value
 *
 * @Note              - <WORK IN PROGRESS>
 */
uint32_t RCC_GetPLLOutputClock(void) {

	return 0;
}	

/****************************************************************************************/
							stm32f446xx_spi_driver.h
/****************************************************************************************/	
/*
 * stm32f446xx_spi_driver.h
 *
 *  Created on: Feb 5, 2021
 *      Author: Oliver
 */

#ifndef INC_STM32F446XX_SPI_DRIVER_H_
#define INC_STM32F446XX_SPI_DRIVER_H_

#include "stm32f446xx.h"

/* Configuration Structure for SPIx Peripheral */
typedef struct {
	uint8_t SPI_DeviceMode;		/* possible values from @SPI_DEVICEMODE */
	uint8_t SPI_BusConfig;		/* possible values from @SPI_BUSCONFIG */
	uint8_t SPI_SclkSpeed;		/* possible values from @SPI_SCLKSPEED */
	uint8_t SPI_DFF;			/* possible values from @SPI_DFF */
	uint8_t SPI_CPOL;			/* possible values from @SPI_CPOL */
	uint8_t SPI_CPHA;			/* possible values from @SPI_CPHA */
	uint8_t SPI_SSM;			/* possible values from @SPI_SSM */
} SPI_Config_t;

/* Handle Structure for SPIx Peripheral */
typedef struct {
	SPI_RegDef_t *pSPIx;		/* This holds the base address of SPIx (x:0,1,2) peripheral */
	SPI_Config_t SPIConfig;		/* This contains the SPI peripheral configuration options */
	uint8_t	*pTxBuffer;			/* To store the application Tx buffer address */
	uint8_t	*pRxBuffer;			/* To store the application Rx buffer address */
	uint32_t TxLen;				/* To store the Tx length */
	uint32_t RxLen;				/* To store the Rx length */
	uint8_t	TxState;			/* possible values from @SPI_ApplicationStates */
	uint8_t	RxState;			/* possible values from @SPI_ApplicationStates */
} SPI_Handle_t;

/* SPI Application States: @SPI_ApplicationStates */
#define SPI_READY							0
#define SPI_BUSY_IN_RX						1
#define SPI_BUSY_IN_TX						2

/* Possible SPI Application Events */
#define SPI_EVENT_TX_CMPLT					1
#define SPI_EVENT_RX_CMPLT					2
#define SPI_EVENT_OVR_ERR					3
#define SPI_EVENT_CRC_ERR					4

/* SPI Device Modes: @SPI_DEVICEMODE */
#define SPI_DEVICE_MODE_MASTER				1
#define SPI_DEVICE_MODE_SLAVE				0

/* SPI Bus Configurations: @SPI_BUSCONFIG */
#define SPI_BUS_CONFIG_FD					1		//full duplex
#define SPI_BUS_CONFIG_HD					2		//half duplex
#define SPI_BUS_CONFIG_SIMPLEX_RXONLY		3		//simplex receive only

/* SPI Serial Clock Speed: @SPI_SCLKSPEED */
#define SPI_SCLK_SPEED_DIV2					0
#define SPI_SCLK_SPEED_DIV4					1
#define SPI_SCLK_SPEED_DIV8					2
#define SPI_SCLK_SPEED_DIV16				3
#define SPI_SCLK_SPEED_DIV32				4
#define SPI_SCLK_SPEED_DIV64				5
#define SPI_SCLK_SPEED_DIV128				6
#define SPI_SCLK_SPEED_DIV256				7

/* SPI Data Frame Format: @SPI_DFF */
#define SPI_DFF_8BITS						0
#define SPI_DFF_16BITS						1

/* SPI Clock Polarity: @SPI_CPOL */
#define SPI_CPOL_LOW						0		//Low clock position when idle
#define SPI_CPOL_HIGH						1		//High clock position when idle

/* SPI Clock Phase: @SPI_CPHA */
#define SPI_CPHA_LOW						0		//Data capture begins on first clock edge
#define SPI_CPHA_HIGH						1		//Data capture begins on second clock edge

/* SPI Software Slave Management: @SPI_SSM */
	//When SSM bit is set, NSS Pin Input is replaced with value of SSI bit.
#define SPI_SSM_DI							0		//Software slave management disabled
#define SPI_SSM_EN							1		//Software slave management enabled

/* SPI Related Status Flag Definitions */
#define SPI_FLAG_RXNE						(1 << SPI_SR_RXNE)
#define SPI_FLAG_TXE						(1 << SPI_SR_TXE)
#define SPI_FLAG_CHSIDE						(1 << SPI_SR_CHSIDE)
#define SPI_FLAG_UDR						(1 << SPI_SR_UDR)
#define SPI_FLAG_CRCERR						(1 << SPI_SR_CRCERR)
#define SPI_FLAG_MODF						(1 << SPI_SR_MODF)
#define SPI_FLAG_OVR						(1 << SPI_SR_OVR)
#define SPI_FLAG_BUSY						(1 << SPI_SR_BSY)
#define SPI_FLAG_FRE						(1 << SPI_SR_FRE)

/***********************************************************************************
 * 							APIs supported by this driver
 * 			For more info about the APIs, check the function definitions
 **********************************************************************************/

/* Peripheral Clock Setup */
void SPI_PClockControl(SPI_RegDef_t *pSPIx, uint8_t State);

/* Initialization and Deinitialization */
void SPI_Init(SPI_Handle_t *pSPIHandle);
void SPI_DeInit(SPI_RegDef_t *pSPIx);

/* Data Send and Receive */
void SPI_SendData(SPI_RegDef_t *pSPIx, uint8_t *pTxBuffer, uint32_t Len);
void SPI_ReceiveData(SPI_RegDef_t *pSPIx, uint8_t *pRxBuffer, uint32_t Len);
uint8_t SPI_SendDataIT(SPI_Handle_t *pSPIHandle, uint8_t *pTxBuffer, uint32_t Len);
uint8_t SPI_ReceiveDataIT(SPI_Handle_t *pSPIHandle, uint8_t *pRxBuffer, uint32_t Len);

/* IRQ Configuration, Priority and ISR Handling */
void SPI_IRQInterruptConfig(uint8_t IRQNumber, uint8_t State);
void SPI_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority);
void SPI_IRQHandling(SPI_Handle_t *pHandle);

/* Other Peripheral Control APIs */
void SPI_PeripheralControl(SPI_RegDef_t *pSPIx, uint8_t State);
void SPI_SSIConfig(SPI_RegDef_t *pSPIx, uint8_t State);
void SPI_SSOEConfig(SPI_RegDef_t *pSPIx, uint8_t State);
uint8_t SPI_GetFlagStatus(SPI_RegDef_t *pSPIx, uint32_t FlagName);
void SPI_ClearOVRFlag(SPI_RegDef_t *pSPIx);
void SPI_CloseTransmission(SPI_Handle_t *pSPIHandle);
void SPI_CloseReception(SPI_Handle_t *pSPIHandle);

/* Application Callback */
void SPI_ApplicationEventCallback(SPI_Handle_t *pSPIHandle, uint8_t AppEv);

#endif /* INC_STM32F446XX_SPI_DRIVER_H_ */

/****************************************************************************************/
							stm32f446xx_usart_driver.h
/****************************************************************************************/	
/*
 * stm32f446xx_usart_driver.h
 *
 *  Created on: Mar 12, 2021
 *      Author: Oliver
 */

#ifndef INC_STM32F446XX_USART_DRIVER_H_
#define INC_STM32F446XX_USART_DRIVER_H_

#include "stm32f446xx.h"

/* Configuration Structure for USARTx Peripheral */
typedef struct {
	uint8_t  USART_Mode;					/* possible values from @USART_Mode */
	uint32_t USART_Baud;					/* possible values from @USART_Baud */
	uint8_t  USART_NoOfStopBits;			/* possible values from @USART_NoOfStopBits */
	uint8_t  USART_WordLength;				/* possible values from @USART_WordLength */
	uint8_t  USART_ParityControl;			/* possible values from @USART_ParityControl */
	uint8_t  USART_HWFlowControl;			/* possible values from @USART_HWFlowControl */
} USART_Config_t;

/* Handle Structure for USARTx Peripheral */
typedef struct {
	USART_RegDef_t *pUSARTx; 				/* Holds the base address of the USARTx peripheral */
	USART_Config_t USART_Config; 			/* Holds USARTx peripheral configuration settings */
	uint8_t  *pTxBuffer;					/* To store the application Tx buffer address */
	uint8_t  *pRxBuffer;					/* To store the application Rx buffer address */
	uint32_t TxLen;							/* To store the Tx length */
	uint32_t RxLen;							/* To store the Rx length */
	uint8_t  TxBusyState;					/* possible values from @USART_ApplicationStates */
	uint8_t  RxBusyState;					/* possible values from @USART_ApplicationStates */
} USART_Handle_t;


/* @USART_Mode */
#define USART_MODE_ONLY_TX 	0
#define USART_MODE_ONLY_RX 	1
#define USART_MODE_TXRX  	2

/* @USART_Baud */
#define USART_STD_BAUD_1200			1200
#define USART_STD_BAUD_2400			2400
#define USART_STD_BAUD_9600			9600
#define USART_STD_BAUD_19200 		19200
#define USART_STD_BAUD_38400 		38400
#define USART_STD_BAUD_57600 		57600
#define USART_STD_BAUD_115200 		115200
#define USART_STD_BAUD_230400 		230400
#define USART_STD_BAUD_460800 		460800
#define USART_STD_BAUD_921600 		921600
#define USART_STD_BAUD_2M 			2000000
#define USART_STD_BAUD_3M 			3000000


/* @USART_NoOfStopBits */
#define USART_STOPBITS_1     		0
#define USART_STOPBITS_0_5   		1
#define USART_STOPBITS_2     		2
#define USART_STOPBITS_1_5   		3

/* @USART_WordLength */
#define USART_WORDLEN_8BITS 		0
#define USART_WORDLEN_9BITS 		1

/* @USART_ParityControl */
#define USART_PARITY_EN_ODD   		2
#define USART_PARITY_EN_EVEN  		1
#define USART_PARITY_DISABLE   		0

/* Hardware Flow Control : @USART_HWFlowControl */
#define USART_HW_FLOW_CTRL_NONE    	0
#define USART_HW_FLOW_CTRL_CTS    	1
#define USART_HW_FLOW_CTRL_RTS    	2
#define USART_HW_FLOW_CTRL_CTS_RTS	3

/* USART Related Status Flag Definitions */
#define USART_FLAG_PE				(1 << USART_SR_PE)
#define USART_FLAG_FE				(1 << USART_SR_FE)
#define USART_FLAG_NF				(1 << USART_SR_NF)
#define USART_FLAG_ORE				(1 << USART_SR_ORE)
#define USART_FLAG_IDLE				(1 << USART_SR_IDLE)
#define USART_FLAG_RXNE				(1 << USART_SR_RXNE)
#define USART_FLAG_TC				(1 << USART_SR_TC)
#define USART_FLAG_TXE				(1 << USART_SR_TXE)
#define USART_FLAG_LBD				(1 << USART_SR_LBD)
#define USART_FLAG_CTS				(1 << USART_SR_CTS)

/* USART Application States : @USART_ApplicationStates */
#define USART_READY					0
#define USART_BUSY_IN_RX			1
#define USART_BUSY_IN_TX			2

/* USART Application Events Macro */
#define USART_EVENT_TX_CMPLT   		0
#define	USART_EVENT_RX_CMPLT   		1
#define	USART_EVENT_IDLE      		2
#define	USART_EVENT_CTS       		3
#define	USART_EVENT_PE        		4
#define	USART_ERR_FE     			5
#define	USART_ERR_NF    	 		6
#define	USART_ERR_ORE    			7

/***********************************************************************************
 * 							APIs supported by this driver
 * 			For more info about the APIs, check the function definitions
 **********************************************************************************/

/* Peripheral Clock Setup */
void USART_PClockControl(USART_RegDef_t *pUSARTx, uint8_t State);

/* Initialization and Deinitialization */
void USART_Init(USART_Handle_t *pUSARTHandle);
void USART_DeInit(USART_RegDef_t *pUSARTx);

/* Data Send and Receive */
void USART_SendData(USART_Handle_t *pUSARTHandle, uint8_t *pTxBuffer, uint32_t Len);
void USART_ReceiveData(USART_Handle_t *pUSARTHandle, uint8_t *pRxBuffer, uint32_t Len);

uint8_t USART_SendDataIT(USART_Handle_t *pUSARTHandle, uint8_t *pTxBuffer, uint32_t Len);
uint8_t USART_ReceiveDataIT(USART_Handle_t *pUSARTHandle, uint8_t *pRxBuffer, uint32_t Len);

/* IRQ Configuration, Priority and ISR Handling */
void USART_IRQInterruptConfig(uint8_t IRQNumber, uint8_t State);
void USART_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority);
void USART_IRQHandling(USART_Handle_t *pUSARTHandle);

/* Other Peripheral Control APIs */
void USART_PeripheralControl(USART_RegDef_t *pUSARTx, uint8_t State);
uint8_t USART_GetFlagStatus(USART_RegDef_t *pUSARTx, uint8_t FlagName);
void USART_ClearFlag(USART_RegDef_t *pUSARTx, uint16_t FlagName);
void USART_SetBaudRate(USART_RegDef_t *pUSARTx, uint32_t BaudRate);

/* Application Callback */
void USART_ApplicationEventCallback(USART_Handle_t *pUSARTHandle, uint8_t AppEv);

#endif /* INC_STM32F446XX_USART_DRIVER_H_ */

/****************************************************************************************/
								stm32f446xx.h
/****************************************************************************************/	
/*
 * stm32f446xx.h
 *
 *  Created on: Jan 20, 2021
 *      Author: Oliver Moore
 */

#ifndef INC_STM32F446XX_H_
#define INC_STM32F446XX_H_

#include <stdint.h>
#include <stddef.h>


#define __vo volatile
#define __weak __attribute__((weak))

/* General Macros */
#define ENABLE 				1
#define DISABLE 			0
#define SET 				ENABLE
#define RESET 				DISABLE
#define GPIO_PIN_SET		SET
#define GPIO_PIN_RESET		RESET
#define FLAG_RESET			RESET
#define FLAG_SET			SET

/**************************** Processor Specific Details ****************************/

/* ARM Cortex Mx Processor NVIC ISERx Register Addresses */
#define NVIC_ISER0				((__vo uint32_t*)0xE000E100)
#define NVIC_ISER1				((__vo uint32_t*)0xE000E104)
#define NVIC_ISER2				((__vo uint32_t*)0xE000E108)
#define NVIC_ISER3				((__vo uint32_t*)0xE000E10C)

/* ARM Cortex Mx Processor NVIC ICERx Register Addresses */
#define NVIC_ICER0				((__vo uint32_t*)0xE000E180)
#define NVIC_ICER1				((__vo uint32_t*)0xE000E184)
#define NVIC_ICER2				((__vo uint32_t*)0xE000E188)
#define NVIC_ICER3				((__vo uint32_t*)0xE000E18C)

/* ARM Cortex Mx Processor NVIC IPR Priority Register Address */
#define NVIC_PR_BASE_ADDR		((__vo uint32_t*)0xE000E400)

/* ARM Cortex Mx Processor Number of Priority Bits implemented in Priority Register */
#define NO_PR_BITS_IMPLEMENTED 	4


/* Base addresses of Flash and SRAM memories */
#define FLASH_BASEADDR			0x08000000U			/* 512kB */
#define SRAM1_BASEADDR			0x20000000U			/* 112kB */
#define SRAM2_BASEADDR			0x2001C000U			/* 16kB */
#define SYSMEM_BASEADDR			0x1FFF0000U			/* 30kB */
#define OTP_BASEADDR			0x1FFF7800U			/* 512B */
#define ROM						SYSMEM_BASEADDR		/* alias */
#define SRAM 					SRAM1_BASEADDR		/* alias */

/* AHBx and APBx Bus Peripheral base addresses */
#define PERIPH_BASEADDR			0x40000000U
#define APB1PERIPH_BASEADDR		PERIPH_BASEADDR
#define APB2PERIPH_BASEADDR		0x40010000U
#define AHB1PERIPH_BASEADDR		0x40020000U
#define AHB2PERIPH_BASEADDR		0x50000000U
#define AHB3PERIPH_BASEADDR		0x60000000U

/* Base addresses of peripherals which are hanging on AHB1 bus */
#define GPIOA_BASEADDR 			(AHB1PERIPH_BASEADDR + 0x0000)
#define GPIOB_BASEADDR 			(AHB1PERIPH_BASEADDR + 0x0400)
#define GPIOC_BASEADDR 			(AHB1PERIPH_BASEADDR + 0x0800)
#define GPIOD_BASEADDR 			(AHB1PERIPH_BASEADDR + 0x0C00)
#define GPIOE_BASEADDR 			(AHB1PERIPH_BASEADDR + 0x1000)
#define GPIOF_BASEADDR 			(AHB1PERIPH_BASEADDR + 0x1400)
#define GPIOG_BASEADDR 			(AHB1PERIPH_BASEADDR + 0x1800)
#define GPIOH_BASEADDR 			(AHB1PERIPH_BASEADDR + 0x1C00)
#define RCC_BASEADDR			(AHB1PERIPH_BASEADDR + 0x3800)

/* Base addresses of peripherals which are hanging on APB1 bus */
#define I2C1_BASEADDR			(APB1PERIPH_BASEADDR + 0x5400)
#define I2C2_BASEADDR			(APB1PERIPH_BASEADDR + 0x5800)
#define I2C3_BASEADDR			(APB1PERIPH_BASEADDR + 0x5C00)

#define SPI2_BASEADDR			(APB1PERIPH_BASEADDR + 0x3800)
#define SPI3_BASEADDR			(APB1PERIPH_BASEADDR + 0x3C00)

#define USART2_BASEADDR			(APB1PERIPH_BASEADDR + 0x4400)
#define USART3_BASEADDR			(APB1PERIPH_BASEADDR + 0x4800)

#define UART4_BASEADDR			(APB1PERIPH_BASEADDR + 0x4C00)
#define UART5_BASEADDR			(APB1PERIPH_BASEADDR + 0x5000)

/* Base addresses of peripherals which are hanging on APB2 bus */
#define EXTI_BASEADDR			(APB2PERIPH_BASEADDR + 0x3C00)

#define SPI1_BASEADDR			(APB2PERIPH_BASEADDR + 0x3000)
#define SPI4_BASEADDR			(APB2PERIPH_BASEADDR + 0x3400)

#define SYSCFG_BASEADDR			(APB2PERIPH_BASEADDR + 0x3800)

#define USART1_BASEADDR			(APB2PERIPH_BASEADDR + 0x1000)
#define USART6_BASEADDR			(APB2PERIPH_BASEADDR + 0x1400)


/*********************** Peripheral Register Definition Structures ***********************/

/* Peripheral register definition structure for GPIO */
typedef struct {
	__vo uint32_t MODER;   		/* GPIO Port Mode			  					Address offset: 0x00  	*/
	__vo uint32_t OTYPER;  		/* GPIO Port Output Type 						Address offset: 0x04	*/
	__vo uint32_t OSPEEDR;  	/* GPIO Port Output Speed 						Address offset: 0x08	*/
	__vo uint32_t PUPDR;   		/* GPIO Port Pull-Up/Pull-Down					Address offset: 0x0C	*/
	__vo uint32_t IDR;   		/* GPIO Port Input Data 						Address offset: 0x10	*/
	__vo uint32_t ODR;   		/* GPIO Port Output Data 						Address offset: 0x14	*/
	__vo uint32_t BSRR;   		/* GPIO Port Bit Set/Reset						Address offset: 0x18	*/
	__vo uint32_t LCKR;   		/* GPIO Port Configuration Lock 				Address offset: 0x1C	*/
	__vo uint32_t AFR[2];   	/* GPIO Alternate Functions
						       	   AFR[0]: Low, AFR[1]: High					Address offset: 0x20,24 */
} GPIO_RegDef_t;


/* Peripheral register definition structure for RCC */
typedef struct {
	__vo uint32_t CR;   		/* RCC Clock Control  							Address offset: 0x00  	*/
	__vo uint32_t PLLCFGR;  	/* RCC PLL Configuration						Address offset: 0x04	*/
	__vo uint32_t CFGR;  		/* RCC Clock Configuration						Address offset: 0x08	*/
	__vo uint32_t CIR;   		/* RCC Clock Interrupt							Address offset: 0x0C	*/
	__vo uint32_t AHB1RSTR; 	/* RCC AHB1 Peripheral Reset					Address offset: 0x10	*/
	__vo uint32_t AHB2RSTR; 	/* RCC AHB2 Peripheral Reset					Address offset: 0x14	*/
	__vo uint32_t AHB3RSTR; 	/* RCC AHB3 Peripheral Reset					Address offset: 0x18	*/
	uint32_t	  RESERVED0;	/* 												Reserved, 0x1C			*/
	__vo uint32_t APB1RSTR; 	/* RCC APB1 Peripheral Reset					Address offset: 0x20	*/
	__vo uint32_t APB2RSTR; 	/* RCC APB2 Peripheral Reset					Address offset: 0x24	*/
	uint32_t	  RESERVED1[2];	/* 												Reserved, 0x28,0x2C		*/
	__vo uint32_t AHB1ENR; 		/* RCC AHB1 Peripheral Clock Enable				Address offset: 0x30	*/
	__vo uint32_t AHB2ENR; 		/* RCC AHB2 Peripheral Clock Enable				Address offset: 0x34	*/
	__vo uint32_t AHB3ENR; 		/* RCC AHB3 Peripheral Clock Enable				Address offset: 0x38	*/
	uint32_t	  RESERVED2;	/* 												Reserved, 0x3C			*/
	__vo uint32_t APB1ENR; 		/* RCC APB1 Peripheral Clock Enable				Address offset: 0x40	*/
	__vo uint32_t APB2ENR; 		/* RCC APB2 Peripheral Clock Enable				Address offset: 0x44	*/
	uint32_t	  RESERVED3[2];	/* 												Reserved, 0x48,0x4C		*/
	__vo uint32_t AHB1LPENR; 	/* RCC AHB1 Peripheral Clock Enable Low Power	Address offset: 0x50	*/
	__vo uint32_t AHB2LPENR; 	/* RCC AHB2 Peripheral Clock Enable	Low Power	Address offset: 0x54	*/
	__vo uint32_t AHB3LPENR; 	/* RCC AHB3 Peripheral Clock Enable	Low Power	Address offset: 0x58	*/
	uint32_t	  RESERVED4;	/* 												Reserved, 0x5C			*/
	__vo uint32_t APB1LPENR; 	/* RCC APB1 Peripheral Clock Enable	Low Power	Address offset: 0x60	*/
	__vo uint32_t APB2LPENR; 	/* RCC APB2 Peripheral Clock Enable	Low Power	Address offset: 0x64	*/
	uint32_t	  RESERVED5[2];	/* 												Reserved, 0x68,0x6C		*/
	__vo uint32_t BDCR; 		/* RCC Backup Domain Control					Address offset: 0x70	*/
	__vo uint32_t CSR; 			/* RCC Clock Control and Status					Address offset: 0x74	*/
	uint32_t	  RESERVED6[2];	/* 												Reserved, 0x78,0x7C		*/
	__vo uint32_t SSCGR; 		/* RCC Spread Spectrum Clock Generation			Address offset: 0x80	*/
	__vo uint32_t PLLI2SCFGR; 	/* RCC PLLI2S Configuration						Address offset: 0x84	*/
	__vo uint32_t PLLSAICFGR; 	/* RCC PLL Configuration						Address offset: 0x88	*/
	__vo uint32_t DCKCFGR; 		/* RCC Dedicated Clock Configuration			Address offset: 0x8C	*/
	__vo uint32_t CKGATENR; 	/* RCC Clocks Gated Enable						Address offset: 0x90	*/
	__vo uint32_t DCKCFGR2; 	/* RCC Dedicated Clocks Configuration 2			Address offset: 0x94	*/
} RCC_RegDef_t;


/* Peripheral register definition structure for EXTI */
typedef struct {
	__vo uint32_t IMR;   		/* Interrupt Mask Register	  					Address offset: 0x00  	*/
	__vo uint32_t EMR;  		/* Event Mask Register							Address offset: 0x04	*/
	__vo uint32_t RTSR;  		/* Rising Trigger Selection Register			Address offset: 0x08	*/
	__vo uint32_t FTSR;   		/* Falling Trigger Selection Register			Address offset: 0x0C	*/
	__vo uint32_t SWIER;   		/* Software Interrupt Event Register			Address offset: 0x10	*/
	__vo uint32_t PR;   		/* Pending Register								Address offset: 0x14	*/
} EXTI_RegDef_t;


/* Peripheral register definition structure for SPI */
typedef struct {
	__vo uint32_t CR1;			/* SPI Control Register 1 (unused in I2S mode)	Address offset: 0x00	*/
	__vo uint32_t CR2;			/* SPI Control Register 2						Address offset: 0x04	*/
	__vo uint32_t SR;			/* SPI Status Register							Address offset: 0x08	*/
	__vo uint32_t DR;			/* SPI Data Register							Address offset: 0x0C	*/
	__vo uint32_t CRCPR;		/* SPI CRC Polynomial Register (unused in I2S)  Address offset: 0x10	*/
	__vo uint32_t RXCRCR;		/* SPI RX CRC Register (unused in I2S)			Address offset: 0x14	*/
	__vo uint32_t TXCRCR;		/* SPI TX CRC Register (unused in I2s) 			Address offset: 0x18	*/
	__vo uint32_t I2SCFGR;		/* SPI I2S Configuration Register				Address offset: 0x1C	*/
	__vo uint32_t I2SPR;		/* SPI I2S Prescalar Register					Address offset: 0x20	*/
} SPI_RegDef_t;


/* Peripheral register definition structure for SYSCFG */
typedef struct {
	__vo uint32_t MEMRMP;   	/* SYSCFG Memory Remap Register 				Address offset: 0x00  	*/
	__vo uint32_t PMC;  		/* SYSCFG Peripheral Mode Config Register		Address offset: 0x04	*/
	__vo uint32_t EXTICR[4];  	/* SYSCFG Ext. Interrupt Config Register 1-4    Address offset: 0x08,0x0C,0x10,0x14 */
	uint32_t RESERVED1[2];   	/* 												Reserved, 0x18,0x1C		*/
	__vo uint32_t CMPCR;   		/* Compensation Cell Control Register			Address offset: 0x20	*/
	uint32_t RESERVED2[2];   	/* 												Reserved, 0x24,0x28		*/
	__vo uint32_t CFGR;   		/* SYSCFG Configuration Register				Address offset: 0x2C	*/
} SYSCFG_RegDef_t;

/* Peripheral register definition structure for I2C */
typedef struct {
	__vo uint32_t CR1;   		/* I2C Control Register 1		 				Address offset: 0x00  	*/
	__vo uint32_t CR2;  		/* I2C Control Register 2						Address offset: 0x04	*/
	__vo uint32_t OAR1;  		/* I2C Own Address Register 1				    Address offset: 0x08	*/
	__vo uint32_t OAR2;   		/* I2C Own Address Register 2					Address offset: 0x0C	*/
	__vo uint32_t DR;   		/* I2C Data Register							Address offset: 0x10	*/
	__vo uint32_t SR1;   		/* I2C Status Register 1						Address offset: 0x14	*/
	__vo uint32_t SR2;   		/* I2C Status Register 2						Address offset: 0x18	*/
	__vo uint32_t CCR;   		/* I2C Clock Control Register					Address offset: 0x1C	*/
	__vo uint32_t TRISE;   		/* I2C TRISE Register							Address offset: 0x20	*/
	__vo uint32_t FLTR;   		/* I2C FLTR Register							Address offset: 0x24	*/
} I2C_RegDef_t;

/* Peripheral register definition structure for USART */
typedef struct {
	__vo uint32_t SR;   		/* USART Status Register	 					Address offset: 0x00  	*/
	__vo uint32_t DR;  			/* USART Data Register							Address offset: 0x04	*/
	__vo uint32_t BRR;  		/* USART Baud Rate Register				  		Address offset: 0x08	*/
	__vo uint32_t CR1;   		/* USART Control Register 1						Address offset: 0x0C	*/
	__vo uint32_t CR2;   		/* USART Control Register 2						Address offset: 0x10	*/
	__vo uint32_t CR3;   		/* USART Control Register 3						Address offset: 0x14	*/
	__vo uint32_t GTPR;   		/* USART Guard Time and Prescaler Register		Address offset: 0x18	*/
} USART_RegDef_t;

/* Peripheral definitions (Peripheral base addresses type cast to xxx_RegDef_t) */
#define GPIOA 		((GPIO_RegDef_t*) GPIOA_BASEADDR)
#define GPIOB 		((GPIO_RegDef_t*) GPIOB_BASEADDR)
#define GPIOC 		((GPIO_RegDef_t*) GPIOC_BASEADDR)
#define GPIOD 		((GPIO_RegDef_t*) GPIOD_BASEADDR)
#define GPIOE 		((GPIO_RegDef_t*) GPIOE_BASEADDR)
#define GPIOF 		((GPIO_RegDef_t*) GPIOF_BASEADDR)
#define GPIOG 		((GPIO_RegDef_t*) GPIOG_BASEADDR)
#define GPIOH 		((GPIO_RegDef_t*) GPIOH_BASEADDR)

#define RCC			((RCC_RegDef_t*) RCC_BASEADDR)

#define EXTI		((EXTI_RegDef_t*) EXTI_BASEADDR)

#define SYSCFG		((SYSCFG_RegDef_t*) SYSCFG_BASEADDR)

#define SPI1		((SPI_RegDef_t*) SPI1_BASEADDR)
#define SPI2		((SPI_RegDef_t*) SPI2_BASEADDR)
#define SPI3		((SPI_RegDef_t*) SPI3_BASEADDR)
#define SPI4		((SPI_RegDef_t*) SPI4_BASEADDR)

#define I2C1		((I2C_RegDef_t*) I2C1_BASEADDR)
#define I2C2		((I2C_RegDef_t*) I2C2_BASEADDR)
#define I2C3		((I2C_RegDef_t*) I2C3_BASEADDR)

#define USART1		((USART_RegDef_t*) USART1_BASEADDR)
#define USART2		((USART_RegDef_t*) USART2_BASEADDR)
#define USART3		((USART_RegDef_t*) USART3_BASEADDR)
#define UART4		((USART_RegDef_t*) UART4_BASEADDR)
#define UART5		((USART_RegDef_t*) UART5_BASEADDR)
#define USART6		((USART_RegDef_t*) USART6_BASEADDR)

/********************* PERIPHERAL CLOCK ENABLE MACROS *********************/

/* Clock Enable Macros for GPIOx peripherals */
#define GPIOA_PCLK_EN()		(RCC->AHB1ENR |= (1 <<  0))
#define GPIOB_PCLK_EN()		(RCC->AHB1ENR |= (1 <<  1))
#define GPIOC_PCLK_EN()		(RCC->AHB1ENR |= (1 <<  2))
#define GPIOD_PCLK_EN()		(RCC->AHB1ENR |= (1 <<  3))
#define GPIOE_PCLK_EN()		(RCC->AHB1ENR |= (1 <<  4))
#define GPIOF_PCLK_EN()		(RCC->AHB1ENR |= (1 <<  5))
#define GPIOG_PCLK_EN()		(RCC->AHB1ENR |= (1 <<  6))
#define GPIOH_PCLK_EN()		(RCC->AHB1ENR |= (1 <<  7))

/* Clock Enable Macros for I2Cx peripherals */
#define I2C1_PCLK_EN()		(RCC->APB1ENR |= (1 << 21))
#define I2C2_PCLK_EN()		(RCC->APB1ENR |= (1 << 22))
#define I2C3_PCLK_EN()		(RCC->APB1ENR |= (1 << 23))

/* Clock Enable Macros for SPIx peripherals */
#define SPI1_PCLK_EN()		(RCC->APB2ENR |= (1 << 12))
#define SPI2_PCLK_EN()		(RCC->APB1ENR |= (1 << 14))
#define SPI3_PCLK_EN()		(RCC->APB1ENR |= (1 << 15))
#define SPI4_PCLK_EN()		(RCC->APB2ENR |= (1 << 13))

/* Clock Enable Macros for USARTx peripherals */
#define USART1_PCLK_EN()	(RCC->APB2ENR |= (1 <<  4))
#define USART2_PCLK_EN()	(RCC->APB1ENR |= (1 << 17))
#define USART3_PCLK_EN()	(RCC->APB1ENR |= (1 << 18))
#define UART4_PCLK_EN()		(RCC->APB1ENR |= (1 << 19))
#define UART5_PCLK_EN()		(RCC->APB1ENR |= (1 << 20))
#define USART6_PCLK_EN()	(RCC->APB2ENR |= (1 <<  5))

/* Clock Enable Macro for SYSCFG peripheral */
#define SYSCFG_PCLK_EN()	(RCC->APB2ENR |= (1 << 14))


/**** PERIPHERAL CLOCK DISABLE MACROS ****/

/* Clock Disable Macros for GPIOx peripherals */
#define GPIOA_PCLK_DI()		(RCC->AHB1ENR &= ~(1 <<  0))
#define GPIOB_PCLK_DI()		(RCC->AHB1ENR &= ~(1 <<  1))
#define GPIOC_PCLK_DI()		(RCC->AHB1ENR &= ~(1 <<  2))
#define GPIOD_PCLK_DI()		(RCC->AHB1ENR &= ~(1 <<  3))
#define GPIOE_PCLK_DI()		(RCC->AHB1ENR &= ~(1 <<  4))
#define GPIOF_PCLK_DI()		(RCC->AHB1ENR &= ~(1 <<  5))
#define GPIOG_PCLK_DI()		(RCC->AHB1ENR &= ~(1 <<  6))
#define GPIOH_PCLK_DI()		(RCC->AHB1ENR &= ~(1 <<  7))

/* Clock Disable Macros for I2Cx peripherals */
#define I2C1_PCLK_DI()		(RCC->APB1ENR &= ~(1 << 21))
#define I2C2_PCLK_DI()		(RCC->APB1ENR &= ~(1 << 22))
#define I2C3_PCLK_DI()		(RCC->APB1ENR &= ~(1 << 23))

/* Clock Disable Macros for SPIx peripherals */
#define SPI1_PCLK_DI()		(RCC->APB2ENR &= ~(1 << 12))
#define SPI2_PCLK_DI()		(RCC->APB1ENR &= ~(1 << 14))
#define SPI3_PCLK_DI()		(RCC->APB1ENR &= ~(1 << 15))
#define SPI4_PCLK_DI()		(RCC->APB2ENR &= ~(1 << 13))

/* Clock Disable Macros for USARTx peripherals */
#define USART1_PCLK_DI()	(RCC->APB2ENR &= ~(1 <<  4))
#define USART2_PCLK_DI()	(RCC->APB1ENR &= ~(1 << 17))
#define USART3_PCLK_DI()	(RCC->APB1ENR &= ~(1 << 18))
#define UART4_PCLK_DI()		(RCC->APB1ENR &= ~(1 << 19))
#define UART5_PCLK_DI()		(RCC->APB1ENR &= ~(1 << 20))
#define USART6_PCLK_DI()	(RCC->APB2ENR &= ~(1 <<  5))

/* Clock Disable Macro for SYSCFG peripheral */
#define SYSCFG_PCLK_DI()	(RCC->APB2ENR &= ~(1 << 14))


/* Macros to reset GPIOx Peripherals */
#define GPIOA_REG_RESET()	do{ (RCC->AHB1RSTR |= (1 << 0));  (RCC->AHB1RSTR &= ~(1 << 0)); } while(0)
#define GPIOB_REG_RESET()	do{ (RCC->AHB1RSTR |= (1 << 1));  (RCC->AHB1RSTR &= ~(1 << 0)); } while(0)
#define GPIOC_REG_RESET()	do{ (RCC->AHB1RSTR |= (1 << 2));  (RCC->AHB1RSTR &= ~(1 << 0)); } while(0)
#define GPIOD_REG_RESET()	do{ (RCC->AHB1RSTR |= (1 << 3));  (RCC->AHB1RSTR &= ~(1 << 0)); } while(0)
#define GPIOE_REG_RESET()	do{ (RCC->AHB1RSTR |= (1 << 4));  (RCC->AHB1RSTR &= ~(1 << 0)); } while(0)
#define GPIOF_REG_RESET()	do{ (RCC->AHB1RSTR |= (1 << 5));  (RCC->AHB1RSTR &= ~(1 << 0)); } while(0)
#define GPIOG_REG_RESET()	do{ (RCC->AHB1RSTR |= (1 << 6));  (RCC->AHB1RSTR &= ~(1 << 0)); } while(0)
#define GPIOH_REG_RESET()	do{ (RCC->AHB1RSTR |= (1 << 7));  (RCC->AHB1RSTR &= ~(1 << 0)); } while(0)

#define GPIO_BASEADDR_TO_CODE(x) ((x == GPIOA) ? 0 : \
								  (x == GPIOB) ? 1 : \
								  (x == GPIOC) ? 2 : \
								  (x == GPIOD) ? 3 : \
								  (x == GPIOE) ? 4 : \
								  (x == GPIOF) ? 5 : \
								  (x == GPIOG) ? 6 : \
								  (x == GPIOG) ? 7 : 0)

/* Macros to reset SPIx Peripherals */
#define SPI1_REG_RESET()	do{ (RCC->APB2RSTR |= (1 << 12));  (RCC->APB2RSTR &= ~(1 << 0)); } while(0)
#define SPI2_REG_RESET()	do{ (RCC->APB1RSTR |= (1 << 14));  (RCC->APB1RSTR &= ~(1 << 0)); } while(0)
#define SPI3_REG_RESET()	do{ (RCC->APB1RSTR |= (1 << 15));  (RCC->APB1RSTR &= ~(1 << 0)); } while(0)
#define SPI4_REG_RESET()	do{ (RCC->APB2RSTR |= (1 << 13));  (RCC->APB2RSTR &= ~(1 << 0)); } while(0)

/* Macros to reset I2Cx Peripherals */
#define I2C1_REG_RESET()	do{ (RCC->APB1RSTR |= (1 << 21));  (RCC->APB1RSTR &= ~(1 << 0)); } while(0)
#define I2C2_REG_RESET()	do{ (RCC->APB1RSTR |= (1 << 22));  (RCC->APB1RSTR &= ~(1 << 0)); } while(0)
#define I2C3_REG_RESET()	do{ (RCC->APB1RSTR |= (1 << 23));  (RCC->APB1RSTR &= ~(1 << 0)); } while(0)

/* Macros to reset USARTx Peripherals */
#define USART1_REG_RESET()	do{ (RCC->APB2RSTR |= (1 <<  4));  (RCC->APB2RSTR &= ~(1 << 0)); } while(0)
#define USART2_REG_RESET()	do{ (RCC->APB1RSTR |= (1 << 17));  (RCC->APB1RSTR &= ~(1 << 0)); } while(0)
#define USART3_REG_RESET()	do{ (RCC->APB1RSTR |= (1 << 18));  (RCC->APB1RSTR &= ~(1 << 0)); } while(0)
#define UART4_REG_RESET()	do{ (RCC->APB1RSTR |= (1 << 19));  (RCC->APB1RSTR &= ~(1 << 0)); } while(0)
#define UART5_REG_RESET()	do{ (RCC->APB1RSTR |= (1 << 20));  (RCC->APB1RSTR &= ~(1 << 0)); } while(0)
#define USART6_REG_RESET()	do{ (RCC->APB2RSTR |= (1 <<  5));  (RCC->APB2RSTR &= ~(1 << 0)); } while(0)


/* IRQ (Interrupt Request) Numbers of STM32F446xx MCU */
#define IRQ_NO_EXTI0				6
#define IRQ_NO_EXTI1				7
#define IRQ_NO_EXTI2			  	8
#define IRQ_NO_EXTI3			  	9
#define IRQ_NO_EXTI4			  	10
#define IRQ_NO_EXTI9_5			  	23
#define IRQ_NO_EXTI15_10		  	40

#define IRQ_NO_SPI1					35
#define IRQ_NO_SPI2					36
#define IRQ_NO_SPI3					51
#define IRQ_NO_SPI4					84

#define IRQ_NO_I2C1_EV				31
#define IRQ_NO_I2C1_ER				32
#define IRQ_NO_I2C2_EV				33
#define IRQ_NO_I2C2_ER				34
#define IRQ_NO_I2C3_EV				72
#define IRQ_NO_I2C3_ER				73

#define IRQ_NO_USART1				37
#define IRQ_NO_USART2				38
#define IRQ_NO_USART3				39
#define IRQ_NO_UART4				52
#define IRQ_NO_UART5				53
#define IRQ_NO_USART6				71


/* NVIC IRQ Priority Level Macros */
#define NVIC_IRQ_PRI0				0
#define NVIC_IRQ_PRI1				1
#define NVIC_IRQ_PRI2				2
#define NVIC_IRQ_PRI3				3
#define NVIC_IRQ_PRI4				4
#define NVIC_IRQ_PRI5				5
#define NVIC_IRQ_PRI6				6
#define NVIC_IRQ_PRI7				7
#define NVIC_IRQ_PRI8				8
#define NVIC_IRQ_PRI9				9
#define NVIC_IRQ_PRI10				10
#define NVIC_IRQ_PRI11				11
#define NVIC_IRQ_PRI12				12
#define NVIC_IRQ_PRI13				13
#define NVIC_IRQ_PRI14				14
#define NVIC_IRQ_PRI15				15
#define NVIC_IRQ_PRI16				16
#define NVIC_IRQ_PRI17				17
#define NVIC_IRQ_PRI18				18
#define NVIC_IRQ_PRI19				19
#define NVIC_IRQ_PRI20				20
#define NVIC_IRQ_PRI21				21
#define NVIC_IRQ_PRI22				22
#define NVIC_IRQ_PRI23				23
#define NVIC_IRQ_PRI24				24
#define NVIC_IRQ_PRI25				25
#define NVIC_IRQ_PRI26				26
#define NVIC_IRQ_PRI27				27
#define NVIC_IRQ_PRI28				28
#define NVIC_IRQ_PRI29				29
#define NVIC_IRQ_PRI30				30
#define NVIC_IRQ_PRI31				31
#define NVIC_IRQ_PRI32				32
#define NVIC_IRQ_PRI33				33
#define NVIC_IRQ_PRI34				34
#define NVIC_IRQ_PRI35				35
#define NVIC_IRQ_PRI36				36
#define NVIC_IRQ_PRI37				37
#define NVIC_IRQ_PRI38				38
#define NVIC_IRQ_PRI39				39
#define NVIC_IRQ_PRI40				40
#define NVIC_IRQ_PRI41				41
#define NVIC_IRQ_PRI42				42
#define NVIC_IRQ_PRI43				43
#define NVIC_IRQ_PRI44				44
#define NVIC_IRQ_PRI45				45
#define NVIC_IRQ_PRI46				46
#define NVIC_IRQ_PRI47				47
#define NVIC_IRQ_PRI48				48
#define NVIC_IRQ_PRI49				49
#define NVIC_IRQ_PRI50				50
#define NVIC_IRQ_PRI51				51
#define NVIC_IRQ_PRI52				52
#define NVIC_IRQ_PRI53				53
#define NVIC_IRQ_PRI54				54
#define NVIC_IRQ_PRI55				55
#define NVIC_IRQ_PRI56				56
#define NVIC_IRQ_PRI57				57
#define NVIC_IRQ_PRI58				58
#define NVIC_IRQ_PRI59				59
#define NVIC_IRQ_PRI60				60
#define NVIC_IRQ_PRI61				61
#define NVIC_IRQ_PRI62				62
#define NVIC_IRQ_PRI63				63
#define NVIC_IRQ_PRI64				64
#define NVIC_IRQ_PRI65				65
#define NVIC_IRQ_PRI66				66
#define NVIC_IRQ_PRI67				67
#define NVIC_IRQ_PRI68				68
#define NVIC_IRQ_PRI69				69
#define NVIC_IRQ_PRI70				70
#define NVIC_IRQ_PRI71				71
#define NVIC_IRQ_PRI72				72
#define NVIC_IRQ_PRI73				73
#define NVIC_IRQ_PRI74				74
#define NVIC_IRQ_PRI75				75
#define NVIC_IRQ_PRI76				76
#define NVIC_IRQ_PRI77				77
#define NVIC_IRQ_PRI78				78
#define NVIC_IRQ_PRI79				79
#define NVIC_IRQ_PRI80				80
#define NVIC_IRQ_PRI81				81
#define NVIC_IRQ_PRI82				82
#define NVIC_IRQ_PRI83				83
#define NVIC_IRQ_PRI84				84
#define NVIC_IRQ_PRI85				85
#define NVIC_IRQ_PRI86				86
#define NVIC_IRQ_PRI87				87
#define NVIC_IRQ_PRI88				88
#define NVIC_IRQ_PRI89				89
#define NVIC_IRQ_PRI90				90
#define NVIC_IRQ_PRI91				91
#define NVIC_IRQ_PRI92				92
#define NVIC_IRQ_PRI93				93
#define NVIC_IRQ_PRI94				94
#define NVIC_IRQ_PRI95				95
#define NVIC_IRQ_PRI96				96
#define NVIC_IRQ_PRI97				97
#define NVIC_IRQ_PRI98				98
#define NVIC_IRQ_PRI99				99
#define NVIC_IRQ_PRI100				100
#define NVIC_IRQ_PRI101				101
#define NVIC_IRQ_PRI102				102
#define NVIC_IRQ_PRI103				103


/********************* Bit Position Definitions of SPI Peripheral *********************/
/* Bit Position Definitions of SPI_CR1 */
#define SPI_CR1_CPHA				0
#define SPI_CR1_CPOL				1
#define SPI_CR1_MSTR				2
#define SPI_CR1_BR					3
#define SPI_CR1_SPE					6
#define SPI_CR1_LSBFIRST			7
#define SPI_CR1_SSI					8
#define SPI_CR1_SSM					9
#define SPI_CR1_RXONLY				10
#define SPI_CR1_DFF					11
#define SPI_CR1_CRCNEXT				12
#define SPI_CR1_CRCEN				13
#define SPI_CR1_BIDIOE				14
#define SPI_CR1_BIDIMODE			15

/* Bit Position Definitions of SPI_CR2 */
#define SPI_CR2_RXDMAEN				0
#define SPI_CR2_TXDMAEN				1
#define SPI_CR2_SSOE				2
#define SPI_CR2_FRF					4
#define SPI_CR2_ERRIE				5
#define SPI_CR2_RXNEIE				6
#define SPI_CR2_TXEIE				7

/* Bit Position Definitions of SPI_SR */
#define SPI_SR_RXNE					0
#define SPI_SR_TXE					1
#define SPI_SR_CHSIDE				2
#define SPI_SR_UDR					3
#define SPI_SR_CRCERR				4
#define SPI_SR_MODF					5
#define SPI_SR_OVR					6
#define SPI_SR_BSY					7
#define SPI_SR_FRE					8

/********************* Bit Position Definitions of I2C Peripheral *********************/
/* Bit Position Definitions of I2C_CR1 */
#define I2C_CR1_PE					0
#define I2C_CR1_SMBUS				1
#define I2C_CR1_SMBTYPE				3
#define I2C_CR1_ENARP				4
#define I2C_CR1_ENPEC				5
#define I2C_CR1_ENGC				6
#define I2C_CR1_NOSTRETCH			7
#define I2C_CR1_START				8
#define I2C_CR1_STOP				9
#define I2C_CR1_ACK					10
#define I2C_CR1_POS					11
#define I2C_CR1_PEC					12
#define I2C_CR1_ALERT				13
#define I2C_CR1_SWRST				15

/* Bit Position Definitions of I2C_CR2 */
#define I2C_CR2_FREQ				0
#define I2C_CR2_ITERREN				8
#define I2C_CR2_ITEVTEN				9
#define I2C_CR2_ITBUFEN				10
#define I2C_CR2_DMAEN				11
#define I2C_CR2_LAST				12

/* Bit Position Definitions of I2C_OAR1 */
#define I2C_OAR1_ADD0				0
#define I2C_OAR1_ADD71				1
#define I2C_OAR1_ADD98				8
#define I2C_OAR1_ADDMODE			15

/* Bit Position Definitions of I2C_OAR2 */
#define I2C_OAR2_ENDUAL				0
#define I2C_OAR2_ADD71				1

/* Bit Position Definitions of I2C_DR */
#define I2C_DR_70					0

/* Bit Position Definitions of I2C_SR1 */
#define I2C_SR1_SB					0
#define I2C_SR1_ADDR				1
#define I2C_SR1_BTF					2
#define I2C_SR1_ADD10				3
#define I2C_SR1_STOPF				4
#define I2C_SR1_RXNE				6
#define I2C_SR1_TXE					7
#define I2C_SR1_BERR				8
#define I2C_SR1_ARLO				9
#define I2C_SR1_AF					10
#define I2C_SR1_OVR					11
#define I2C_SR1_PECERR				12
#define I2C_SR1_TIMEOUT				14
#define I2C_SR1_SMBALERT			15

/* Bit Position Definitions of I2C_SR2 */
#define I2C_SR2_MSL					0
#define I2C_SR2_BUSY				1
#define I2C_SR2_TRA					2
#define I2C_SR2_GENCALL				4
#define I2C_SR2_SMBDEFAULT			5
#define I2C_SR2_SMBHOST				6
#define I2C_SR2_DUALF				7
#define I2C_SR2_PEC70				8

/* Bit Position Definitions of I2C_CCR */
#define I2C_CCR_CCR					0
#define I2C_CCR_DUTY				14
#define I2C_CCR_FS					15

/* Bit Position Definitions of I2C_TRISE */
#define I2C_TRISE_TRISE5_0			0

/* Bit Position Definitions of I2C_FLTR */
#define I2C_FLTR_DNF3_0				0
#define I2C_ANOFF					4

/********************* Bit Position Definitions of USART Peripheral *********************/
/* Bit Position Definitions of USART_SR */
#define USART_SR_PE					0
#define USART_SR_FE					1
#define USART_SR_NF					2
#define USART_SR_ORE				3
#define USART_SR_IDLE				4
#define USART_SR_RXNE				5
#define USART_SR_TC					6
#define USART_SR_TXE				7
#define USART_SR_LBD				8
#define USART_SR_CTS				9

/* Bit position definitions USART_CR1 */
#define USART_CR1_SBK					0
#define USART_CR1_RWU 					1
#define USART_CR1_RE  					2
#define USART_CR1_TE 					3
#define USART_CR1_IDLEIE 				4
#define USART_CR1_RXNEIE  				5
#define USART_CR1_TCIE					6
#define USART_CR1_TXEIE					7
#define USART_CR1_PEIE 					8
#define USART_CR1_PS 					9
#define USART_CR1_PCE 					10
#define USART_CR1_WAKE  				11
#define USART_CR1_M 					12
#define USART_CR1_UE 					13
#define USART_CR1_OVER8  				15

/* Bit position definitions USART_CR2 */
#define USART_CR2_ADD   				0
#define USART_CR2_LBDL   				5
#define USART_CR2_LBDIE  				6
#define USART_CR2_LBCL   				8
#define USART_CR2_CPHA   				9
#define USART_CR2_CPOL   				10
#define USART_CR2_CLKEN   				11
#define USART_CR2_STOP   				12
#define USART_CR2_LINEN   				14

/* Bit position definitions USART_CR3 */
#define USART_CR3_EIE   				0
#define USART_CR3_IREN   				1
#define USART_CR3_IRLP  				2
#define USART_CR3_HDSEL   				3
#define USART_CR3_NACK   				4
#define USART_CR3_SCEN   				5
#define USART_CR3_DMAR  				6
#define USART_CR3_DMAT   				7
#define USART_CR3_RTSE   				8
#define USART_CR3_CTSE   				9
#define USART_CR3_CTSIE   				10
#define USART_CR3_ONEBIT   				11


#include "stm32f446xx_gpio_driver.h"
#include "stm32f446xx_spi_driver.h"
#include "stm32f446xx_i2c_driver.h"
#include "stm32f446xx_usart_driver.h"
#include "stm32f446xx_rcc_driver.h"

#endif /* INC_STM32F446XX_H_ */

/****************************************************************************************/
							stm32f446xx_gpio_driver.c
/****************************************************************************************/	
/*
 * stm32f446xx_gpio_driver.c
 *
 *  Created on: Jan 24, 2021
 *      Author: Oliver
 */

#include "stm32f446xx_gpio_driver.h"


/* Peripheral Clock Setup */
/* ******************************************************************************
 * @fn					-  GPIO_PClockControl
 *
 * @brief				-  This function enables or disables the peripheral clock
 * 						   for the given GPIO port.
 *
 * @param[in]			-  Base address of the GPIO peripheral
 * @param[in]			-  ENABLE or DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void GPIO_PClockControl(GPIO_RegDef_t *pGPIOx, uint8_t State) {

	//Enable peripheral clock for specified GPIO Port A..H
	if(State == ENABLE) {

		if(pGPIOx == GPIOA) {
			GPIOA_PCLK_EN();
		} else if(pGPIOx == GPIOB) {
			GPIOB_PCLK_EN();
		} else if(pGPIOx == GPIOC) {
			GPIOC_PCLK_EN();
		} else if(pGPIOx == GPIOD) {
			GPIOD_PCLK_EN();
		} else if(pGPIOx == GPIOE) {
			GPIOE_PCLK_EN();
		} else if(pGPIOx == GPIOF) {
			GPIOF_PCLK_EN();
		} else if(pGPIOx == GPIOG) {
			GPIOG_PCLK_EN();
		} else if(pGPIOx == GPIOH) {
			GPIOH_PCLK_EN();
		}

	//Disable peripheral clock for specified GPIO Port A..H
	} else {

		if(pGPIOx == GPIOA) {
			GPIOA_PCLK_DI();
		} else if(pGPIOx == GPIOB) {
			GPIOB_PCLK_DI();
		} else if(pGPIOx == GPIOC) {
			GPIOC_PCLK_DI();
		} else if(pGPIOx == GPIOD) {
			GPIOD_PCLK_DI();
		} else if(pGPIOx == GPIOE) {
			GPIOE_PCLK_DI();
		} else if(pGPIOx == GPIOF) {
			GPIOF_PCLK_DI();
		} else if(pGPIOx == GPIOG) {
			GPIOG_PCLK_DI();
		} else if(pGPIOx == GPIOH) {
			GPIOH_PCLK_DI();
		}
	}
}


/* Initialize and Deinitialize */
/* ******************************************************************************
 * @fn					-  GPIO_Init
 *
 * @brief				-  Initializes the GPIO peripheral
 *
 * @param[in]			-  Base address of the GPIO handle
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void GPIO_Init(GPIO_Handle_t *pGPIOHandle) {

	uint32_t temp = 0;

	//Peripheral Clock Enable
	GPIO_PClockControl(pGPIOHandle->pGPIOx, ENABLE);

	//1. Configure the mode of gpio pin
	if(pGPIOHandle->GPIO_PinConfig.GPIO_PinMode <= GPIO_MODE_ANALOG) {

		//non-interrupt mode
		temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));
		pGPIOHandle->pGPIOx->MODER &= ~(0x3 << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber)); //clearing
		pGPIOHandle->pGPIOx->MODER |= temp; //setting

	} else {

		//interrupt mode
		if(pGPIOHandle->GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_IN_FT) {
			//1. Configure the FTSR
			EXTI->FTSR |= ( 1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
			//clear the corresponding RTSR bit
			EXTI->RTSR &= ~( 1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
		} else if (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_IN_RT) {
			//1. Configure the RTSR
			EXTI->RTSR |= ( 1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
			//clear the corresponding FTSR bit
			EXTI->FTSR &= ~( 1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
		} else if (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_IN_RFT) {
			//1. Configure both FTSR and RTSR
			EXTI->FTSR |= ( 1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
			EXTI->RTSR |= ( 1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
		}

		//2. Configure the GPIO port selection in SYSCFG_EXTICR
		uint8_t temp1 = pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber / 4;
		uint8_t temp2 = pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber % 4;
		uint8_t portcode = GPIO_BASEADDR_TO_CODE(pGPIOHandle->pGPIOx);
		SYSCFG_PCLK_EN();
		SYSCFG->EXTICR[temp1] = portcode << (temp2 * 4);

		//3. Enable the EXTI interrupt delivery using IMR
		EXTI->IMR |= ( 1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
	}

	//2. configure the speed
	temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinSpeed << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));
	pGPIOHandle->pGPIOx->OSPEEDR &= ~(0x3 << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber)); //clearing
	pGPIOHandle->pGPIOx->OSPEEDR |= temp; //setting

	//3. configure the pupd settings
	temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinPuPdControl << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));
	pGPIOHandle->pGPIOx->PUPDR &= ~(0x3 << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber)); //clearing
	pGPIOHandle->pGPIOx->PUPDR |= temp;	//setting

	//4. configure the optype
	temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinOPType << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
	pGPIOHandle->pGPIOx->OTYPER &= ~(0x1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber); //clearing
	pGPIOHandle->pGPIOx->OTYPER |= temp; //setting

	//5. configure the alternate functionality
	if(pGPIOHandle->GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_ALTFN) {
		//configure alt function registers
		uint8_t temp1, temp2;

		temp1 = pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber / 8;
		temp2 = pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber % 8;

		pGPIOHandle->pGPIOx->AFR[temp1] &= ~(0xF << (4 * temp2)); //clearing
		pGPIOHandle->pGPIOx->AFR[temp1] |= (pGPIOHandle->GPIO_PinConfig.GPIO_PinAltFunMode << (4 * temp2)); //setting
	}
}

/* ******************************************************************************
 * @fn					-  GPIO_DeInit
 *
 * @brief				-  De-initializes the GPIO peripheral
 *
 * @param[in]			-  Base address of the GPIO peripheral
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void GPIO_DeInit(GPIO_RegDef_t *pGPIOx) {

	if(pGPIOx == GPIOA) {
		GPIOA_REG_RESET();
	} else if(pGPIOx == GPIOB) {
		GPIOB_REG_RESET();
	} else if(pGPIOx == GPIOC) {
		GPIOC_REG_RESET();
	} else if(pGPIOx == GPIOD) {
		GPIOD_REG_RESET();
	} else if(pGPIOx == GPIOE) {
		GPIOE_REG_RESET();
	} else if(pGPIOx == GPIOF) {
		GPIOF_REG_RESET();
	} else if(pGPIOx == GPIOG) {
		GPIOG_REG_RESET();
	} else if(pGPIOx == GPIOH) {
		GPIOH_REG_RESET();
	}
}

/* Data Read and Write */
/* ******************************************************************************
 * @fn					-  GPIO_ReadFromInputPin
 *
 * @brief				-  Read from input GPIO pin
 *
 * @param[in]			-  Base address of the GPIO peripheral
 * @param[in]			-  GPIOx pin number
 *
 * @return				-  Byte: 0 or 1
 *
 * @note				-  None
 *
 */
uint8_t GPIO_ReadFromInputPin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber) {

	uint8_t value;

	//only care about the LSB, so use right shift and masking to extract the correct bit
	value = (uint8_t) ((pGPIOx->IDR >> PinNumber) & 0x00000001);

	return value;
}

/* ******************************************************************************
 * @fn					-  GPIO_ReadFromInputPort
 *
 * @brief				-  Read from input GPIO port
 *
 * @param[in]			-  Base address of the GPIO peripheral
 *
 * @return				-  Word (16-bit) read from GPIOx port
 *
 * @note				-  None
 *
 */
uint16_t GPIO_ReadFromInputPort(GPIO_RegDef_t *pGPIOx) {

	uint16_t value;

	value = (uint16_t) pGPIOx->IDR;

	return value;
}

/* ******************************************************************************
 * @fn					-  GPIO_WriteToOutputPin
 *
 * @brief				-  Write to output GPIO pin
 *
 * @param[in]			-  Base address of the GPIO peripheral
 * @param[in]			-  GPIOx pin number
 * @param[in]			-  SET or RESET macros
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void GPIO_WriteToOutputPin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber, uint8_t Value) {

	if(Value == GPIO_PIN_SET) {
		//write 1 to the output data register at the bit field corresponding to the pin number
		pGPIOx->ODR |= (1 << PinNumber);
	} else {
		//write 0
		pGPIOx->ODR &= ~(1 << PinNumber);
	}
}

/* ******************************************************************************
 * @fn					-  GPIO_WriteToOutputPort
 *
 * @brief				-  Write to output GPIO port
 *
 * @param[in]			-  Base address of the GPIO peripheral
 * @param[in]			-  16-bit value
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void GPIO_WriteToOutputPort(GPIO_RegDef_t *pGPIOx, uint16_t Value) {

	pGPIOx->ODR = Value;
}

/* ******************************************************************************
 * @fn					-  GPIO_ToggleOutputPin
 *
 * @brief				-  Toggle output GPIO pin
 *
 * @param[in]			-  Base address of the GPIO peripheral
 * @param[in]			-  GPIOx pin number
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void GPIO_ToggleOutputPin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber) {

	pGPIOx->ODR ^= (1 << PinNumber);
}


/* IRQ Configuration, Priority and ISR Handling */
/* ******************************************************************************
 * @fn					-  GPIO_IRQInterruptConfig
 *
 * @brief				-  Configure interrupt request (IRQx)
 *
 * @param[in]			-  IRQ number
 * @param[in]			-  ENABLE or DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void GPIO_IRQInterruptConfig(uint8_t IRQNumber, uint8_t State) {

	if(State == ENABLE) {

		if(IRQNumber <= 31) { //IRQ 0 to 31
			//program ISER0 register
			*NVIC_ISER0 |= (1 << IRQNumber);
		} else if(IRQNumber > 31 && IRQNumber < 64) { //IRQ 32 to 63
			//program ISER1 register
			*NVIC_ISER1 |= (1 << (IRQNumber % 32));
		} else if(IRQNumber >= 64 && IRQNumber < 96) { //IRQ 64 to 95
			//program ISER2 register
			*NVIC_ISER2 |= (1 << (IRQNumber % 64));
		} else if(IRQNumber >= 96 && IRQNumber < 128) { //IRQ 96 to 127 (stm32f446xx only supports up to IRQ96)
			//program ISER3 register
			*NVIC_ISER3 |= (1 << (IRQNumber % 96));
		}

	} else {

		if(IRQNumber <= 31) { //0 to 31
			//program ICER0 register
			*NVIC_ICER0 |= (1 << IRQNumber);
		} else if(IRQNumber > 31 && IRQNumber < 64) { //IRQ 32 to 63
			//program ICER1 register
			*NVIC_ICER1 |= (1 << (IRQNumber % 32));
		} else if(IRQNumber >= 64 && IRQNumber < 96) { //IRQ 64 to 95
			//program ICER2 register
			*NVIC_ICER2 |= (1 << (IRQNumber % 64));
		} else if(IRQNumber >= 96 && IRQNumber < 128) { //IRQ 96 to 127 (stm32f446xx only supports up to IRQ96)
			//program ICER3 register
			*NVIC_ICER3 |= (1 << (IRQNumber % 96));
		}
	}
}

/* ******************************************************************************
 * @fn					-  GPIO_IRQPriorityConfig
 *
 * @brief				-  Configure IRQ priority
 *
 * @param[in]			-  IRQ number
 * @param[in]			-  IRQ priority
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void GPIO_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority) {

	//1. First calculate for the correct IPR register
	//IPRx registers are 32 bits wide, split into four sections of 1 Byte (8-bits): | IPRn || IRQ4n+3_PRI | IRQ4n+2_PRI | IRQ4n+1_PRI | IRQ4n_PRI |
	uint8_t iprx = (IRQNumber / 4);
	uint8_t iprx_section = (IRQNumber % 4);

	//Within each 8-bit (byte) IRQ4n_PRI field, only the upper 4 bits are implemented (4:7), while the lower 4 are not (0:3).
	uint8_t shift_amount = (8 * iprx_section) + (8 - NO_PR_BITS_IMPLEMENTED);

	*(NVIC_PR_BASE_ADDR + iprx) |= (IRQPriority << shift_amount);
}

/* ******************************************************************************
 * @fn					-  GPIO_IRQHandling
 *
 * @brief				-  Configure IRQ handler for GPIOx PINy
 *
 * @param[in]			-  GPIOx pin number
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void GPIO_IRQHandling(uint8_t PinNumber) {

	//clear the EXTI PR register corresponding to the pin number
	if(EXTI->PR & (1 << PinNumber)) {
		//clear
		EXTI->PR |= (1 << PinNumber);
	}
}


/****************************************************************************************/
							stm32f446xx_i2c_driver.c
/****************************************************************************************/	
/*
 * stm32f446xx_i2c_driver.c
 *
 *  Created on: Feb 19, 2021
 *      Author: Oliver
 */

/*
 * What is I2C?
 *
 * I2C is a protocol to achieve serial data communication between integrated circuits (ICs) which are very close to each other. It is a more serious
 * protocol than I2C because companies have come forward to design a specification for it.
 *
 * I2C protocol details (how data should be sent/received, how hand shaking should happen between sender and receiver, error handling) are more complex
 * than I2C.
 *
 * There is no dedicated spec for I2C but TI and Motorola have their own specs. I2C is based on a dedicated spec.
 *
 * I2C is multi-master capable, whereas I2C has no guidelines to achieve this, but depends on MCU designers. STM I2C peripherals can be used in multi-
 * master configurations but arbitration should be handled by software code.
 *
 * I2C hardware automatically ACKs every byte received. I2C does not support any automatic ACKing.
 *
 * I2C needs only 2 pins for communication while I2C may need 4 pins and even more if multiple slaves are involved.
 *
 * I2C master talks to slaves based on slave addresses, whereas I2C uses dedicated pins to select the slave.
 *
 * I2C is half duplex, while I2C is full duplex.
 *
 * For I2C, the max speed is 4MHz in ultra speed plus. For some STM microcontrollers, the max speed is just 400kHz. For I2C max speed, its Fpclk/2.
 * That means if the peripheral clock is 20MHz, then speed can be 10MHz.
 *
 * Slaves Control over Serial Clock:
 * In I2C, slave can make master wait by holding the clock down if its busy, thanks to clock stretching feature of I2C. But in I2C, slave has no control
 * over the clock, programmers may use their own tricks to overcome this situation.
 *
 * Data Rate:
 * Data Rate (number of bits transferred from sender to receiver in 1 sec) is much less compared to I2C.
 *
 * For example, in STM32F4x, if you have a peripheral clock of 40MHz, then with I2C you can only achieve data rate of 400Kbps compared with 20Mbps for I2C.
 *
 * SDA and SCL Signals:
 * Both SDA and SCL are bidirectional lines connected to a positive supply voltage via pullup resistors. When the bus is free, both lines are held high.
 * The output stages of devices connected to the bus must have an open-drain or open-collector configuration.
 * The bus capacitance limits the number of interfaces connected to the bus.
 *
 * I2C Modes:
 * Standard Mode		Up to 100Kbits/sec		Supported by STM32F4x
 * Fast Mode			Up to 400Kbits/sec		Supported by STM32F4x
 * Fast Mode+			Up to 1Mbits/sec		Supported by Some STM32F4x MCUs
 * High Speed Mode		Up to 3.4Mbits/sec		(not supported by F4x)
 *
 *	Start & Stop Conditions:
 *	All transactions begin with a Start(S) and are terminated by a STOP(P)
 *	A High to Low transition on the SDA line while SCL is High defines a Start condition
 *	A Low to High transition on the SDA line while SCL is High defines a Stop condition
 *
 *	The bus is considered to be busy after the START condition.
 *	The bus is considered to be free again a certain time after the STOP condition.
 *	When the bus is free another master (if present) may claim the bus.
 *	The bus stays busy if a repeated START is generated instead of a STOP condition.
 *	Most of the MCUs I2C peripherals support both master and slave mode. You need not to configure the mode because when the peripheral generates the
 *	start condition it automatically becomes the master and when it generates the stop condition it goes back to slave mode.
 *
 *	When Master gives ACK to slave, it means its ready to accept additional bytes. When Master sends NACK to slave, it indicates to slave to stop transmitting data.
 *
 *	Repeated Start Condition: (Sr) Start Again without Stop
 *	A master would do this to prevent another master from taking over the bus if it hasn't finished all communication.
 *	It is essentially a START, STOP, START without giving the chance for another master to take over in between those START conditions.
 *
 *	I2C1, I2C2, I2C3 are all on APB1 bus.
 *
 *	Required APIs:
 *	I2C Initialization
 *	I2C Master TX
 *	I2C Master RX
 *	I2C Slave TX
 *	I2C Slave RX
 *	I2C Error Interrupt Handling
 *	I2C Event Interrupt Handling
 *
 *	I2Cx Peripheral:
 *	I2C_SCLSpeed
 *	I2C_DeviceAddress
 *	I2C_ACKControl
 *	I2C_FMDutyCycle
 *
 *	Steps for I2C Init (Generic)
 *	1. Configure the Mode (standard or fast)
 *	2. Configure the speed of the serial clock (SCL)
 *	3. Configure the device address (applicable when device is slave)
 *	4. Enable the Acking
 *	5. Configure the rise time for I2C pins
 *
 *
 *	I2C Clock Stretching:
 *
 *	. Clock stretching simply means holding the clock to 0 or ground level.
 *	. The moment clock is held low, then the whole I2C interface pauses until clock is given up to its normal operation level.
 *	. I2C Devices, either master or slave, use clock stretching to slow down the communication by stretching SCL to low,
 *	  which prevents the clock to rise high again and the i2c communication stops for awhile.
 *		. There are situations where an I2C slave is not able to cooperate with the clock speed given by the master and needs to slow down a little.
 *		. If slave needs time, then it takes the advantage of clock stretching, and by holding clock at low, it pauses I2C operation.
 *
 *
 *
 *										I2C Interrupt Requests
 * 			Interrupt Event									Event Flag		Enable Control bit
 * Start bit sent (master)										SB				ITEVFEN
 * Address bit sent (master) or Address matched (slave)			ADDR			 ITEVFEN
 * 10-bit header sent (master)									ADD10			 ITEVFEN
 * Stop received (slave)										STOPF			 ITEVFEN
 * Data byte transfer finished									BTF				 ITEVFEN
 * Receive buffer not empty										RxNE			ITEVFEN and ITBUFEN
 * Transmit buffer empty										TxE				 ITEVFEN and ITBUFEN
 * Bus error													BERR			ITERREN
 * Arbitration loss (master)									ARLO			 ITERREN
 * Acknowledge failure											AF				 ITERREN
 * Overrun/Underrun												OVR				 ITERREN
 * PEC error													PECERR			 ITERREN
 * Timeout/Tlow error											TIMEOUT			 ITERREN
 * SMBusAlert													SMBALERT		 ITERREN
 *
 *		 				NVIC IRQn
 * I2Cx 	Event (I2Cx_EV_IRQ_LINE)	Error (I2Cx_ER_IRQ_LINE)
 * I2C1				31							32
 * I2C2				33							34
 * I2C3				72							73
 *
 * Bus Error:
 * 	This error happens when the interface detects an SDA rising or falling edge while SCL is high,
 * 	occurring in a non-valid position during a byte transfer.
 *
 * Arbitration Loss Error
 * 	This error can happen when the interface loses the arbitration of the bus to another master.
 *
 * ACK Failure Error
 * 	This error happens when no ACK is returned for the byte sent.
 *
 * Overrun Error
 * 	Happens during reception, when a new byte is received and the data register has not been
 * 	read yet and the new received byte is lost.
 *
 * Underrun Error
 * 	Happens when in transmission when a new byte should be sent and the data register has
 * 	not been written yet and the same byte is sent twice.
 *
 * PEC Error
 * 	Happens when there is CRC mismatch, if you have enabled the CRC feature
 *
 * Time-Out Error
 * 	Happens when master or slave stretches the clock, by holding it low more than the
 * 	recommended amount of time.
 *
 * BTF Flag in Tx and preventing underrun
 * 	During Txing of a data byte, if TXE=1, then that means data register is empty.
 * 	And if the firmware has not written any byte to data register before shift register becomes
 * 	empty (previous byte transmission), then BTF flag will be set and clock will be stretched
 * 	to prevent the underrun.
 *
 * BTF Flag in Rx and preventing overrun
 * 	If RXNE=1, then it means new data is waiting in the data register, and if the firmware
 * 	has not read the data byte yet before shift register is filled with another new data,
 * 	then also the BTF flag will be set and clock will be stretched to prevent the overrun.
 *
 * 	__Common Problems in I2C and Debugging Tips:__
 *
 * 	Problem   1: SDA and SCL line not held HIGH Voltage after I2C pin initialization
 * 	Reason    1: Not activating the pullup resistors if you are using the internal pullup resistor of an I/O line
 * 	Debug Tip 1: Worth checking the configuration register of an I/O line to see whether the pullups are really activated
 * 	           or not, best way is to dump the register contents.
 *
 * 	Problem   2: ACK failure
 * 	Reason    1: Generating the address with wrong slave address.
 * 	Debug Tip 1: Verify the slave address appearing on the SDA line by using a logic analyzer
 * 	Reason    2: Not enabling the ACKing feature in the I2C control register
 * 	Debug Tip 1: Cross check the I2C Control register ACK enable field
 *
 * 	Problem   3: Master is not producing the clock
 * 	Debug Tip 1: First check whether the I2C peripheral clock is enabled and set to at least 2MHz to produce
 * 				 standard mode I2C serial clock frequency
 *  Debug Tip 2: Check whether GPIOs which you used for SCL and SDA functionality are configured properly
 *   			 for alternate functionality.
 */

#include "stm32f446xx_i2c_driver.h"

static void I2C_GenerateStartCondition(I2C_RegDef_t *pI2Cx);
static void I2C_ExecuteAddressPhaseWrite(I2C_RegDef_t *pI2Cx, uint8_t SlaveAddr);
static void I2C_ExecuteAddressPhaseRead(I2C_RegDef_t *pI2Cx, uint8_t SlaveAddr);
static void I2C_ClearADDRFlag(I2C_Handle_t *pI2CHandle);
static void I2C_MasterHandleTXEInterrupt(I2C_Handle_t *pI2CHandle);
static void I2C_MasterHandleRXNEInterrupt(I2C_Handle_t *pI2CHandle);

/******************* Private Helper Functions *******************/
static void I2C_GenerateStartCondition(I2C_RegDef_t *pI2Cx) {

	pI2Cx->CR1 |= (1 << I2C_CR1_START);
}

static void I2C_ExecuteAddressPhaseWrite(I2C_RegDef_t *pI2Cx, uint8_t SlaveAddr) {

	SlaveAddr = SlaveAddr << 1;
	SlaveAddr &= ~(1); 	// the LSB is R/nW bit which must be set to 0 for WRITE
	pI2Cx->DR = SlaveAddr;
}

static void I2C_ExecuteAddressPhaseRead(I2C_RegDef_t *pI2Cx, uint8_t SlaveAddr) {

	SlaveAddr = SlaveAddr << 1;
	SlaveAddr |= 1;  	// the LSB is R/nW bit which must be set to 1 for READ
	pI2Cx->DR = SlaveAddr;
}

static void I2C_ClearADDRFlag(I2C_Handle_t *pI2CHandle) {

	uint32_t dummy_read;

	//check for device mode
	if(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_MSL)) {
		//device is in master mode
		if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX) {
			if(pI2CHandle->RxSize == 1) {
				//disable ACKing
				I2C_ManageAcking(pI2CHandle->pI2Cx, I2C_ACK_DISABLE);

				//clear the ADDR flag (read SR1, read SR2)
				dummy_read = pI2CHandle->pI2Cx->SR1;
				dummy_read = pI2CHandle->pI2Cx->SR2;
				(void)dummy_read;
			}
		} else {
			//clear the ADDR flag (read SR1, read SR2)
			dummy_read = pI2CHandle->pI2Cx->SR1;
			dummy_read = pI2CHandle->pI2Cx->SR2;
			(void)dummy_read;
		}
	} else {
		//device is in slave mode
		//clear the ADDR flag (read SR1, read SR2)
		dummy_read = pI2CHandle->pI2Cx->SR1;
		dummy_read = pI2CHandle->pI2Cx->SR2;
		(void)dummy_read;
	}
}

static void I2C_MasterHandleTXEInterrupt(I2C_Handle_t *pI2CHandle) {
	//Data transmission
	if(pI2CHandle->TxLen > 0) {
		//1. Load the data into DR
		pI2CHandle->pI2Cx->DR = *(pI2CHandle->pTxBuffer);

		//2. Decrement the TxLen
		pI2CHandle->TxLen--;

		//3. Increment the buffer address
		pI2CHandle->pTxBuffer++;
	}
}

static void I2C_MasterHandleRXNEInterrupt(I2C_Handle_t *pI2CHandle) {
	//Data reception
	if(pI2CHandle->RxSize == 1) {
		*pI2CHandle->pRxBuffer = pI2CHandle->pI2Cx->DR;
		pI2CHandle->RxLen--;
	}

	if(pI2CHandle->RxSize > 1) {
		if(pI2CHandle->RxLen == 2) {
			//clear the ACK bit
			I2C_ManageAcking(pI2CHandle->pI2Cx, I2C_ACK_DISABLE);
		}
		//read DR
		*pI2CHandle->pRxBuffer = pI2CHandle->pI2Cx->DR;
		pI2CHandle->pRxBuffer++;
		pI2CHandle->RxLen--;
	}

	if(pI2CHandle->RxLen == 0) {
		//close the I2C data reception and notify the application

		//1. Generate the stop condition
		if(pI2CHandle->SR == I2C_DISABLE_SR) {
			I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
		}

		//2. Close the I2C Rx
		I2C_CloseReception(pI2CHandle);

		//3. Notify the application
		I2C_ApplicationEventCallback(pI2CHandle, I2C_EV_RX_CMPLT);
	}
}

/* Peripheral Clock Setup */
/* ******************************************************************************
 * @fn					-  I2C_PClockControl
 *
 * @brief				-  This function enables or disables the peripheral clock
 * 						   for the given I2C peripheral.
 *
 * @param[in]			-  Base address of the I2C peripheral
 * @param[in]			-  ENABLE or DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void I2C_PClockControl(I2C_RegDef_t *pI2Cx, uint8_t State) {

	//Enable peripheral clock for specified I2C peripheral 1..3
	if(State == ENABLE) {

		if(pI2Cx == I2C1) {
			I2C1_PCLK_EN();
		} else if(pI2Cx == I2C2) {
			I2C2_PCLK_EN();
		} else if(pI2Cx == I2C3) {
			I2C3_PCLK_EN();
		}

	//Disable peripheral clock for specified I2C peripheral 1..3
	} else {

		if(pI2Cx == I2C1) {
			I2C1_PCLK_DI();
		} else if(pI2Cx == I2C2) {
			I2C2_PCLK_DI();
		} else if(pI2Cx == I2C3) {
			I2C3_PCLK_DI();
		}
	}
}


/* Initialization and Deinitialization */
/* ******************************************************************************
 * @fn					-  I2C_Init
 *
 * @brief				-  Initializes the I2C peripheral
 *
 * @param[in]			-  Base address of the I2C handle
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void I2C_Init(I2C_Handle_t *pI2CHandle) {

	uint32_t tempreg = 0;

	//enable the clock for the i2c peripheral
	I2C_PClockControl(pI2CHandle->pI2Cx, ENABLE);

	//1. ack control bit
	tempreg |= (pI2CHandle->I2C_Config.I2C_AckControl << 10);
	pI2CHandle->pI2Cx->CR1 = tempreg;

	//2. configure the FREQ field of CR2
	tempreg = 0;
	tempreg |= (RCC_GetPCLK1Value() / 1000000U);
	pI2CHandle->pI2Cx->CR2 = (tempreg & 0x3F); //mask all bits except the first 5 bits

	//3. program the device's own address (helpful if device is slave)
	tempreg = 0;
	tempreg |= (pI2CHandle->I2C_Config.I2C_DeviceAddress << 1);
	tempreg |= (1 << 14);
	pI2CHandle->pI2Cx->OAR1 = tempreg;

	//4. CCR calculations
	uint16_t ccr_value = 0;
	tempreg = 0;

	if(pI2CHandle->I2C_Config.I2C_SCLSpeed <= I2C_SCL_Speed_SM) {
		//standard mode
		ccr_value = (RCC_GetPCLK1Value() / (2 * pI2CHandle->I2C_Config.I2C_SCLSpeed)); //50% duty cycle
		tempreg |= (ccr_value & 0xFFF); //mask all bits except the first 12 bits
	} else {
		//fast mode
		tempreg |= (1 << 15);
		tempreg |= (pI2CHandle->I2C_Config.I2C_FMDutyCycle << 14);
		if(pI2CHandle->I2C_Config.I2C_FMDutyCycle == I2C_FM_DUTY_2) {
			ccr_value = (RCC_GetPCLK1Value() / (3 * pI2CHandle->I2C_Config.I2C_SCLSpeed)); //DUTY = 0
		} else {
			ccr_value = (RCC_GetPCLK1Value() / (25 * pI2CHandle->I2C_Config.I2C_SCLSpeed)); //DUTY = 1
		}
		tempreg |= (ccr_value & 0xFFF); //mask all bits except the first 12 bits
	}
	pI2CHandle->pI2Cx->CCR = tempreg;

	//5. TRISE
	if(pI2CHandle->I2C_Config.I2C_SCLSpeed <= I2C_SCL_Speed_SM) {
		//configure the trise in std mode
		tempreg = (RCC_GetPCLK1Value() / 1000000U) + 1;
	} else {
		//configure the trise in fast mode
		tempreg = ((RCC_GetPCLK1Value() * 300) / 1000000000U) + 1;
	}
	pI2CHandle->pI2Cx->TRISE = (tempreg & 0x3F);
}

/* ******************************************************************************
 * @fn					-  I2C_DeInit
 *
 * @brief				-  De-initializes the I2C peripheral
 *
 * @param[in]			-  Base address of the I2C peripheral
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void I2C_DeInit(I2C_RegDef_t *pI2Cx) {

	if(pI2Cx == I2C1) {
		I2C1_REG_RESET();
	} else if(pI2Cx == I2C2) {
		I2C2_REG_RESET();
	} else if(pI2Cx == I2C3) {
		I2C3_REG_RESET();
	}
}

/* Data Send and Receive */
/* ******************************************************************************
 * @fn					-  I2C_MasterSendData
 *
 * @brief				-  Send data over I2C bus from master
 *
 * @param[in]			-  Pointer to base address of the I2C Handle
 * @param[in]			-  Pointer to Tx buffer
 * @param[in]			-  Length of data to be sent
 * @param[in]			-  Address of slave device
 * @param[in]			-  I2C_SR or I2C_NO_SR macros (Repeated Start bits)
 *
 * @return				-  None
 *
 * @note				-  Polling based (blocking)
 *
 */
void I2C_MasterSendData(I2C_Handle_t *pI2CHandle, uint8_t *pTxBuffer, uint32_t Len, uint8_t SlaveAddress, uint8_t SR) {

	//1. Generate the START condition
	I2C_GenerateStartCondition(pI2CHandle->pI2Cx);

	//2. Confirm that start generation is completed by checking the SB flag in SR1
	//	 Note: Until SB is cleared, SCL will be stretched (pulled to LOW)
	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_SB));

	//3. Send the address of the slave with r/nw bit set to w(0) (total 8 bits)
	I2C_ExecuteAddressPhaseWrite(pI2CHandle->pI2Cx, SlaveAddress);

	//4. Confirm that address phase is completed by checking the ADDR flag in SR1
	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_ADDR));

	//5. Clear the ADDR flag according to its software sequence
	//	 Note: Until ADDR is cleared, SCL will be stretched (pulled to LOW)
	I2C_ClearADDRFlag(pI2CHandle);

	//6. Send the data until Len becomes 0
	while(Len > 0) {
		while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_FLAG_TXE)); //wait until TXE is set
		pI2CHandle->pI2Cx->DR = *pTxBuffer;
		pTxBuffer++;
		Len--;
	}

	//7. When Len becomes zero, wait for TXE=1 and BTF=1 before generating the STOP condition
	//   Note: TXE=1, BTF=1, means that both SR and DR are empty and next transmission should begin
	//   when BTF=1, SCL will be stretched (pulled to LOW)
	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_FLAG_TXE)); //wait until TXE is set
	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_FLAG_BTF)); //wait until BTF is set

	//8. Generate STOP condition and master need not to wait for the completion of stop condition.
	//	 Note: generating STOP, automatically clears the BTF.
	if(SR == I2C_DISABLE_SR) {
		I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
	}
}

/* ******************************************************************************
 * @fn					-  I2C_MasterReceiveData
 *
 * @brief				-  Receive data over I2C bus from slave
 *
 * @param[in]			-  Pointer to base address of the I2C Handle
 * @param[in]			-  Pointer to Rx buffer
 * @param[in]			-  Length of data to be read
 * @param[in]			-  Address of slave device
 * @param[in]			-  I2C_SR or I2C_NO_SR macros (Repeated Start bits)
 *
 * @return				-  None
 *
 * @note				-  Polling based (blocking)
 *
 */
void I2C_MasterReceiveData(I2C_Handle_t *pI2CHandle, uint8_t *pRxBuffer, uint8_t Len, uint8_t SlaveAddress, uint8_t SR) {

	//1. Generate the START condition
	I2C_GenerateStartCondition(pI2CHandle->pI2Cx);

	//2. Confirm that start generation is completed by checking the SB flag in SR1
	//	 Note: Until SB is cleared, SCL will be stretched (pulled to LOW)
	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_SB));

	//3. Send the address of the slave with r/nw bit set to R(1) (total 8 bits)
	I2C_ExecuteAddressPhaseRead(pI2CHandle->pI2Cx, SlaveAddress);

	//4. Wait until address phase is completed by checking the ADDR flag in SR1
	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_ADDR));

	//Procedure to read only 1 byte from slave
	if(Len == 1) {
		//Disable ACKing
		I2C_ManageAcking(pI2CHandle->pI2Cx, I2C_ACK_DISABLE);

		//Clear the Addr flag
		I2C_ClearADDRFlag(pI2CHandle);

		//Wait until RXNE=1
		while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_FLAG_RXNE));

		//Generate STOP condition
		if(SR == I2C_DISABLE_SR) {
			I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
		}

		//Read data into buffer
		*pRxBuffer = pI2CHandle->pI2Cx->DR;
	}

	//Procedure to read data from slave when Len > 1
	if(Len > 1) {
		//Clear the Addr flag
		I2C_ClearADDRFlag(pI2CHandle);

		//Read the data until Len becomes zero
		for(uint32_t i = Len; i > 0; i--) {

			//Wait until RXNE=1
			while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx,I2C_FLAG_RXNE));

			if(i == 2) { //If last 2 bytes are remaining
				//Clear the ACK bit
				I2C_ManageAcking(pI2CHandle->pI2Cx, I2C_ACK_DISABLE);

				//Generate STOP condition
				if(SR == I2C_DISABLE_SR) {
					I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
				}
			}
			//Read the data from data register into buffer
			*pRxBuffer = pI2CHandle->pI2Cx->DR;

			//Increment the buffer address
			pRxBuffer++;
		}
	}

	//Re-enable ACKing
	if(pI2CHandle->I2C_Config.I2C_AckControl == I2C_ACK_ENABLE) {
		I2C_ManageAcking(pI2CHandle->pI2Cx, I2C_ACK_ENABLE);
	}
}

/* ******************************************************************************
 * @fn					-  I2C_MasterSendDataIT
 *
 * @brief				-  Send data over I2C bus from master (IT)
 *
 * @param[in]			-  Pointer to base address of the I2C Handle
 * @param[in]			-  Pointer to Rx buffer
 * @param[in]			-  Length of data to be read
 * @param[in]			-  Address of slave device
 * @param[in]			-  I2C_SR or I2C_NO_SR macros (Repeated Start bits)
 *
 * @return				-  Busy state
 *
 * @note				-  Interrupt based (non-blocking)
 *
 */
uint8_t I2C_MasterSendDataIT(I2C_Handle_t *pI2CHandle, uint8_t *pTxBuffer, uint32_t Len, uint8_t SlaveAddress, uint8_t SR) {

	uint8_t busystate = pI2CHandle->TxRxState;

	if((busystate != I2C_BUSY_IN_TX) && (busystate != I2C_BUSY_IN_RX)) {
		pI2CHandle->pTxBuffer = pTxBuffer;
		pI2CHandle->TxLen = Len;
		pI2CHandle->TxRxState = I2C_BUSY_IN_TX;
		pI2CHandle->DevAddr = SlaveAddress;
		pI2CHandle->SR = SR;

	//Generate START Condition
		I2C_GenerateStartCondition(pI2CHandle->pI2Cx);

	//Enable ITBUFEN Control Bit
		pI2CHandle->pI2Cx->CR2 |= (1 << I2C_CR2_ITBUFEN);

	//Enable ITEVTEN Control Bit
		pI2CHandle->pI2Cx->CR2 |= (1 << I2C_CR2_ITEVTEN);

	//Enable ITERREN Control Bit
		pI2CHandle->pI2Cx->CR2 |= (1 << I2C_CR2_ITERREN);
	}

	return busystate;
}

/* ******************************************************************************
 * @fn					-  I2C_MasterReceiveDataIT
 *
 * @brief				-  Receive data over I2C bus from slave (IT)
 *
 * @param[in]			-  Pointer to base address of the I2C Handle
 * @param[in]			-  Pointer to Rx buffer
 * @param[in]			-  Length of data to be read
 * @param[in]			-  Address of slave device
 * @param[in]			-  I2C_SR or I2C_NO_SR macros (Repeated Start bits)
 *
 * @return				-  Busy state
 *
 * @note				-  Interrupt based (non-blocking)
 *
 */
uint8_t I2C_MasterReceiveDataIT(I2C_Handle_t *pI2CHandle, uint8_t *pRxBuffer, uint8_t Len, uint8_t SlaveAddress, uint8_t SR) {
	//try uint8_t Len argument

	uint8_t busystate = pI2CHandle->TxRxState;

	if((busystate != I2C_BUSY_IN_TX) && (busystate != I2C_BUSY_IN_RX)) {
		pI2CHandle->pRxBuffer = pRxBuffer;
		pI2CHandle->RxLen = Len;
		pI2CHandle->TxRxState = I2C_BUSY_IN_RX;
		pI2CHandle->RxSize = Len;	//RxSize is used in the ISR code to manage the data reception
		pI2CHandle->DevAddr = SlaveAddress;
		pI2CHandle->SR = SR;

	//Generate START Condition
		I2C_GenerateStartCondition(pI2CHandle->pI2Cx);

	//Enable ITBUFEN Control Bit
		pI2CHandle->pI2Cx->CR2 |= (1 << I2C_CR2_ITBUFEN);

	//Enable ITEVTEN Control Bit
		pI2CHandle->pI2Cx->CR2 |= (1 << I2C_CR2_ITEVTEN);

	//Enable ITERREN Control Bit
		pI2CHandle->pI2Cx->CR2 |= (1 << I2C_CR2_ITERREN);
	}

	return busystate;
}

/* ******************************************************************************
 * @fn					-  I2C_CloseTransmission
 *
 * @brief				-  End I2C transmission
 *
 * @param[in]			-  Pointer to I2C handle
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void I2C_CloseTransmission(I2C_Handle_t *pI2CHandle) {

	//Disable ITBUFEN Control Bit
	pI2CHandle->pI2Cx->CR2 &= ~(1 << I2C_CR2_ITBUFEN);

	//Disable ITEVTEN Control Bit
	pI2CHandle->pI2Cx->CR2 &= ~(1 << I2C_CR2_ITEVTEN);

	pI2CHandle->TxRxState = I2C_READY;
	pI2CHandle->pTxBuffer = NULL;
	pI2CHandle->TxLen = 0;
}

/* ******************************************************************************
 * @fn					-  I2C_CloseReception
 *
 * @brief				-  End I2C reception
 *
 * @param[in]			-  Pointer to I2C handle
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void I2C_CloseReception(I2C_Handle_t *pI2CHandle) {

	//Disable ITBUFEN Control Bit
	pI2CHandle->pI2Cx->CR2 &= ~(1 << I2C_CR2_ITBUFEN);

	//Disable ITEVTEN Control Bit
	pI2CHandle->pI2Cx->CR2 &= ~(1 << I2C_CR2_ITEVTEN);

	pI2CHandle->TxRxState = I2C_READY;
	pI2CHandle->pRxBuffer = NULL;
	pI2CHandle->RxLen = 0;
	pI2CHandle->RxSize = 0;

	if(pI2CHandle->I2C_Config.I2C_AckControl == I2C_ACK_ENABLE) {
		I2C_ManageAcking(pI2CHandle->pI2Cx, I2C_ACK_ENABLE);
	}
}

/* ******************************************************************************
 * @fn					-  I2C_SlaveSendData
 *
 * @brief				-  Send data over I2C bus from slave
 *
 * @param[in]			-  Base address of the I2C peripheral
 * @param[in]			-  Data byte to be sent
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void I2C_SlaveSendData(I2C_RegDef_t *pI2Cx, uint8_t data) {

	pI2Cx->DR = data;
}

/* ******************************************************************************
 * @fn					-  I2C_SlaveReceiveData
 *
 * @brief				-  Receive data over I2C bus from master
 *
 * @param[in]			-  Base address of the I2C peripheral
 *
 * @return				-  Data byte received
 *
 * @note				-  None
 *
 */
uint8_t I2C_SlaveReceiveData(I2C_RegDef_t *pI2Cx) {

	return (uint8_t)pI2Cx->DR;
}

/* IRQ Configuration, Priority and ISR Handling */
/* ******************************************************************************
 * @fn					-  I2C_IRQInterruptConfig
 *
 * @brief				-  Configure interrupt request (IRQx)
 *
 * @param[in]			-  IRQ number
 * @param[in]			-  ENABLE or DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void I2C_IRQInterruptConfig(uint8_t IRQNumber, uint8_t State) {

	if(State == ENABLE) {

		if(IRQNumber <= 31) { //IRQ 0 to 31
			//program ISER0 register
			*NVIC_ISER0 |= (1 << IRQNumber);

		} else if(IRQNumber > 31 && IRQNumber < 64) { //IRQ 32 to 63
			//program ISER1 register
			*NVIC_ISER1 |= (1 << (IRQNumber % 32));

		} else if(IRQNumber >= 64 && IRQNumber < 96) { //IRQ 64 to 95
			//program ISER2 register
			*NVIC_ISER2 |= (1 << (IRQNumber % 64));

		} else if(IRQNumber >= 96 && IRQNumber < 128) { //IRQ 96 to 127 (stm32f446xx only supports up to IRQ96)
			//program ISER3 register
			*NVIC_ISER3 |= (1 << (IRQNumber % 96));
		}

	} else {

		if(IRQNumber <= 31) { //0 to 31
			//program ICER0 register
			*NVIC_ICER0 |= (1 << IRQNumber);

		} else if(IRQNumber > 31 && IRQNumber < 64) { //IRQ 32 to 63
			//program ICER1 register
			*NVIC_ICER1 |= (1 << (IRQNumber % 32));

		} else if(IRQNumber >= 64 && IRQNumber < 96) { //IRQ 64 to 95
			//program ICER2 register
			*NVIC_ICER2 |= (1 << (IRQNumber % 64));

		} else if(IRQNumber >= 96 && IRQNumber < 128) { //IRQ 96 to 127 (stm32f446xx only supports up to IRQ96)
			//program ICER3 register
			*NVIC_ICER3 |= (1 << (IRQNumber % 96));
		}
	}
}

/* ******************************************************************************
 * @fn					-  I2C_IRQPriorityConfig
 *
 * @brief				-  Configure IRQ priority
 *
 * @param[in]			-  IRQ number
 * @param[in]			-  IRQ priority
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void I2C_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority) {

	//1. First calculate for the correct IPR register
	//IPRx registers are 32 bits wide, split into four sections of 1 Byte (8-bits): | IPRn || IRQ4n+3_PRI | IRQ4n+2_PRI | IRQ4n+1_PRI | IRQ4n_PRI |
	uint8_t iprx = (IRQNumber / 4);
	uint8_t iprx_section = (IRQNumber % 4);

	//Within each 8-bit (byte) IRQ4n_PRI field, only the upper 4 bits are implemented (4:7), while the lower 4 are not (0:3).
	uint8_t shift_amount = (8 * iprx_section) + (8 - NO_PR_BITS_IMPLEMENTED);

	*(NVIC_PR_BASE_ADDR + iprx) |= (IRQPriority << shift_amount);
}

/* ******************************************************************************
 * @fn					-  I2C_EV_IRQHandling
 *
 * @brief				-  Configure I2C Event IRQ Handling
 *
 * @param[in]			-  Pointer to base address of the I2C Handle
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void I2C_EV_IRQHandling(I2C_Handle_t *pI2CHandle) {

	//Interrupt handling for both master and slave mode of a device
	uint32_t temp1, temp2, temp3;

	temp1 = pI2CHandle->pI2Cx->CR2 & (1 << I2C_CR2_ITEVTEN);
	temp2 = pI2CHandle->pI2Cx->CR2 & (1 << I2C_CR2_ITBUFEN);

	//1. Handle for interrupt generated by SB event
	//	Note: SB flag is only applicable in Master mode
	temp3 = pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_SB);
	if(temp1 && temp3) {
		//The interrupt is generated because of SB event
		//This block will not be executed in slave mode because SB is always 0
		//In this block lets execute the address phase
		if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX) {
			I2C_ExecuteAddressPhaseWrite(pI2CHandle->pI2Cx, pI2CHandle->DevAddr);
		} else if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX) {
			I2C_ExecuteAddressPhaseRead(pI2CHandle->pI2Cx, pI2CHandle->DevAddr);
		}
	}

	//2. Handle for interrupt generated by ADDR event
	// 	Note: When master mode:	address is sent
	//		  When slave mode: address matched with own address
	temp3 = pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_ADDR);
	if(temp1 && temp3) {
		//The interrupt is generated because of ADDR event
		I2C_ClearADDRFlag(pI2CHandle);
	}

	//3. Handle for interrupt generated by BTF (Byte Transfer Finished) event
	temp3 = pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_BTF);
	if(temp1 && temp3) {
		//BTF flag is set
		if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX) {
			//make sure that TXE is also set
			if(pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_TXE)) {
				//BTF,TXE = 1

				if(pI2CHandle->TxLen == 0) {
					//Len = 0

					//1. generate the STOP condition
					if(pI2CHandle->SR == I2C_DISABLE_SR) {
						I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
					}

					//2. reset all of the member elements of the handle structure
					I2C_CloseTransmission(pI2CHandle);

					//3. notify the application about completed transmission
					I2C_ApplicationEventCallback(pI2CHandle, I2C_EV_TX_CMPLT);
				}
			}

		} else if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX) {
			//Do nothing because I2C is Busy in Rx
			;
		}
	}

	//4. Handle for interrupt generated by STOPF event
	//	Note: Stop detection flag is applicable only in slave mode. For master,
	//		  this flag will never be set.
	temp3 = pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_STOPF);
	if(temp1 && temp3) {
		//STOPF flag is set
		//Clear the STOPF ( i.e. 1. Read from SR1 | 2. Write to CR1 )
		pI2CHandle->pI2Cx->CR1 |= 0x0000;

		//notify the application that STOP is detected
		I2C_ApplicationEventCallback(pI2CHandle, I2C_EV_STOP);
	}

	//5. Handle for interrupt generated by TXE event
	temp3 = pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_TXE);
	if(temp1 && temp2 && temp3) {
		//check for device mode
		if(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_MSL)) {
			//device is in master mode
			//TXE flag is set
			if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX) {
				I2C_MasterHandleTXEInterrupt(pI2CHandle);
			}
		} else {
			//slave
			//make sure slave is really in transmitter mode
			if(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_TRA)) {
				I2C_ApplicationEventCallback(pI2CHandle, I2C_EV_DATA_REQ);
			}
		}
	}

	//6. Handle for interrupt generated by RXNE event
	temp3 = pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_RXNE);
	if(temp1 && temp2 && temp3) {
		//check for device mode
		if(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_MSL)) {
			//device is in master mode
			//RXNE flag is set
			if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX) {
				I2C_MasterHandleRXNEInterrupt(pI2CHandle);
			}
		} else {
			//slave
			//make sure the slave is really in receiver mode
			if(!(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_TRA))) {
				I2C_ApplicationEventCallback(pI2CHandle, I2C_EV_DATA_RCV);
			}
		}
	}
}

/* ******************************************************************************
 * @fn					-  I2C_ER_IRQHandling
 *
 * @brief				-  Configure I2C Error IRQ Handling
 *
 * @param[in]			-  Pointer to base address of the I2C Handle
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void I2C_ER_IRQHandling(I2C_Handle_t *pI2CHandle) {

	uint32_t temp1, temp2;

	//Know the status of ITERREN control bit in CR2
	temp2 = (pI2CHandle->pI2Cx->CR2) & (1 << I2C_CR2_ITERREN);

	/***********************Check for Bus error************************************/
	temp1 = (pI2CHandle->pI2Cx->SR1) & (1 << I2C_SR1_BERR);
	if(temp1 && temp2) {
		//Bus error (BERR)
		//Clear bus error flag
		pI2CHandle->pI2Cx->SR1 &= ~(1 << I2C_SR1_BERR);

		//notify application about the error
		I2C_ApplicationEventCallback(pI2CHandle, I2C_ERROR_BERR);
	}
	/***********************Check for Arbitration Lost error************************/
	temp1 = (pI2CHandle->pI2Cx->SR1) & (1 << I2C_SR1_ARLO);
	if(temp1 && temp2) {
		//Arbitration lost error (ARLO)
		//Clear ARLO flag
		pI2CHandle->pI2Cx->SR1 &= ~(1 << I2C_SR1_ARLO);

		//notify application about the error
		I2C_ApplicationEventCallback(pI2CHandle, I2C_ERROR_ARLO);
	}
	/***********************Check for ACK Failure error******************************/
	temp1 = (pI2CHandle->pI2Cx->SR1) & (1 << I2C_SR1_AF);
	if(temp1 && temp2) {
		//ACK failure error (AF)
		//Clear AF flag
		pI2CHandle->pI2Cx->SR1 &= ~(1 << I2C_SR1_AF);

		//notify application about the error
		I2C_ApplicationEventCallback(pI2CHandle, I2C_ERROR_AF);
	}
	/***********************Check for Overrun/Underrun error*************************/
	temp1 = (pI2CHandle->pI2Cx->SR1) & (1 << I2C_SR1_OVR);
	if(temp1 && temp2) {
		//Overrun/Underrun error (OVR)
		//Clear OVR flag
		pI2CHandle->pI2Cx->SR1 &= ~(1 << I2C_SR1_OVR);

		//notify application about the error
		I2C_ApplicationEventCallback(pI2CHandle, I2C_ERROR_OVR);
	}
	/***********************Check for Time Out error**********************************/
	temp1 = (pI2CHandle->pI2Cx->SR1) & (1 << I2C_SR1_TIMEOUT);
	if(temp1 && temp2) {
		//Time Out error (TIMEOUT)
		//Clear TIMEOUT flag
		pI2CHandle->pI2Cx->SR1 &= ~(1 << I2C_SR1_TIMEOUT);

		//notify application about the error
		I2C_ApplicationEventCallback(pI2CHandle, I2C_ERROR_TIMEOUT);
	}
}

/* Other Peripheral Control APIs */
/* ******************************************************************************
 * @fn					-  I2C_PeripheralControl
 *
 * @brief				-  Enable or disable I2Cx peripheral
 *
 * @param[in]			-  Base address of the I2C peripheral
 * @param[in]			-  ENABLE or DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx, uint8_t State) {

	if(State == ENABLE) {
 		pI2Cx->CR1 |= (1 << I2C_CR1_PE);
 		//pI2CBaseAddress->CR1 |= I2C_CR1_PE_Bit_Mask;
 	} else {
 		pI2Cx->CR1 &= ~(1 << 0);
	}
}

/* ******************************************************************************
 * @fn					-  I2C_GetFlagStatus
 *
 * @brief				-  Retrieve flag status of I2C peripheral
 *
 * @param[in]			-  Base address of the I2C peripheral
 * @param[in]			-  Flag name
 *
 * @return				-  Byte containing flag status info
 *
 * @note				-  None
 *
 */
uint8_t I2C_GetFlagStatus(I2C_RegDef_t *pI2Cx, uint32_t FlagName) {

	if(pI2Cx->SR1 & FlagName) {
		return FLAG_SET;
	}

	return FLAG_RESET;
}

/* ******************************************************************************
 * @fn					-  I2C_ManageAcking
 *
 * @brief				-  Enable or Disable ACKing
 *
 * @param[in]			-  Base address of the I2C peripheral
 * @param[in]			-  I2C_ACK_ENABLE or I2C_ACK_DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void I2C_ManageAcking(I2C_RegDef_t *pI2Cx, uint8_t State) {

	if(State == I2C_ACK_ENABLE) {
		//enable the ACK
		pI2Cx->CR1 |= (1 << I2C_CR1_ACK);
	} else {
		//disable the ACK
		pI2Cx->CR1 &= ~(1 << I2C_CR1_ACK);
	}
}

/* ******************************************************************************
 * @fn					-  I2C_GenerateStopCondition
 *
 * @brief				-  Generate STOP condition for I2C bus
 *
 * @param[in]			-  Base address of the I2C peripheral
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void I2C_GenerateStopCondition(I2C_RegDef_t *pI2Cx) {

	pI2Cx->CR1 |= (1 << I2C_CR1_STOP);
}

/* ******************************************************************************
 * @fn					-  I2C_SlaveEnableDisableCallbackEvents
 *
 * @brief				-  Enable or Disable Callback Events
 *
 * @param[in]			-  Base address of the I2C peripheral
 * @param[in]			-  ENABLE or DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void I2C_SlaveEnableDisableCallbackEvents(I2C_RegDef_t *pI2Cx, uint8_t State) {

	if(State == ENABLE) {
		pI2Cx->CR2 |= (1 << I2C_CR2_ITEVTEN);
		pI2Cx->CR2 |= (1 << I2C_CR2_ITBUFEN);
		pI2Cx->CR2 |= (1 << I2C_CR2_ITERREN);
	} else {
		pI2Cx->CR2 &= ~(1 << I2C_CR2_ITEVTEN);
		pI2Cx->CR2 &= ~(1 << I2C_CR2_ITBUFEN);
		pI2Cx->CR2 &= ~(1 << I2C_CR2_ITERREN);
	}
}

/* Application Callback */
/* ******************************************************************************
 * @fn					-  I2C_ApplicationEventCallback
 *
 * @brief				-  Application Event Callback (weak implementation)
 *
 * @param[in]			-  Pointer to I2C handle
 * @param[in]			-  Application event byte
 *
 * @return				-  None
 *
 * @note				-  Weak implementation
 *
 */
__weak void I2C_ApplicationEventCallback(I2C_Handle_t *pI2CHandle, uint8_t AppEv) {

	//This is a weak implementation -- the application may override this function.
}

/****************************************************************************************/
							stm32f446xx_rcc_driver.c
/****************************************************************************************/	
/*
 * stm32f446xx_rcc_driver.c
 *
 *  Created on: Mar 10, 2021
 *      Author: Oliver
 */

#include "stm32f446xx_rcc_driver.h"

uint16_t AHB_PreScaler[8] = {2,4,8,16,64,128,256,512};
uint8_t APB1_PreScaler[4] = {2,4,8,16};



/*********************************************************************
 * @fn      		  - RCC_GetPCLK1Value
 *
 * @brief             - Returns the APB1 clock value
 *
 * @param[in]         - N/A
 *
 * @return            - APB1 clock value
 *
 * @Note              -
 */
uint32_t RCC_GetPCLK1Value(void) {

	uint32_t pclk1, SystemClk;
	uint8_t clksrc, temp, ahbp, apb1p;

	clksrc = ((RCC->CFGR >> 2) & 0x3);

	if(clksrc == 0) {
		SystemClk = 16000000;
	} else if(clksrc == 1) {
		SystemClk = 8000000;
	} else if(clksrc == 2) {
		SystemClk = RCC_GetPLLOutputClock();
	}

	//for AHB
	temp = ((RCC->CFGR >> 4) & 0xF);

	if(temp < 8) {
		ahbp = 1;
	} else {
		ahbp = AHB_PreScaler[temp - 8];
	}

	//for APB1
	temp = ((RCC->CFGR >> 10) & 0x7);

	if(temp < 4) {
		apb1p = 1;
	} else {
		apb1p = APB1_PreScaler[temp - 4];
	}

	pclk1 = ((SystemClk / ahbp) / apb1p);

	return pclk1;
}

/*********************************************************************
 * @fn      		  - RCC_GetPCLK2Value
 *
 * @brief             - Returns the APB2 clock value
 *
 * @param[in]         - N/A
 *
 * @return            - APB2 clock value
 *
 * @Note              -
 */
uint32_t RCC_GetPCLK2Value(void) {

	uint32_t SystemClock = 0, tmp, pclk2;
	uint8_t clk_src = (RCC->CFGR >> 2) & 0x3;

	uint8_t ahbp, apb2p;

	if(clk_src == 0) {
		SystemClock = 16000000;
	} else {
		SystemClock = 8000000;
	}

	tmp = (RCC->CFGR >> 4) & 0xF;
	if(tmp < 0x08) {
		ahbp = 1;
	} else {
		ahbp = AHB_PreScaler[tmp - 8];
	}

	tmp = (RCC->CFGR >> 13) & 0x7;
	if(tmp < 0x04) {
		apb2p = 1;
	} else {
		apb2p = APB1_PreScaler[tmp - 4];
	}
	pclk2 = ((SystemClock / ahbp) / apb2p);

	return pclk2;
}

/*********************************************************************
 * @fn      		  - RCC_GetPLLOutputClock
 *
 * @brief             - Returns the PLL Output clock value
 *
 * @param[in]         - N/A
 *
 * @return            - PLL Output clock value
 *
 * @Note              - <WORK IN PROGRESS>
 */
uint32_t RCC_GetPLLOutputClock(void) {

	return 0;
}

/****************************************************************************************/
							stm32f446xx_spi_driver.c
/****************************************************************************************/	
/*
 * stm32f446xx_spi_driver.c
 *
 *  Created on: Feb 5, 2021
 *      Author: Oliver
 */

/*	Notes:
 *
 * 				Serial Peripheral Interface
 *
 * 	The SPI bus allows the communication between one master device and one or more slave devices:
 *
 * 				SCLK -----------------> SCLK
 * 	Master		MOSI -----------------> MOSI		Slave
 * 				MISO <----------------- MISO	(Sensor, EEPROM, SDCARD,
 * 				gpio1-----------------> šš		 Display, Bluetooth, etc)
 *
 *	Serial Clock, Master Out Slave In, Master In Slave Out, Slave Select.
 *
 *	1. Four I/O pins are dedicated to SPI communication with external devices.
 *	2. MISO: Master In / Slave Out data. In the general case, this pin is used to transmit data
 *	   in slave mode and receive data in master mode.
 *	3. MOSI: Master Out / Slave In data. In general case, this pin is used to transmit data
 *	   in master mode, and receive data in slave mode.
 *	4. SCK: Serial Clock output pin for SPI master and input pin for SPI slaves.
 *	5. NSS: Slave select pin. Depending on the SPI and NSS settings, this pin can be
 *	   used to select an individual slave device for communication.
 *
 *
 *	SPI advantages:  higher speed than I2C, simpler
 *		disadvantages: low distance (10ft), more pins used.
 *
 *	RS-485 (4000ft max distance)
 *
 *	SPI/I2C communicate over TTL signaling in range of 0-5V.
 *	CAN/RS-485 communicate over differential signaling (>10V).
 *	This is a reason why SPI and I2C are short distance communication interfaces.
 *
 *
 *	Protocol	Type					Max Distance (ft)				Max Speed (bps)			Typical Usage
 *	USB3.0		Dual Simplex Serial		9ft (up to 49 with 5 hubs)   	5G						Mass storage, video
 *	USB2.0		Half Duplex Serial		16ft (98ft with 5 hubs)			1.5M,12M,480M			Keyboard, Mouse, Drive, speakers, printer, camera
 *	Ethernet	Serial					1600ft							10G						Network Communications
 *	I2C			Synchronous Serial		18ft							3.4M (high-speed mode)	Microcontroller communications
 *	RS-232		Asynchronous Serial		50-100ft						20k						Modem, Mouse, Instrumentation
 *	RS-485		Asynchronous Serial		4000ft							10M						Data Acquisition, control systems SPI
 *	SPI			Synchronous Serial		10ft							fPCLK/2					Sensors, EEPROM, Flash, Display
 *
 *
 *	To use slave select, Master must use a GPIO pin and pull 'ss' to ground for slave to activate MOSI,MISO pins and take them out of High-Z state.
 *
 *	Minimal SPI Bus configuration:
 *	The SPI bus allows the communication between one master device and one or more slave devices. In some applications SPI bus may consist of just two wires -
 *	one for the clock signal and the other for synchronous data transfer. Other signals can be added depending on the data exchange between SPI nodes and their
 *	slave select signal management.
 *
 *	SPI Hardware - Behind the Scenes:
 *	SPI protocol uses Shift Registers on both Master and Slave side for communication.
 *	MOSI connects the LSB of Master's shift register with MSB of Slave's shift register.
 *	MISO connects the LSB of Slave's shift register with the MSB of Master's shift register.
 *	Every clock cycle, both shift registers will right-shift by 1 bit. This means the  LSB of Master will be pushed to MSB of Slave, and
 *	LSB of Slave will be pushed to MSB of Master simultaneously.
 *
 *						(After 1 Clock Cycle)
 *	  ->[B0,A7,A6,A5,A4,A3,A2,A1] -MOSI-> [A0,B7,B6,B5,B4,B3,B2,B1] -
 *	 |			Master			   					Slave			 |
 *    -----------------------------MISO------------------------------
 *
 *
 *   Customizing SPI Bus: Bus Configurations
 *   The SPI allows the MCU to communicate using different configurations, depending on the device targeted and the app requirements.
 *
 *   Full-Duplex Communication:
 *   In this config, the shift registers of the master and slave are linked using two unidirectional lines between the MOSI and the MISO pins.
 *   During SPI communication, data is shifted synchronously on the SCK clock edges provided by the master. The master transmits the data to be sent
 *   to the slave via the MOSI line and receives data from the slave via the MISO line. By default, the SPI is configured for Full-Duplex Communication.
 *   (Up to 16-bit shift registers on both sides).
 *
 *   Half-Duplex Communication:
 *   In this configuration, one single cross connection line is used to link the shift registers of the master and slave together. During this communication,
 *   the data is synchronously shifted between the shift registers on the SCK clock edge in the transfer direction selected reciprocally by both master and slave.
 *   MOSI of master has to be connected to MISO of slave here. NSS optional if only one slave. Master would be set up as transmit mode, slave as receiver mode, or vice versa.
 *   (Up to 8-bit shift registers on both sides)
 *
 *	 Simplex Communication:
 *	 Simplex single master, single slave application (master in transmit-only/slave in receive-only mode)
 *	 Transmit-only, receive-only mode:
 *	 The configuration settings are the same as for full-duplex. The application has to ignore the information captured on the unused input pin.
 *	 This pin can be used as a standard GPIO.
 *
 *		Slave Select (NSS) Pin Management
 *	When a device is in slave mode:
 *	In slave mode, the NSS works as a standard 'chip select' input and lets the slave communicate with the master.
 *
 *	When a device is a master:
 *	In master mode, NSS can be used either as output or input. As an input, it can prevent multi-master bus collision, and as an output it can
 *	drive a slave select signal of a single slave.
 *
 *	2 Types of Slave Management:
 *		Hardware or software slave management can be set using the SSM bit in the SPIx_CR1 register.
 *
 *	Hardware Slave Management
 *		Hardware NSS management (SSM=0): NSS pin must be pulled low to activate slave to communicate with master. NSS pin must be in output mode.
 *		The NSS pin is managed by the hardware.
 *
 *	Software Slave Management
 *		Software NSS management (SSM=1): in this configuration, slave select information is driven internally by the SSI bit value in register
 *		SPIx_CR1. The external NSS pin is free for other application uses.
 *
 *
 *
 *	Points to Remember:
 *	Scenario 1: 1 Master 1 Slave
 *		1) You dont need to use NSS pin of master and slave if you use software slave management.
 *		2) If you dont want to use software slave management, then you can connect NSS of master to NSS of slave.
 *
 *	Scenario2: 1 master and multiple slaves
 *		1) You cannot use software slave management here.
 *		2) You cannot use NSS pin of the master to connect NSS pin of any of the slaves.
 *		3) Master has to use some of its GPIO pins to control the different NSS pins of the slaves.
 *
 *
 *
 *	SPI Communication Format
 *	SCLK Phase (CPHA), SCLK Polarity (CPOL), Data Frame Format (DFF)
 *
 *	. During SPI communication, receive and transmit operations are performed simultaneously.
 *	. The serial clock (SCK) synchronizes the shifting and sampling of the information on the data lines.
 *	. The communication format depends on the clock phase, the clock polarity and the data frame format.
 *	  To be able to communicate together, the master and slaves devices must follow the same communication format.
 *
 *	CPOL(Clock Polarity)
 *	> The CPOL (clock polarity) bit controls the idle state value of the clock when no data is being transferred.
 *	> If CPOL is reset, the SCLK pin has a low-level idle state. If CPOL is set, the SCLK pin has a high-level idle state.
 *
 *	CPHA(Clock Phase)
 *	> CPHA controls at which clock edge of the SCLK(1st or 2nd) the data should be sampled by the slave.
 *	> The combination of CPOL (clock polarity) and CPHA (clock phase) bits selects the data capture clock edge.
 *
 *	4 Different SPI modes:
 *	SPI mode 0: CPOL = 0, CPHA = 0
 *	SPI mode 1: CPOL = 0, CPHA = 1
 *	SPI mode 2: CPOL = 1, CPHA = 0
 *	SPI mode 3: CPOL = 1, CPHA = 1
 *
 *	If CPHA = 1, Data will be sampled on the Trailing Edge of the clock
 *	If CPHA = 0, Data will be sampled on the Leading Edge of the clock
 *
 *	Slave samples on MOSI and Master samples on MISO
 *
 *	What is the maximum SCLK speed of SPIx peripheral which can be achieved on a given microcontroller?
 *	> First you have to know the speed of the APBx bus on which the SPI peripheral is connected.
 *
 *	By default, the clock signal is sourced from HSI signal (16MHZ) (other choices are HSE or PLL signals) and the APB1 bus prescalar is set to 1. The APB1 bus can support
 *	a maximum clock speed of 42MHz. Then we have: f_pclk = 16MHz -> SPI2/SPI3 (on APB1 bus) -> min SPI prescalar = 2 -> SCLK = 8MHZ
 *
 *	Note: SPI1 peripheral is hanging on APB2 bus (84MHz max speed -- 2x APB1 bus!), while SPI2/3 are on APB1 bus.
 *
 *	So, if we use the internal RC oscillator of 16MHz as our system clock, then SPI1/SPI2/SPI3 peripherals can produce the serial clock of 8MHz maximum.
 *
 *	SPI Driver API Requirements:
 *		. SPI initialization / peripheral clock control
 *		. SPI Tx
 *		. SPI Rx
 *		. SPI Interrupt Config & Handling
 *		. Other SPI Management APIs
 *
 *	SPIx Peripheral - Configurable Items for User Application:
 *	SPI_DeviceMode, SPI_BusConfig, SPI_DFF, SPI_CPHA, SPI_CPOL, SPI_SSM, SPI_Speed
 */

#include "stm32f446xx_spi_driver.h"

//static keyword used to make helper functions private
static void spi_txe_interrupt_handle(SPI_Handle_t *pSPIHandle);
static void spi_rxne_interrupt_handle(SPI_Handle_t *pSPIHandle);
static void spi_ovr_err_interrupt_handle(SPI_Handle_t *pSPIHandle);

/******************* Private Helper Functions *******************/
static void spi_txe_interrupt_handle(SPI_Handle_t *pSPIHandle) {

	//check the DFF bit in CR1
	if(pSPIHandle->pSPIx->CR1 & (1 << SPI_CR1_DFF)) {

		//16bit DFF
		//1. Load the data in to the DR
		pSPIHandle->pSPIx->DR = *((uint16_t*)pSPIHandle->pTxBuffer);
		pSPIHandle->TxLen--;
		pSPIHandle->TxLen--;
		(uint16_t*)pSPIHandle->pTxBuffer++;

	} else {

		//8bit DFF
		pSPIHandle->pSPIx->DR = *pSPIHandle->pTxBuffer;
		pSPIHandle->TxLen--;
		pSPIHandle->pTxBuffer++;
	}

	if(!pSPIHandle->TxLen) {

		//If TxLen is zero, close the SPI transmission and inform application that Tx is finished
		//this prevents interrupts from setting the TXE flag
		SPI_CloseTransmission(pSPIHandle);
		SPI_ApplicationEventCallback(pSPIHandle, SPI_EVENT_TX_CMPLT);
	}
}

static void spi_rxne_interrupt_handle(SPI_Handle_t *pSPIHandle){

	//check the DFF bit in CR1
	if(pSPIHandle->pSPIx->CR1 & (1 << SPI_CR1_DFF)) {

		//16bit DFF
		*((uint16_t*)pSPIHandle->pRxBuffer) = (uint16_t)pSPIHandle->pSPIx->DR;
		pSPIHandle->RxLen -= 2;
		pSPIHandle->pRxBuffer++;
		pSPIHandle->pRxBuffer++;

	} else {

		//8bit DFF
		*(pSPIHandle->pRxBuffer) = (uint8_t)pSPIHandle->pSPIx->DR;
		pSPIHandle->RxLen--;
		pSPIHandle->pRxBuffer++;
	}

	if(!pSPIHandle->RxLen) {

		//Rx is complete, turn off the RXNEIE interrupt
		SPI_CloseReception(pSPIHandle);
		SPI_ApplicationEventCallback(pSPIHandle, SPI_EVENT_RX_CMPLT);
	}
}

static void spi_ovr_err_interrupt_handle(SPI_Handle_t *pSPIHandle){

	uint8_t temp;

	//1. clear the OVR flag
	if(pSPIHandle->TxState != SPI_BUSY_IN_TX) {
		temp = pSPIHandle->pSPIx->DR;
		temp = pSPIHandle->pSPIx->SR;
	}
	(void)temp;

	//2. inform the application
	SPI_ApplicationEventCallback(pSPIHandle, SPI_EVENT_OVR_ERR);
}

/* Peripheral Clock Setup */
/* ******************************************************************************
 * @fn					-  SPI_PClockControl
 *
 * @brief				-  This function enables or disables the peripheral clock
 * 						   for the given SPI peripheral.
 *
 * @param[in]			-  Base address of the SPI peripheral
 * @param[in]			-  ENABLE or DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void SPI_PClockControl(SPI_RegDef_t *pSPIx, uint8_t State) {

	//Enable peripheral clock for specified SPI peripheral 1..4
	if(State == ENABLE) {

		if(pSPIx == SPI1) {
			SPI1_PCLK_EN();
		} else if(pSPIx == SPI2) {
			SPI2_PCLK_EN();
		} else if(pSPIx == SPI3) {
			SPI3_PCLK_EN();
		} else if(pSPIx == SPI4) {
			SPI4_PCLK_EN();
		}

	//Disable peripheral clock for specified SPI peripheral 1..4
	} else {

		if(pSPIx == SPI1) {
			SPI1_PCLK_DI();
		} else if(pSPIx == SPI2) {
			SPI2_PCLK_DI();
		} else if(pSPIx == SPI3) {
			SPI3_PCLK_DI();
		} else if(pSPIx == SPI4) {
			SPI4_PCLK_DI();
		}
	}
}

/* Initialization and Deinitialization */
/* ******************************************************************************
 * @fn					-  SPI_Init
 *
 * @brief				-  Initializes the SPI peripheral
 *
 * @param[in]			-  Base address of the SPI handle
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void SPI_Init(SPI_Handle_t *pSPIHandle) {

	//Peripheral Clock Enable
	SPI_PClockControl(pSPIHandle->pSPIx, ENABLE);

	//1.a. Configure the SPI_CR1 register
	uint32_t tempreg = 0;

	//1.b. Configure the device mode as Master (slave is default)
	tempreg |= (pSPIHandle->SPIConfig.SPI_DeviceMode << SPI_CR1_MSTR);

	//2. Configure the bus config
	if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_FD) {
		//bidi mode should be cleared
		tempreg &= ~(1 << SPI_CR1_BIDIMODE);
	} else if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_HD) {
		//bidi mode should be set
		tempreg |= (1 << SPI_CR1_BIDIMODE);
	} else if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_SIMPLEX_RXONLY) {
		//BIDI mode should be cleared
		tempreg &= ~(1 << SPI_CR1_BIDIMODE);
		//RXONLY bit must be set
		tempreg |= (1 << SPI_CR1_RXONLY);
	}

	//3. Configure the SPI Serial Clock Speed (baud rate)
	tempreg |= (pSPIHandle->SPIConfig.SPI_SclkSpeed << SPI_CR1_BR);

	//4. Configure the DFF (Data Frame Format)
	tempreg |= (pSPIHandle->SPIConfig.SPI_DFF << SPI_CR1_DFF);

	//5. Configure the CPOL (Clock Polarity)
	tempreg |= (pSPIHandle->SPIConfig.SPI_CPOL << SPI_CR1_CPOL);

	//6. Configure the CPHA (Clock Phase)
	tempreg |= (pSPIHandle->SPIConfig.SPI_CPHA << SPI_CR1_CPHA);

	tempreg |= pSPIHandle->SPIConfig.SPI_SSM << SPI_CR1_SSM;

	pSPIHandle->pSPIx->CR1 = tempreg;
}

/* ******************************************************************************
 * @fn					-  SPI_DeInit
 *
 * @brief				-  De-initializes the SPI peripheral
 *
 * @param[in]			-  Base address of the SPI peripheral
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void SPI_DeInit(SPI_RegDef_t *pSPIx) {

	if(pSPIx == SPI1) {
		SPI1_REG_RESET();
	} else if(pSPIx == SPI2) {
		SPI2_REG_RESET();
	} else if(pSPIx == SPI3) {
		SPI3_REG_RESET();
	} else if(pSPIx == SPI4) {
		SPI4_REG_RESET();
	}
}

/* Data Send and Receive */
/* ******************************************************************************
 * @fn					-  SPI_SendData
 *
 * @brief				-  Send data over SPI bus
 *
 * @param[in]			-  Base address of the SPI peripheral
 * @param[in]			-  Pointer to Tx buffer
 * @param[in]			-  Length of data to be sent
 *
 * @return				-  None
 *
 * @note				-  This is a blocking call (polling)
 *
 */
void SPI_SendData(SPI_RegDef_t *pSPIx, uint8_t *pTxBuffer, uint32_t Len) {

	while(Len > 0) {

		//1. Wait (polling) until TXE is set
		while(SPI_GetFlagStatus(pSPIx,SPI_FLAG_TXE) == FLAG_RESET);

		//2. check the DFF bit in CR1
		if(pSPIx->CR1 & (1 << SPI_CR1_DFF)) {

			//16bit DFF
			//1. Load the data in to the DR
			pSPIx->DR = *((uint16_t*)pTxBuffer);
			Len--;
			Len--;
			(uint16_t*)pTxBuffer++;

		} else {

			//8bit DFF
			pSPIx->DR = *pTxBuffer;
			Len--;
			pTxBuffer++;
		}
	}
}


/* ******************************************************************************
 * @fn					-  SPI_ReceiveData
 *
 * @brief				-  Receive data over SPI bus
 *
 * @param[in]			-  Base address of the SPI peripheral
 * @param[in]			-  Pointer to Rx buffer
 * @param[in]			-  Length of data to be received
 *
 * @return				-  None
 *
 * @note				-  This is a blocking call (polling)
 *
 */
void SPI_ReceiveData(SPI_RegDef_t *pSPIx, uint8_t *pRxBuffer, uint32_t Len) {

	while(Len > 0) {

		//1. Wait (polling) until RXNE is set
		while(SPI_GetFlagStatus(pSPIx,SPI_FLAG_RXNE) == FLAG_RESET);

		//2. check the DFF bit in CR1
		if(pSPIx->CR1 & (1 << SPI_CR1_DFF)) {

			//16bit DFF
			//1. Load the data from DR into Rxbuffer address
			*((uint16_t*)pRxBuffer) = pSPIx->DR;
			Len--;
			Len--;
			(uint16_t*)pRxBuffer++;

		} else {

			//8bit DFF
			*(pRxBuffer) = pSPIx->DR;
			Len--;
			pRxBuffer++;
		}
	}
}

/* ******************************************************************************
 * @fn					-  SPI_SendDataIT
 *
 * @brief				-  Receive data over SPI bus using interrupts
 *
 * @param[in]			-  Pointer to SPI handle
 * @param[in]			-  Pointer to Tx buffer
 * @param[in]			-  Length of data to be received
 *
 * @return				-  Status of Tx
 *
 * @note				-  This is a non-blocking call (interrupt)
 *
 */
uint8_t SPI_SendDataIT(SPI_Handle_t *pSPIHandle, uint8_t *pTxBuffer, uint32_t Len) {

	uint8_t status = pSPIHandle->TxState;

	if(status != SPI_BUSY_IN_TX) {

		//1. Save the Tx buffer address and Len information in some global variables
		pSPIHandle->pTxBuffer = pTxBuffer;
		pSPIHandle->TxLen = Len;

		//2. Mark the SPI state as busy in transmission so no other code can take over
		//   the same peripheral until transmission is over.
		pSPIHandle->TxState = SPI_BUSY_IN_TX;

		//3. Enable the TXEIE control bit to get interrupt whenever TXE flag is set in SR
		pSPIHandle->pSPIx->CR2 |= (1 << SPI_CR2_TXEIE);
	}

	return status;
}

/* ******************************************************************************
 * @fn					-  SPI_ReceiveDataIT
 *
 * @brief				-  Receive data over SPI bus using interrupts
 *
 * @param[in]			-  Pointer to SPI handle
 * @param[in]			-  Pointer to Rx buffer
 * @param[in]			-  Length of data to be received
 *
 * @return				-  None
 *
 * @note				-  This is a non-blocking call (interrupt)
 *
 */
uint8_t SPI_ReceiveDataIT(SPI_Handle_t *pSPIHandle, uint8_t *pRxBuffer, uint32_t Len) {

	uint8_t status = pSPIHandle->RxState;

	if(status != SPI_BUSY_IN_RX) {

		//1. Save the Rx buffer address and Len information in some global variables
		pSPIHandle->pRxBuffer = pRxBuffer;
		pSPIHandle->RxLen = Len;

		//2. Mark the SPI state as busy in retrieval so no other code can take over
		//   the same peripheral until retrieval is over.
		pSPIHandle->RxState = SPI_BUSY_IN_RX;

		//3. Enable the RXNEIE control bit to get interrupt whenever RXE flag is set in SR
		pSPIHandle->pSPIx->CR2 |= (1 << SPI_CR2_RXNEIE);
	}

	return status;
}


/* IRQ Configuration, Priority and ISR Handling */
/* ******************************************************************************
 * @fn					-  SPI_IRQInterruptConfig
 *
 * @brief				-  Configure interrupt request (IRQx)
 *
 * @param[in]			-  IRQ number
 * @param[in]			-  ENABLE or DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void SPI_IRQInterruptConfig(uint8_t IRQNumber, uint8_t State) {

	if(State == ENABLE) {

		if(IRQNumber <= 31) { //IRQ 0 to 31
			//program ISER0 register
			*NVIC_ISER0 |= (1 << IRQNumber);

		} else if(IRQNumber > 31 && IRQNumber < 64) { //IRQ 32 to 63
			//program ISER1 register
			*NVIC_ISER1 |= (1 << (IRQNumber % 32));

		} else if(IRQNumber >= 64 && IRQNumber < 96) { //IRQ 64 to 95
			//program ISER2 register
			*NVIC_ISER2 |= (1 << (IRQNumber % 64));

		} else if(IRQNumber >= 96 && IRQNumber < 128) { //IRQ 96 to 127 (stm32f446xx only supports up to IRQ96)
			//program ISER3 register
			*NVIC_ISER3 |= (1 << (IRQNumber % 96));
		}

	} else {

		if(IRQNumber <= 31) { //0 to 31
			//program ICER0 register
			*NVIC_ICER0 |= (1 << IRQNumber);

		} else if(IRQNumber > 31 && IRQNumber < 64) { //IRQ 32 to 63
			//program ICER1 register
			*NVIC_ICER1 |= (1 << (IRQNumber % 32));

		} else if(IRQNumber >= 64 && IRQNumber < 96) { //IRQ 64 to 95
			//program ICER2 register
			*NVIC_ICER2 |= (1 << (IRQNumber % 64));

		} else if(IRQNumber >= 96 && IRQNumber < 128) { //IRQ 96 to 127 (stm32f446xx only supports up to IRQ96)
			//program ICER3 register
			*NVIC_ICER3 |= (1 << (IRQNumber % 96));
		}
	}
}


/* ******************************************************************************
 * @fn					-  SPI_IRQPriorityConfig
 *
 * @brief				-  Configure IRQ priority
 *
 * @param[in]			-  IRQ number
 * @param[in]			-  IRQ priority
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void SPI_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority) {

	//1. First calculate for the correct IPR register
	//IPRx registers are 32 bits wide, split into four sections of 1 Byte (8-bits): | IPRn || IRQ4n+3_PRI | IRQ4n+2_PRI | IRQ4n+1_PRI | IRQ4n_PRI |
	uint8_t iprx = (IRQNumber / 4);
	uint8_t iprx_section = (IRQNumber % 4);

	//Within each 8-bit (byte) IRQ4n_PRI field, only the upper 4 bits are implemented (4:7), while the lower 4 are not (0:3).
	uint8_t shift_amount = (8 * iprx_section) + (8 - NO_PR_BITS_IMPLEMENTED);

	*(NVIC_PR_BASE_ADDR + iprx) |= (IRQPriority << shift_amount);
}


/* ******************************************************************************
 * @fn					-  SPI_IRQHandling
 *
 * @brief				-  Configure IRQ handler for SPIx
 *
 * @param[in]			-  Pointer to SPI handle
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void SPI_IRQHandling(SPI_Handle_t *pHandle) {

/*
 *	SPI Interrupts:
 *	During SPI communication, an interrupt can be generated by the following events:
 *	. Transmit Tx buffer ready to be loaded						(TXE Event Flag)  	(TXEIE  Enable Control Bit)
 *	. Data received in Rx buffer								(RXNE Event Flag) 	(RXNEIE Enable Control Bit)
 *	. Master mode fault (must avoid when using single-master)	(MODF Event Flag) 	(ERRIE  Enable Control Bit)
 *	. Overrun error												(OVR Event Flag)  	(ERRIE  Enable Control Bit)
 *	. CRC error													(CRCERR Event Flag)	(ERRIE  Enable Control Bit)
 *	. TI frame format error										(FRE Event Flag)  	(ERRIE  Enable Control Bit)
 *
 *	Interrupts can be enabled and disabled separately.
 *
 *	SPI connects directly to NVIC without EXTI line or other intermediate step.
 *
 *	Exercise 1:
 *	Complete SPI IRQ number definition macros in MCU specific header file
 *
 *	Exercise 2:
 *	Complete the SPI IRQ Configuration APIs Implementation (reuse code from GPIO driver)
 */
	uint8_t temp1, temp2;

	//check for TXE
	temp1 = pHandle->pSPIx->SR & (1 << SPI_SR_TXE);
	temp2 = pHandle->pSPIx->CR2 & (1 << SPI_CR2_TXEIE);

	if (temp1 && temp2) {
		//handle TXE
		spi_txe_interrupt_handle(pHandle);
	}

	//check for RXNE
	temp1 = pHandle->pSPIx->SR & (1 << SPI_SR_RXNE);
	temp2 = pHandle->pSPIx->CR2 & (1 << SPI_CR2_RXNEIE);

	if(temp1 && temp2) {
		//handle RXNE
		spi_rxne_interrupt_handle(pHandle);
	}

	//check for OVR flag
	temp1 = pHandle->pSPIx->SR & (1 << SPI_SR_OVR);
	temp2 = pHandle->pSPIx->CR2 & (1 << SPI_CR2_ERRIE);

	if(temp1 && temp2) {
		//handle ovr error
		spi_ovr_err_interrupt_handle(pHandle);
	}

}

/* Other Peripheral Control APIs */
/* ******************************************************************************
 * @fn					-  SPI_PeripheralControl
 *
 * @brief				-  Enable or disable SPIx peripheral
 *
 * @param[in]			-  Base address of the SPI peripheral
 * @param[in]			-  ENABLE or DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void SPI_PeripheralControl(SPI_RegDef_t *pSPIx, uint8_t State) {

	if(State == ENABLE) {
		pSPIx->CR1 |= (1 << SPI_CR1_SPE);
	} else {
		pSPIx->CR1 &= ~(1 << SPI_CR1_SPE);
	}
}

/* ******************************************************************************
 * @fn					-  SPI_SSIConfig
 *
 * @brief				-  SSI (Internal Slave Select)
 *
 * @param[in]			-  Base address of the SPI peripheral
 * @param[in]			-  ENABLE or DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  Forces a value onto NSS pin and the IO value of the
 * 						   NSS pin is ignored.
 *
 */
void SPI_SSIConfig(SPI_RegDef_t *pSPIx, uint8_t State) {

	if(State == ENABLE) {
		pSPIx->CR1 |= (1 << SPI_CR1_SSI);
	} else {
		pSPIx->CR1 &= ~(1 << SPI_CR1_SSI);
	}
}

/* ******************************************************************************
 * @fn					-  SPI_SSOEConfig
 *
 * @brief				-  SSOE (Slave Select Output Enable)
 *
 * @param[in]			-  Base address of the SPI peripheral
 * @param[in]			-  ENABLE or DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  0: SS output is disabled in master mode and cell can work
 * 					          in multi-master configuration.
 * 					       1: SS output is enabled in master mode and when cell is
 * 					          enabled. Cell cannot work in multi-master environment.
 *
 */
void SPI_SSOEConfig(SPI_RegDef_t *pSPIx, uint8_t State) {

	if(State == ENABLE) {
		pSPIx->CR2 |= (1 << SPI_CR2_SSOE);
	} else {
		pSPIx->CR2 &= ~(1 << SPI_CR2_SSOE);
	}
}

/* ******************************************************************************
 * @fn					-  SPI_GetFlagStatus
 *
 * @brief				-  Retrieve flag status of SPI peripheral
 *
 * @param[in]			-  Base address of the SPI peripheral
 * @param[in]			-  Flag name
 *
 * @return				-  Byte containing flag status info
 *
 * @note				-  None
 *
 */
uint8_t SPI_GetFlagStatus(SPI_RegDef_t *pSPIx, uint32_t FlagName) {

	if(pSPIx->SR & FlagName) {
		return FLAG_SET;
	}

	return FLAG_RESET;
}

/* ******************************************************************************
 * @fn					-  SPI_ClearOVRFlag
 *
 * @brief				-  Clear Overrun Flag
 *
 * @param[in]			-  Base address of the SPI peripheral
 *
 * @return				-  None
 *
 * @note				-  Pg864 of reference manual
 *
 */
void SPI_ClearOVRFlag(SPI_RegDef_t *pSPIx) {

	uint8_t temp;
	temp = pSPIx->DR;
	temp = pSPIx->SR;
	(void)temp;
}

/* ******************************************************************************
 * @fn					-  SPI_CloseTransmission
 *
 * @brief				-  End SPI transmission
 *
 * @param[in]			-  Pointer to SPI handle
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void SPI_CloseTransmission(SPI_Handle_t *pSPIHandle) {

	pSPIHandle->pSPIx->CR2 &= ~( 1 << SPI_CR2_TXEIE);
	pSPIHandle->pTxBuffer = NULL;
	pSPIHandle->TxLen = 0;
	pSPIHandle->TxState = SPI_READY;
}

/* ******************************************************************************
 * @fn					-  SPI_CloseReception
 *
 * @brief				-  End SPI reception
 *
 * @param[in]			-  Pointer to SPI handle
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void SPI_CloseReception(SPI_Handle_t *pSPIHandle) {

	pSPIHandle->pSPIx->CR2 &= ~( 1 << SPI_CR2_RXNEIE);
	pSPIHandle->pRxBuffer = NULL;
	pSPIHandle->RxLen = 0;
	pSPIHandle->RxState = SPI_READY;
}

/* Application Callback */
/* ******************************************************************************
 * @fn					-  SPI_ApplicationEventCallback
 *
 * @brief				-  Application Event Callback (weak implementation)
 *
 * @param[in]			-  Pointer to SPI handle
 * @param[in]			-  Application event byte
 *
 * @return				-  None
 *
 * @note				-  Weak implementation
 *
 */
__weak void SPI_ApplicationEventCallback(SPI_Handle_t *pSPIHandle, uint8_t AppEv) {

	//This is a weak implementation -- the application may override this function.
}


/****************************************************************************************/
							stm32f446xx_usart_driver.c
/****************************************************************************************/	
/*
 * stm32f446xx_usart_driver.c
 *
 *  Created on: Mar 12, 2021
 *      Author: Oliver
 */

/*
 *	UART (Universal Asynchronous Receiver Transmitter)
 *	and
 *	USART (Universal Synchronous/Asynchronous Receiver Transmitter)
 *	are pieces of hardware that converts parallel data into serial data.
 *
 *	You can use USART module in both synchronous and asynchronous modes.
 *
 *	There is no specific port for USART communication. They are commonly used in conjunction
 *	with protocols like RS-232, RS-434, USB etc.
 *
 *	In Synchronous transmission, the clock is sent separately from the data stream and
 *	no start/stop bits are used.
 *
 *	USART Hardware Components:
 *	Baud rate generator, TX and RX shift registers, Transmit/Receive control blocks and buffers,
 *	First-in First-out (FIFO) buffer memory
 *
 *	USART is just a piece of hardware in the MCU which transmits/receives data bits either in
 *	Synchronous or Asynchronous mode.
 *
 *	If it is Asynchronous mode, then the clock will not be sent alongside the data, instead we use
 *	synchronization bits like start and stop with the useful data.
 *
 *	__Understanding UART Pins__
 *	UART1:  TX, RX, RTS, CTS
 *
 *	The USART RX engine continuously samples the RX line to detect the start bit of a frame.
 *	When the start bit of the frame is detected, the frame reception kicks in on the RX line.
 *
 *	When transmission is not occurring, the TX line will be held high in its idle state.
 *
 *	RTS (Request to Send and CTS) (Clear to Send - Active Low pin)
 *
 *	When hardware flow control is used, the UART module will send the data out of TX line
 *	only when the CTS is pulled to low.
 *
 *	UART module uses the RTS line to request data from the other device.
 *
 *	__UART Frame Formats__
 *	9-bit word, 1 stop bit
 *	<Start Bit> <Data Frame Bit 0:8> <Stop Bit>  (Bit 8 can also be used as an optional Parity Bit)
 *	When parity is used, the MSB of the data will be replaced by parity bit
 *
 *	8-bit word, 1 stop bit
 *	<Start Bit> <Data Frame Bit 0:7> <Stop Bit>
 *
 *	__Baud Rate__
 *	Baud rate is how fast the data is sent over the serial line in units of bits-per-second (bps).
 *	If you invert the baud rate, you can find out how long it takes to transmit a single bit. This value
 *	determines how long the transmitter holds a serial line high or low.
 *
 *	Baud rate = 9600bps
 *	1 bit duration = 1/9600 = 104us
 *
 *	Both transmitting and receiving devices should operate at the same rate.
 *	Common values: 2400, 4800, 9600, 19200, 38400, 57600, 115200
 *
 *	The baud rates are usually dependent upon the peripheral clock frequency of the UART peripheral.
 *
 *	__Synchronization Bits__
 *	Start bit marks the beginning of a frame (idle data line going from high to low)
 *	Stop bits mark the the end of a frame (back to idle state low to high)
 *	There is always 1 start bit, but stop bits are configurable (0.5, 1, 1.5, 2 stop bits)
 *
 *	__UART Parity__
 *	Adding a Parity bit is a simple method of error detection. Parity is simply the number of one's appearing
 *	in the binary form of a number.
 *	55(decimal) -> 0b00110111  Parity=5 (odd number of one's -> set parity bit to 1)   Parity is either even or odd.
 *	Even = 0, Odd = 1
 *
 *	__UART Peripheral Clock__
 *	USART1 and USART6 are on APB2 (84MHz max but 16MHz if run from HSI or HSE).
 *	USART2, USART3, UART4, UART5 are on APB1 (42MHz max but 16MHz if run from HSI or HSE).
 *
 *	__Steps for Data Transmission__
 *	. Program the M bit in USART_CR1 to define the word length
 *	. Program the number of stop bits in USART2_CR2 register.
 *	. Select the desired baud rate using the USART_BRR register (check table to see baud rate choices given different peripheral clock values).
 *	. Set the TE bit in USART_CR1 to enable the transmit block.
 *	. Enable the USART by writing the UE bit in USART_CR1.
 *	. Now if TXE flag is set, then write the data byte to send, in the USART_DR register.
 *	. After writing the last data into the USART_DR register, wait until TC=1
 *
 *	__Steps for Data Reception__
 *	. Program the M bit in USART_CR1 to define the word length.
 *	. Program the number of stop bits in USART_CR2 register.
 *	. Select the desired baud rate using the USART_BRR register.
 *	. Enable the USART by writing the UE bit in USART_CR1.
 *	. Set the RE bit in the USART_CR1 register, which enables the receiver block of the USART peripheral.
 *	. When a character is received, wait until the RXNE bit is set and read the data byte from the data register.
 *	. The RXNE bit must be cleared by reading the data register, before the end of the reception of the next character to avoid an overrun error.
 *
 *	__USART: Oversampling__
 *	. The receiver implements different user-configurable over-sampling techniques (except in synchronous mode) for data recovery by
 *	  discriminating between valid incoming data and noise.
 *	. The over-sampling method can be selected by programming the OVER8 bit in the USART_CR1 register and can be either 16 or 8 times the baud rate clock.
 *	. Configurable oversampling method by 16 or by 8 to give flexibility between speed and clock tolerance.
 *
 *	__Sampled Values vs Noise__
 *	Sampled Value		NE Status		Received bit value
 *		000					0					0
 *		001					1					0
 *		010					1					0
 *		011					1					1
 *		100					1					0
 *		101					1					1
 *		110					1					1
 *		111					0					1
 *
 *	__Noise Error__
 *	When noise is detected in a frame:
 *	. The NF flag bit is set by hardware when noise is detected on a received frame.
 *	. The invalid data is transferred from the Shift register to the USART_DR register.
 *	. The application may consider or discard the frame based on application logic.
 *
 *	__Selecting the proper over-sampling method__
 *	The receiver implements different user-configurable over-sampling techniques (except in synchronous mode) for
 *	data recovery by discriminating between valid incoming data and noise.
 *	. Over-sampling by 8 (OVER8 = 1) -> max baud rate = F_pclk / 8
 *		- max receiver tolerance to clock deviation reduced
 *	. Over-sampling by 16 (OVER8 = 0) -> max baud rate = F_pclk / 16
 *		- max receiver tolerance to clock deviation increased
 *
 *	__Baud Rate Calculation__
 *	Tx/Rx baud = (F_pclk / (8 * USARTDIV))  if OVER8 = 1
 *	Tx/Rx baud = (F_pclk / (16 * USARTDIV))  if OVER8 = 0
 *
 *	General Formula:
 *	Tx/Rx baud = (F_pclk / (8 * (2 - OVER8) * USARTDIV))
 *
 *	Example:
 *	F_pclk = 16MHz (USART peripheral clock)
 *	Tx/Rx baud = 9600bps (Desired baud rate)
 *	OVER8 = 0 (Oversampling by 16)
 *
 *	USARTDIV = 16M / (8 * 2 * 9600) = 104.1875
 *
 *	The baud rate for Rx and Tx are both set to the same value as programmed in the Mantissa and Fraction values of USARTDIV
 *
 *	Now this value we have to convert into hex and then program the USART_BRR register to achieve desired baud rate.
 *	USART uses a fractional baud rate generator - with a 12-bit mantissa and 4-bit fraction
 *
 *				USART_BRR
 *	Mantissa.Fraction = 104.1875
 *	Mantissa = 104	 	DIV_Mantissa[15:4]
 *	Fraction = 1875  	DIV_Fraction[3:0]
 *
 *	USARTDIV = 104.1875 (For baudrate 9600bps with F_pclk = 16MHz and OVER8 = 0)
 *	Div_Fraction = 0.1875 * 16 = 3
 *	Div_Mantissa = 104 = 0x68
 *	USARTDIV = 0x683  (Program this value into USART_BRR register to generate baudrate of 9600bps)
 *
 *	CP2102 USB to UART converter chip exists on ST development boards to convert USB signal of PC to/from MCU UART signal.
 *	Can also use a USB to UART converter cable.
 */

#include "stm32f446xx_usart_driver.h"


/******************* Private Helper Functions *******************/


/* Peripheral Clock Setup */
/* ******************************************************************************
 * @fn					-  USART_PClockControl
 *
 * @brief				-  This function enables or disables the peripheral clock
 * 						   for the given USART peripheral.
 *
 * @param[in]			-  Base address of the USART peripheral
 * @param[in]			-  ENABLE or DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void USART_PClockControl(USART_RegDef_t *pUSARTx, uint8_t State) {

	//Enable peripheral clock for specified USART peripheral 1..3
	if(State == ENABLE) {

		if(pUSARTx == USART1) {
			USART1_PCLK_EN();
		} else if(pUSARTx == USART2) {
			USART2_PCLK_EN();
		} else if(pUSARTx == USART3) {
			USART3_PCLK_EN();
		} else if(pUSARTx == UART4) {
			UART4_PCLK_EN();
		} else if(pUSARTx == UART5) {
			UART5_PCLK_EN();
		} else if(pUSARTx == USART6) {
			USART6_PCLK_EN();
		}

	//Disable peripheral clock for specified USART peripheral 1..6
	} else {

		if(pUSARTx == USART1) {
			USART1_PCLK_DI();
		} else if(pUSARTx == USART2) {
			USART2_PCLK_DI();
		} else if(pUSARTx == USART3) {
			USART3_PCLK_DI();
		} else if(pUSARTx == UART4) {
			UART4_PCLK_DI();
		} else if(pUSARTx == UART5) {
			UART5_PCLK_DI();
		} else if(pUSARTx == USART6) {
			USART6_PCLK_DI();
		}
	}
}


/* Initialization and Deinitialization */
/* ******************************************************************************
 * @fn					-  USART_Init
 *
 * @brief				-  Initializes the USART peripheral
 *
 * @param[in]			-  Base address of the USART handle
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void USART_Init(USART_Handle_t *pUSARTHandle) {

	uint32_t tempreg = 0;

/* ************************************** Configuration of CR1 ************************************** */

	//Enable the clock for the given USART peripheral
	USART_PClockControl(pUSARTHandle->pUSARTx, ENABLE);

	//Enable USART Tx and Rx engines according to the USART_Mode configuration
	if(pUSARTHandle->USART_Config.USART_Mode == USART_MODE_ONLY_RX) {
		//Enable the receiver bit field
		tempreg |= (1 << USART_CR1_RE);

	} else if(pUSARTHandle->USART_Config.USART_Mode == USART_MODE_ONLY_TX) {
		//Enable the transmitter bit field
		tempreg |= (1 << USART_CR1_TE);

	} else if(pUSARTHandle->USART_Config.USART_Mode == USART_MODE_TXRX) {
		//Enable both the receiver and transmitter bit fields
		tempreg |= ((1 << USART_CR1_RE) | (1 << USART_CR1_TE));
	}

	//Configure the word length configuration
	tempreg |= (pUSARTHandle->USART_Config.USART_WordLength << USART_CR1_M);

	//Configure parity control bit fields
	if(pUSARTHandle->USART_Config.USART_ParityControl == USART_PARITY_EN_EVEN) {
		//Enable parity control
		tempreg |= (1 << USART_CR1_PCE);

		//Enable EVEN parity
		//Not required because EVEN parity is selected by default when parity control is enabled.

	} else if(pUSARTHandle->USART_Config.USART_ParityControl == USART_PARITY_EN_ODD) {
		//Enable parity control
		tempreg |= (1 << USART_CR1_PCE);

		//Enable ODD parity
		tempreg |= (1 << USART_CR1_PS);
	}

	//Program the CR1 register
	pUSARTHandle->pUSARTx->CR1 = tempreg;

/* ************************************** Configuration of CR2 ************************************** */
	tempreg = 0;

	//Configure the number of stop bits inserted during USART frame transmission
	tempreg |= (pUSARTHandle->USART_Config.USART_NoOfStopBits << USART_CR2_STOP);

	//Program the CR2 register
	pUSARTHandle->pUSARTx->CR2 = tempreg;

/* ************************************** Configuration of CR3 ************************************** */
	tempreg = 0;

	//Configure of USART hardware flow control
	if(pUSARTHandle->USART_Config.USART_HWFlowControl == USART_HW_FLOW_CTRL_CTS) {
		//Enable CTS flow control
		tempreg |= (1 << USART_CR3_CTSE);

	} else if(pUSARTHandle->USART_Config.USART_HWFlowControl == USART_HW_FLOW_CTRL_RTS) {
		//Enable RTS flow control
		tempreg |= (1 << USART_CR3_RTSE);

	} else if(pUSARTHandle->USART_Config.USART_HWFlowControl == USART_HW_FLOW_CTRL_CTS_RTS) {
		//Enable both CTS and RTS flow control
		tempreg |= (1 << USART_CR3_CTSE);
		tempreg |= (1 << USART_CR3_RTSE);
	}

	//Program the CR3 register
	pUSARTHandle->pUSARTx->CR3 = tempreg;

/* ************************************** Configuration of BRR ************************************** */
	//Configure the baud rate
	USART_SetBaudRate(pUSARTHandle->pUSARTx, pUSARTHandle->USART_Config.USART_Baud);
}

/* ******************************************************************************
 * @fn					-  USART_DeInit
 *
 * @brief				-  De-initializes the USART peripheral
 *
 * @param[in]			-  Base address of the USART peripheral
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void USART_DeInit(USART_RegDef_t *pUSARTx) {

	if(pUSARTx == USART1) {
		USART1_REG_RESET();
	} else if(pUSARTx == USART2) {
		USART2_REG_RESET();
	} else if(pUSARTx == USART3) {
		USART3_REG_RESET();
	} else if(pUSARTx == UART4) {
		UART4_REG_RESET();
	} else if(pUSARTx == UART5) {
		UART5_REG_RESET();
	} else if(pUSARTx == USART6) {
		USART6_REG_RESET();
	}
}

/* Data Send and Receive */
/* ******************************************************************************
 * @fn					-  USART_SendData
 *
 * @brief				-  Send data over USART bus
 *
 * @param[in]			-  Base address of the USART Handle
 * @param[in]			-  Pointer to Tx buffer
 * @param[in]			-  Length of data to be sent
 *
 * @return				-  None
 *
 * @note				-  Polling based (blocking)
 *
 */
void USART_SendData(USART_Handle_t *pUSARTHandle, uint8_t *pTxBuffer, uint32_t Len) {

	uint16_t *pdata;

	//Loop until Len number of bytes are transferred
	for(uint32_t i = 0; i < Len; i++) {
		//Wait until TXE flag is set in SR
		while(! USART_GetFlagStatus(pUSARTHandle->pUSARTx, USART_FLAG_TXE));

		//Check the USART_WordLength for 9 or 8 bit data frame configuration
		if(pUSARTHandle->USART_Config.USART_WordLength == USART_WORDLEN_9BITS) {

			//9 Bit Data Transfer
			//If 9 bits, load the DR with 2 bytes, masking the bits other than the first 9 of 16 bits (0x1FF)
			pdata = (uint16_t*) pTxBuffer;
			pUSARTHandle->pUSARTx->DR = (*pdata & (uint16_t) 0x01FF);

			//Check for USART_ParityControl
			if(pUSARTHandle->USART_Config.USART_ParityControl == USART_PARITY_DISABLE) {
				//No parity is used in this transfer, so 9 bits of user data will be sent
				//Increment the buffer address twice
				pTxBuffer++;
				pTxBuffer++;
			} else {
				//Parity bit is used in this transfer, so 8 bits of user data will be sent
				//The 9th bit will be replaced with parity bit by the hardware
				//Increment the buffer address
				pTxBuffer++;
			}

		} else {

			//8 Bit Data Transfer
			pUSARTHandle->pUSARTx->DR = (*pTxBuffer & (uint8_t) 0xFF);

			//Increment the buffer address
			pTxBuffer++;
		}
	}

	//Wait until TC flag is set in SR
	while(! USART_GetFlagStatus(pUSARTHandle->pUSARTx, USART_FLAG_TC));
}

/* ******************************************************************************
 * @fn					-  USART_ReceiveData
 *
 * @brief				-  Receive data over USART bus
 *
 * @param[in]			-  Base address of the USART Handle
 * @param[in]			-  Pointer to Rx buffer
 * @param[in]			-  Length of data to be read
 *
 * @return				-  None
 *
 * @note				-  Polling based (blocking)
 *
 */
void USART_ReceiveData(USART_Handle_t *pUSARTHandle, uint8_t *pRxBuffer, uint32_t Len) {

	//Loop until Len number of bytes are transferred
	for(uint32_t i = 0; i < Len; i++) {
		//Wait until RXNE flag is set in SR
		while(! USART_GetFlagStatus(pUSARTHandle->pUSARTx, USART_FLAG_RXNE));

		//Check the USART_WordLength for 9 or 8 bit data frame configuration
		if(pUSARTHandle->USART_Config.USART_WordLength == USART_WORDLEN_9BITS) {

			//9 Bit Data Transfer

			//Check for USART_ParityControl
			if(pUSARTHandle->USART_Config.USART_ParityControl == USART_PARITY_DISABLE) {
				//No parity is used in this transfer, so 9 bits of user data will be received

				//Read only first 9 bits so mask the DR with 0x01FF
				*((uint16_t*) pRxBuffer) = (pUSARTHandle->pUSARTx->DR & (uint16_t) 0x01FF);

				//Increment the buffer address twice
				pRxBuffer++;
				pRxBuffer++;

			} else {
				//Parity bit is used in this transfer, so 8 bits of user data will be received
				//The 9th bit will be replaced with parity bit by the hardware
				*pRxBuffer = (pUSARTHandle->pUSARTx->DR & (uint8_t) 0xFF);

				//Increment the buffer address
				pRxBuffer++;
			}

		} else {

			//8 Bit Data Transfer
			//Check for USART_ParityControl
			if(pUSARTHandle->USART_Config.USART_ParityControl == USART_PARITY_DISABLE) {
				//No parity is used in this transfer, so 8 bits of user data will be received

				//Read only first 9 bits so mask the DR with 0x01FF
				 *pRxBuffer = (uint8_t) (pUSARTHandle->pUSARTx->DR & (uint8_t) 0xFF);


			} else {
				//Parity bit is used in this transfer, so 7 bits of user data will be received
				//The 8th bit will be replaced with parity bit by the hardware
				//Read only 7 bits, masking DR with 0x7F
				*pRxBuffer = (uint8_t) (pUSARTHandle->pUSARTx->DR & (uint8_t) 0x7F);

			}

			//Increment the buffer address
			pRxBuffer++;
		}
	}
}

/* ******************************************************************************
 * @fn					-  USART_SendDataIT
 *
 * @brief				-  Send data over USART bus (IT)
 *
 * @param[in]			-  Pointer to base address of the USART Handle
 * @param[in]			-  Pointer to Rx buffer
 * @param[in]			-  Length of data to be read
 *
 * @return				-  Busy state
 *
 * @note				-  Interrupt based (non-blocking)
 *
 */
uint8_t USART_SendDataIT(USART_Handle_t *pUSARTHandle, uint8_t *pTxBuffer, uint32_t Len) {

	uint8_t txstate = pUSARTHandle->TxBusyState;

	if(txstate != USART_BUSY_IN_TX) {
		pUSARTHandle->TxLen = Len;
		pUSARTHandle->pTxBuffer = pTxBuffer;
		pUSARTHandle->TxBusyState = USART_BUSY_IN_TX;

		//Enable interrupt for TXE
		pUSARTHandle->pUSARTx->CR1 |= (1 << USART_CR1_TXEIE);

		//Enable interrupt for TC
		pUSARTHandle->pUSARTx->CR1 |= (1 << USART_CR1_TCIE);
	}

	return txstate;
}

/* ******************************************************************************
 * @fn					-  USART_ReceiveDataIT
 *
 * @brief				-  Receive data over USART bus (IT)
 *
 * @param[in]			-  Pointer to base address of the USART Handle
 * @param[in]			-  Pointer to Rx buffer
 * @param[in]			-  Length of data to be read
 *
 * @return				-  Busy state
 *
 * @note				-  Interrupt based (non-blocking)
 *
 */
uint8_t USART_ReceiveDataIT(USART_Handle_t *pUSARTHandle, uint8_t *pRxBuffer, uint32_t Len) {

	uint8_t rxstate = pUSARTHandle->RxBusyState;

	if(rxstate != USART_BUSY_IN_RX) {
		pUSARTHandle->RxLen = Len;
		pUSARTHandle->pRxBuffer = pRxBuffer;
		pUSARTHandle->RxBusyState = USART_BUSY_IN_RX;

		(void)pUSARTHandle->pUSARTx->DR;

		//Enable interrupt for RXNE
		pUSARTHandle->pUSARTx->CR1 |= (1 << USART_CR1_RXNEIE);
	}

	return rxstate;
}


/* IRQ Configuration, Priority and ISR Handling */
/* ******************************************************************************
 * @fn					-  USART_IRQInterruptConfig
 *
 * @brief				-  Configure interrupt request (IRQx)
 *
 * @param[in]			-  IRQ number
 * @param[in]			-  ENABLE or DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void USART_IRQInterruptConfig(uint8_t IRQNumber, uint8_t State) {

	if(State == ENABLE) {

		if(IRQNumber <= 31) { //IRQ 0 to 31
			//program ISER0 register
			*NVIC_ISER0 |= (1 << IRQNumber);

		} else if(IRQNumber > 31 && IRQNumber < 64) { //IRQ 32 to 63
			//program ISER1 register
			*NVIC_ISER1 |= (1 << (IRQNumber % 32));

		} else if(IRQNumber >= 64 && IRQNumber < 96) { //IRQ 64 to 95
			//program ISER2 register
			*NVIC_ISER2 |= (1 << (IRQNumber % 64));

		} else if(IRQNumber >= 96 && IRQNumber < 128) { //IRQ 96 to 127 (stm32f446xx only supports up to IRQ96)
			//program ISER3 register
			*NVIC_ISER3 |= (1 << (IRQNumber % 96));
		}

	} else {

		if(IRQNumber <= 31) { //0 to 31
			//program ICER0 register
			*NVIC_ICER0 |= (1 << IRQNumber);

		} else if(IRQNumber > 31 && IRQNumber < 64) { //IRQ 32 to 63
			//program ICER1 register
			*NVIC_ICER1 |= (1 << (IRQNumber % 32));

		} else if(IRQNumber >= 64 && IRQNumber < 96) { //IRQ 64 to 95
			//program ICER2 register
			*NVIC_ICER2 |= (1 << (IRQNumber % 64));

		} else if(IRQNumber >= 96 && IRQNumber < 128) { //IRQ 96 to 127 (stm32f446xx only supports up to IRQ96)
			//program ICER3 register
			*NVIC_ICER3 |= (1 << (IRQNumber % 96));
		}
	}
}

/* ******************************************************************************
 * @fn					-  USART_IRQPriorityConfig
 *
 * @brief				-  Configure IRQ priority
 *
 * @param[in]			-  IRQ number
 * @param[in]			-  IRQ priority
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void USART_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority) {

	//1. First calculate for the correct IPR register
	//IPRx registers are 32 bits wide, split into four sections of 1 Byte (8-bits): | IPRn || IRQ4n+3_PRI | IRQ4n+2_PRI | IRQ4n+1_PRI | IRQ4n_PRI |
	uint8_t iprx = (IRQNumber / 4);
	uint8_t iprx_section = (IRQNumber % 4);

	//Within each 8-bit (byte) IRQ4n_PRI field, only the upper 4 bits are implemented (4:7), while the lower 4 are not (0:3).
	uint8_t shift_amount = (8 * iprx_section) + (8 - NO_PR_BITS_IMPLEMENTED);

	*(NVIC_PR_BASE_ADDR + iprx) |= (IRQPriority << shift_amount);
}

/* ******************************************************************************
 * @fn					-  USART_IRQHandling
 *
 * @brief				-  Configure USART IRQ Handling
 *
 * @param[in]			-  Pointer to base address of the USART Handle
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void USART_IRQHandling(USART_Handle_t *pUSARTHandle) {

	uint32_t temp1, temp2;
	//uint32_t temp3;

	uint16_t *pdata;

/* ************************ Check for TC flag ******************************************* */

	//Check state of TC bit in the SR
	temp1 = pUSARTHandle->pUSARTx->SR & (1 << USART_SR_TC);

	//Check the state of TCIE bit
	temp2 = pUSARTHandle->pUSARTx->CR1 & (1 << USART_CR1_TCIE);

	if(temp1 && temp2) {

		//This interrupt is due to TC
		if(pUSARTHandle->TxBusyState == USART_BUSY_IN_TX) {

			//Check the TxLen. If it is zero, then close data transmission
			if(! pUSARTHandle->TxLen) {

				//Clear the TC flag
				pUSARTHandle->pUSARTx->SR &= ~(1 << USART_SR_TC);

				//Clear the TCIE control bit
				//pUSARTHandle->pUSARTx->CR1 &= ~(1 << USART_CR1_TCIE);

				//Reset the application state
				pUSARTHandle->TxBusyState = USART_READY;

				//Reset buffer address to NULL
				pUSARTHandle->pTxBuffer = NULL;

				//Reset the length to zero
				pUSARTHandle->TxLen = 0;

				//Call the application callback with event USART_EVENT_TX_CMPLT
				USART_ApplicationEventCallback(pUSARTHandle, USART_EVENT_TX_CMPLT);
			}
		}
	}

/* ************************ Check for TXE flag ******************************************* */

	//Check the state of TXE bit in the SR
	temp1 = pUSARTHandle->pUSARTx->SR & (1 << USART_SR_TXE);

	//Check the state of TXEIE bit in CR1
	temp2 = pUSARTHandle->pUSARTx->CR1 & (1 << USART_CR1_TXEIE);

	if(temp1 && temp2) {

		//This interrupt is because of TXE
		if(pUSARTHandle->TxBusyState == USART_BUSY_IN_TX) {

			//Keep sending data until TxLen reaches zero
			if(pUSARTHandle->TxLen > 0) {

				//Check the USART_WordLength item for 9 bit or 8 bit in a frame
				if(pUSARTHandle->USART_Config.USART_WordLength == USART_WORDLEN_9BITS) {

					//9 Bit Data Transfer

					//If 9 bits, load DR with 2 bytes, masking the bits other than the first 9 bits
					pdata = (uint16_t*) pUSARTHandle->pTxBuffer;
					pUSARTHandle->pUSARTx->DR = (*pdata & (uint16_t) 0x01FF);

					//Check for USART_ParityControl
					if(pUSARTHandle->USART_Config.USART_ParityControl == USART_PARITY_DISABLE) {

						//9 Bit Data Transfer
						//No parity is used in this transfer, so 9 bits of user data will be sent
						//Increment the buffer address twice
						pUSARTHandle->pTxBuffer++;
						pUSARTHandle->pTxBuffer++;
						pUSARTHandle->TxLen -= 2;

					} else {
						//Parity bit is used in this transfer, so 8 bits of user data will be sent
						//The 9th bit will be replaced with parity bit by the hardware

						//Increment the buffer address
						pUSARTHandle->pTxBuffer++;
						pUSARTHandle->TxLen -= 1;
					}

				} else {

					//8 Bit Data Transfer

					pUSARTHandle->pUSARTx->DR = (*pUSARTHandle->pTxBuffer & (uint8_t) 0xFF);

					//Increment the buffer address
					pUSARTHandle->pTxBuffer++;
					pUSARTHandle->TxLen -= 1;
				}
			}

			if (pUSARTHandle->TxLen == 0) {
				//TxLen is zero
				//Clear the TXEIE bit (disable interrupt for TXE flag )
				pUSARTHandle->pUSARTx->CR1 &= ~(1 << USART_CR1_TXEIE);
			}
		}
	}

/* ************************ Check for RXNE flag ******************************************* */
	//Check the state of RXNE bit in the SR
	temp1 = pUSARTHandle->pUSARTx->SR & (1 << USART_SR_RXNE);

	//Check the state of RXNEIE bit in CR1
	temp2 = pUSARTHandle->pUSARTx->CR1 & (1 << USART_CR1_RXNEIE);

	if(temp1 && temp2) {

		//This interrupt is because of RXNE
		if(pUSARTHandle->RxBusyState == USART_BUSY_IN_RX) {

			//Keep receiving data until RxLen reaches zero
			if(pUSARTHandle->RxLen > 0) {

				//Check the USART_WordLength item for 9 bit or 8 bit in a frame
				if(pUSARTHandle->USART_Config.USART_WordLength == USART_WORDLEN_9BITS) {

					//9 Bit Data Transfer

					//Check for USART_ParityControl
					if(pUSARTHandle->USART_Config.USART_ParityControl == USART_PARITY_DISABLE) {

						//No parity is used in this transfer, so 9 bits of user data will be sent
						//Read only first 9 bits so mask the DR with 0x01FF
						*((uint16_t*) pUSARTHandle->pRxBuffer) = (pUSARTHandle->pUSARTx->DR & (uint16_t) 0x01FF);

						//Increment the buffer address twice
						pUSARTHandle->pRxBuffer++;
						pUSARTHandle->pRxBuffer++;
						pUSARTHandle->RxLen -= 2;

					} else {
						//Parity bit is used in this transfer, so 8 bits of user data will be received
						//The 9th bit will be replaced with parity bit by the hardware
						*pUSARTHandle->pRxBuffer = (pUSARTHandle->pUSARTx->DR & (uint8_t) 0xFF);

						//Increment the buffer address
						pUSARTHandle->pRxBuffer++;
						pUSARTHandle->RxLen -= 1;
					}

				} else {

					//8 Bit Data Transfer

					//Check for USART_ParityControl
					if(pUSARTHandle->USART_Config.USART_ParityControl == USART_PARITY_DISABLE) {
						//No parity is used in this transfer, so 8 bits of user data will be received
						//Read 8 bits from DR
						*pUSARTHandle->pRxBuffer = (uint8_t) (pUSARTHandle->pUSARTx->DR & (uint8_t) 0xFF);

					} else {
						//Parity bit is used in this transfer, so 7 bits of user data will be received
						//The 8th bit will be replaced with parity bit by the hardware
						//Read only 7 bits, mask DR with 0x7F
						*pUSARTHandle->pRxBuffer = (uint8_t) (pUSARTHandle->pUSARTx->DR & (uint8_t) 0x7F);
					}

					//Increment the buffer address
					pUSARTHandle->pRxBuffer++;
					pUSARTHandle->RxLen -= 1;
				}
			}

			//If Len = 0
			if (!pUSARTHandle->RxLen) {
				//RxLen is zero
				//Clear the RXNEIE bit (disable interrupt for TXE flag )
				pUSARTHandle->pUSARTx->CR1 &= ~(1 << USART_CR1_RXNEIE);
				pUSARTHandle->RxBusyState = USART_READY;
				USART_ApplicationEventCallback(pUSARTHandle, USART_EVENT_RX_CMPLT);
			}
		}
	}

/* ***************************** Check for CTS flag ******************************************* */
//Note: CTS feature is not applicable for UART4 and UART5

	//Check status of CTS bit in SR
	temp1 = pUSARTHandle->pUSARTx->SR & (1 << USART_SR_CTS);

	//Check status of CTSE bit in CR3
	temp2 = pUSARTHandle->pUSARTx->CR3 & (1 << USART_CR3_CTSE);

	//Check status of CTSIE bit in CR3 (This bit is not available for UART4 and UART5)
	//temp3 = pUSARTHandle->pUSARTx->CR3 & (1 << USART_CR3_CTSIE);

	if(temp1 && temp2) {
		//Clear the CTS flag in SR
		pUSARTHandle->pUSARTx->SR &= ~(1 << USART_SR_CTS);

		//This interrupt is because of CTS
		USART_ApplicationEventCallback(pUSARTHandle, USART_EVENT_CTS);
	}

/* ************************ Check for IDLE detection flag *************************************** */

	//Check status of IDLE flag bit in SR
	temp1 = pUSARTHandle->pUSARTx->SR & (1 << USART_SR_IDLE);

	//Check status of IDLEIE bit in CR1
	temp2 = pUSARTHandle->pUSARTx->CR1 & (1 << USART_CR1_IDLEIE);

	if(temp1 && temp2) {
		//Clear the IDLE flag in SR. Refer to RM to understand clear sequence
		temp1 = pUSARTHandle->pUSARTx->SR &= ~(1 << USART_SR_IDLE);

		//This interrupt is because of IDLE
		USART_ApplicationEventCallback(pUSARTHandle, USART_EVENT_IDLE);
	}

/* ************************ Check for Overrun detection flag ************************************ */

	//Check status of ORE flag bit in SR
	temp1 = pUSARTHandle->pUSARTx->SR & USART_SR_ORE;

	//Check status of RXNEIE bit in CR1
	temp2 = pUSARTHandle->pUSARTx->CR1 & USART_CR1_RXNEIE;

	if(temp1 && temp2) {
		//Don't need to clear the ORE flag here, instead give an API for the application to clear the ORE flag

		//This interrupt is because of Overrun error
		USART_ApplicationEventCallback(pUSARTHandle, USART_ERR_ORE);
	}

/* ********************************* Check for Error flag *************************************** */
//Noise Flag, Overrun Error and Framing Error in multibuffer communication
//We don't discuss multibuffer communication in this course. Please refer to RM
//The below code will get executed only if multibuffer mode is used.

	temp2 = pUSARTHandle->pUSARTx->CR3 & (1 << USART_CR3_EIE);

	if(temp2) {
		temp1 = pUSARTHandle->pUSARTx->SR;

		if(temp1 & (1 << USART_SR_FE)) {
			//This bit is set by hardware when a de-synchronization, excessive noise or a break character
			//is detected. It is cleared by a software sequence (a read to USART_SR followed by a read to USART_DR)
			USART_ApplicationEventCallback(pUSARTHandle, USART_ERR_FE);
		}

		if(temp1 & (1 << USART_SR_NF)) {
			//This bit is set by hardware when noise is detected on a received frame. It is cleared by a software
			//sequence (a read to USART_SR followed by a read to USART_DR)
			USART_ApplicationEventCallback(pUSARTHandle, USART_ERR_NF);
		}

		if(temp1 & (1 << USART_SR_ORE)) {
			USART_ApplicationEventCallback(pUSARTHandle, USART_ERR_ORE);
		}
	}
}

/* Other Peripheral Control APIs */
/* ******************************************************************************
 * @fn					-  USART_PeripheralControl
 *
 * @brief				-  Enable or disable USARTx peripheral
 *
 * @param[in]			-  Base address of the USART peripheral
 * @param[in]			-  ENABLE or DISABLE macros
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void USART_PeripheralControl(USART_RegDef_t *pUSARTx, uint8_t State) {

	if(State == ENABLE) {
		pUSARTx->CR1 |= (1 << 13);

	} else {
		pUSARTx->CR1 &= ~(1 << 13);
	}
}

/* ******************************************************************************
 * @fn					-  USART_GetFlagStatus
 *
 * @brief				-  Retrieve flag status of USART peripheral
 *
 * @param[in]			-  Base address of the USART peripheral
 * @param[in]			-  Flag name
 *
 * @return				-  Byte containing flag status info
 *
 * @note				-  None
 *
 */
uint8_t USART_GetFlagStatus(USART_RegDef_t *pUSARTx, uint8_t FlagName) {

	if(pUSARTx->SR & FlagName) {
		return SET;
	}

	return RESET;
}

/* ******************************************************************************
 * @fn					-  USART_ClearFlag
 *
 * @brief				-  Clear flag of USART peripheral
 *
 * @param[in]			-  Base address of the USART peripheral
 * @param[in]			-  Flag name
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void USART_ClearFlag(USART_RegDef_t *pUSARTx, uint16_t FlagName) {

	pUSARTx->SR &= ~(FlagName);
}

/* ******************************************************************************
 * @fn					-  USART_SetBaudRate
 *
 * @brief				-  Sets Baud Rate (bits per second) of USART communication
 *
 * @param[in]			-  Base address of the USART peripheral
 * @param[in]			-  Baud rate
 *
 * @return				-  None
 *
 * @note				-  None
 *
 */
void USART_SetBaudRate(USART_RegDef_t *pUSARTx, uint32_t BaudRate) {

	//Variable to hold the APB clock
	uint32_t PCLKx;

	uint32_t usartdiv;

	//Variables to hold Mantissa and Fraction values
	uint32_t M_part, F_part;

	uint32_t tempreg = 0;

	//Get the value of APB bus clock into the variable PCLKx
	if((pUSARTx == USART1) || (pUSARTx == USART6)) {
		//USART1 and USART6 are hanging on APB2 bus
		PCLKx = RCC_GetPCLK2Value();
	} else {
		PCLKx = RCC_GetPCLK1Value();
	}

	//Check for Over8 configuration bit
	if(pUSARTx->CR1 & (1 << USART_CR1_OVER8)) {
		//Over8 = 1, over-sampling by 8
		usartdiv = ((25 * PCLKx) / (2 * BaudRate));
	} else {
		//Over8 = 0, over-sampling by 16
		usartdiv = ((25 * PCLKx) / (4 * BaudRate));
	}

	//Determine the Mantissa (Integer) part
	M_part = usartdiv / 100;

	//Store the Mantissa part
	tempreg = (M_part << 4);

	//Determine the Fractional part
	F_part = (usartdiv - (100 * M_part));

	//Store the Fractional part
	if(pUSARTx->CR1 & (1 << USART_CR1_OVER8)) {
		//Over8 = 1, over-sampling by 8
		tempreg |= (((F_part * 8) + 50) / 100) & ((uint8_t)0x07);
	} else {
		//Over8 = 0, over-sampling by 16
		tempreg |= (((F_part * 16) + 50) / 100) & ((uint8_t)0x0F);
	}

	//Copy the value of tempreg into BRR
	pUSARTx->BRR = (uint16_t)tempreg;
}

/* Application Callback */
/* ******************************************************************************
 * @fn					-  USART_ApplicationEventCallback
 *
 * @brief				-  Application Event Callback (weak implementation)
 *
 * @param[in]			-  Pointer to USART handle
 * @param[in]			-  Application event byte
 *
 * @return				-  None
 *
 * @note				-  Weak implementation
 *
 */
__weak void USART_ApplicationEventCallback(USART_Handle_t *pUSARTHandle, uint8_t AppEv) {

	//This is a weak implementation -- the application may override this function.
}

