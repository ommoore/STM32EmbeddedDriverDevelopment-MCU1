/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

/*
 *  Exercise: HSI Measurement
 *
 *  Write a program to output HSI clock on microcontroller pin and measure it using oscilloscope or logic analyzer.
 *
 *	Steps:
 *	1. Select the desired clock for the MCOx signal (Microcontroller Clock Output)
 *	2. Output the MCOx signal on the MCU pin
 *
 *	6.3.3 RCC clock configuration register (RCC_CFGR)
 *	Select HSI Clock for MCO1 (microcontroller clock output 1)
 *		> Bits 22:21 -> 00 (HSI clock selected)
 *
 *  PA8 alternate functionality:  MCO1 (AF0)
 *  PA8 is Pin 41 on the MCU (LQFP64 Package)
 *
 *
 *
 */

#include <stdint.h>

#define RCC_BASE_ADDR		0x40023800UL
#define RCC_CFGR_REG_OFFSET	0x08UL
#define RCC_CFGR_REG_ADDR	(RCC_BASE_ADDR + RCC_CFGR_REG_OFFSET)

#define GPIOA_BASE_ADDR		0x40020000UL

int main(void)
{
	uint32_t *pRccCfgrReg = (uint32_t*) RCC_CFGR_REG_ADDR;

    //1. Configure the RCC_CFGR MCO1 bit fields to select HSI as clock source
	*pRccCfgrReg &= ~(0x3 << 21);  // 0x3 = 0b11. Clearing bits 21 and 22

	//Configure MCO1 prescaler to divide by 4. Bits 26:24 we want to write 110.
	*pRccCfgrReg |= (1 << 26);
	*pRccCfgrReg |= (1 << 25);


	//2. Configure PA8 to AF0 mode to behave as MCO1 signal
	//a. Enable the peripheral clock for GPIOA peripheral
	uint32_t *pRccAhb1Enr = (uint32_t*)(RCC_BASE_ADDR + 0x30);
	*pRccAhb1Enr |= (1 << 0); //enable peripheral clock

	//b. Configure the mode of GPIOA pin 8 as alternate function mode
	uint32_t *pGPIOAModeReg = (uint32_t*)(GPIOA_BASE_ADDR + 0x00);
	*pGPIOAModeReg &= ~(0x3 << 16); //clear  0x3 = 0b11
	*pGPIOAModeReg |= (0x2 << 16); //set 0x2 = 0b10 -> 10 means alternate function. bits 16:17 is for pin8

	//c. Configure the alternate function register to set PA8 to mode 0
	uint32_t *pGPIOAAltFunHighReg = (uint32_t*)(GPIOA_BASE_ADDR + 0x24); //AFRH is for pins 8-15, AFRL is for pins 0-7
	*pGPIOAAltFunHighReg &= ~(0xF << 0); //clear 0xF = 0b1111  -> 0000: AF0

	for(;;);
}
